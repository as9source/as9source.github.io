<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- ã‚­ãƒ£ãƒƒã‚·ãƒ¥å¯¾ç­– -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
    <title>èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ </title>
    <!--
    ========================================
    èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ 
    ========================================
    ãƒãƒ¼ã‚¸ãƒ§ãƒ³: 1.17.4
    æœ€çµ‚æ›´æ–°: 2024-12-28
    
    [æ›´æ–°å±¥æ­´]
    v1.17.4 (2024-12-28)
    - æ®µå·®æ™‚ã®ç‚¹ã®é–“éš”ã‚’æ‹¡å¤§ï¼ˆé‡ãªã‚Šé˜²æ­¢ï¼‰
    - ä½œå›³ç”»é¢: 20px â†’ 32px
    - è¨ˆç®—çµæœ: 20px â†’ 30px
    
    v1.17.3 (2024-12-28)
    - ç‚¹ã®å½¢çŠ¶ï¼ˆâ–¼â– â˜…ï¼‰ã‚’ç´„1.4å€ã«æ‹¡å¤§
    - ä½œå›³ç”»é¢ã€è¨ˆç®—çµæœã®ä¸¡æ–¹ã§æ‹¡å¤§
    - ã‚ˆã‚Šè¦–èªæ€§ãŒå‘ä¸Š
    
    v1.17.2 (2024-12-28)
    - ç‚¹ã®å½¢çŠ¶ã‚’æœ€çµ‚èª¿æ•´
      ã‚³ãƒ¼ãƒŠãƒ¼: èµ¤â–¼ï¼ˆä¸‹å‘ãä¸‰è§’ï¼‰ãã®ã¾ã¾
      å£: ç·‘â– ï¼ˆæ­£æ–¹å½¢ï¼‰ã«å¤‰æ›´
      ã‚¨ãƒ³ãƒ‰: é’â˜…ï¼ˆæ˜Ÿï¼‰ã«å¤‰æ›´
    - ã‚ˆã‚Šè¦–è¦šçš„ã«è­˜åˆ¥ã—ã‚„ã™ãæ”¹å–„
    
    v1.17.1 (2024-12-28)
    - ç‚¹ã®å½¢çŠ¶ã‚’å¤‰æ›´ã—ã¦è­˜åˆ¥ã—ã‚„ã™ãæ”¹å–„
      ã‚³ãƒ¼ãƒŠãƒ¼: èµ¤â–¼ï¼ˆä¸‹å‘ãä¸‰è§’ï¼‰
      å£: ç·‘â—†ï¼ˆã²ã—å½¢ï¼‰
      ã‚¨ãƒ³ãƒ‰: é’â—ï¼ˆä¸¸ï¼‰
    
    v1.17.0 (2024-12-28)
    - è‡ªç”±ä½œå›³ã«ã€Œâœ‚ï¸ ç¸åˆ‡ã‚Šã€æ©Ÿèƒ½ã‚’è¿½åŠ 
    - ç‹¬ç«‹ã—ãŸè¤‡æ•°ã®ç·šã‚’å¼•ã‘ã‚‹ã‚ˆã†ã«ãªã£ãŸ
    - ç·šã¨ç·šã‚’ã‚³ãƒ¼ãƒŠãƒ¼ã§æ¥ç¶šã™ã‚‹ã‹ã€ç‹¬ç«‹ã•ã›ã‚‹ã‹ã‚’é¸æŠå¯èƒ½
    - ã‚¢ãƒ©ãƒ¼ãƒˆè¡¨ç¤ºæ©Ÿèƒ½ã‚’è¿½åŠ ï¼ˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€šçŸ¥ï¼‰
    
    v1.16.3 (2024-12-28)
    - ä¸‹éƒ¨ãƒœã‚¿ãƒ³ã€Œä¿å­˜ã€â†’ã€Œç¾å ´ã‚’ä¿å­˜ã€ã«å¤‰æ›´
    - ä¸Šéƒ¨ãƒœã‚¿ãƒ³ã®é…ç½®ã‚ºãƒ¬ã‚’ä¿®æ­£
    - ã™ã¹ã¦ã®ãƒœã‚¿ãƒ³ã‚¹ã‚¿ã‚¤ãƒ«ã‚’çµ±ä¸€
    
    v1.16.2 (2024-12-28)
    - ãƒœã‚¿ãƒ³é…ç½®ã‚’å¤‰æ›´
      ä¸Šéƒ¨: [ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠã«æˆ»ã‚‹] [ãƒ‘ã‚¿ãƒ¼ãƒ³ä¿å­˜] [ä½¿ã„æ–¹]
      ä¸‹éƒ¨: [ğŸ’¾ ä¿å­˜] [ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠã«æˆ»ã‚‹]
    
    v1.16.1 (2024-12-28)
    - å…±æœ‰æ™‚ã®è¨ˆç®—çµæœã«èº¯ä½“é«˜ã•ã‚’è¡¨ç¤º
    - èº¯ä½“é«˜ã•â‰¤1100ã®å ´åˆã€è¿½åŠ è¨ˆç®—å¼ã‚’è¡¨ç¤º
      (1100 - 20 - èº¯ä½“é«˜ã• = ç­”ãˆ)
      (1100 - 30 - èº¯ä½“é«˜ã• = ç­”ãˆ)
    
    v1.16.0 (2024-12-28)
    - å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã®ä¿å­˜æ©Ÿèƒ½ã‚’è¿½åŠ 
    - ä¿å­˜ãƒ‡ãƒ¼ã‚¿ä¸€è¦§ç”»é¢ã‚’è¿½åŠ 
    - ç¾å ´åãƒ»è‰²ã«ã‚ˆã‚‹æ¤œç´¢æ©Ÿèƒ½ã‚’è¿½åŠ 
    - ä¿å­˜ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ãƒ»ç·¨é›†ãƒ»å‰Šé™¤æ©Ÿèƒ½ã‚’å®Ÿè£…
    - ä¸Šæ›¸ãä¿å­˜ã«å¯¾å¿œ
    
    v1.15.1 (2024-12-28)
    - è‰²é¸æŠã«ã€Œãã®ä»–ã€ã‚’è¿½åŠ 
    - ã€Œã‚µãƒƒã‚·è‰²ã€â†’ã€Œè‰²ã€ã«åç§°å¤‰æ›´
    
    v1.15.0 (2024-12-28)
    - ã‚µãƒƒã‚·è‰²å…¥åŠ›æ¬„ã‚’è¿½åŠ ï¼ˆãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³å¼ï¼šB7, B1, YW, H2, S1ï¼‰
    - ç¾å ´åã¨ã‚µãƒƒã‚·è‰²ã‚’å¿…é ˆé …ç›®ã«è¨­å®š
    - æœªå…¥åŠ›æ™‚ã¯è¨ˆç®—çµæœã‚’è¡¨ç¤ºã—ãªã„
    - å…±æœ‰æ™‚ã«ç¾å ´åã¨ã‚µãƒƒã‚·è‰²ã‚’è¡¨ç¤º
    
    v1.14.4 (2024-12-28)
    - å…±æœ‰æ™‚ã®æ¡å¯¸å¯¸æ³•ï¼ˆå‚è€ƒï¼‰ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’å‰Šé™¤
    - è¨ˆç®—çµæœã‚’ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆåŒ–ï¼ˆãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºç¸®å°ã€ä½™ç™½å‰Šæ¸›ï¼‰
    - A4ã‚µã‚¤ã‚ºã«åã¾ã‚‹ã‚ˆã†æœ€é©åŒ–
    
    v1.14.3 (2024-12-28)
    - å…±æœ‰æ™‚ã®è¨ˆç®—çµæœã«è¨ˆç®—å¼ã‚’è¿½åŠ 
    - å„è¾ºã®è¨ˆç®—éç¨‹ãŒåˆ†ã‹ã‚‹ã‚ˆã†ã«è¡¨ç¤º
    
    v1.14.2 (2024-12-28)
    - å…±æœ‰æ™‚ã®å›³é¢è¡¨ç¤ºã‚’ä¿®æ­£ï¼ˆçœŸã£ç™½â†’æ­£å¸¸è¡¨ç¤ºï¼‰
    - canvasã‚’toDataURL()ã§ç”»åƒåŒ–ã—ã¦åŸ‹ã‚è¾¼ã¿
    
    v1.14.1 (2024-12-28)
    - ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠå¾Œã®æç”»ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚’æ”¹å–„
    - canvasã‚µã‚¤ã‚ºå–å¾—ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†è¿½åŠ 
    - ã€Œç‚¹ã—ã‹è¦‹ãˆãªã„ã€å•é¡Œã®æ ¹æœ¬çš„ãªä¿®æ­£
    
    v1.14.0 (2024-12-28)
    - ç¾å ´åå…¥åŠ›æ¬„ã‚’è¿½åŠ 
    - å…±æœ‰æ©Ÿèƒ½ã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ–
    - è¨ˆç®—çµæœã®ã¿ã‚’A4ã‚µã‚¤ã‚ºã§å…±æœ‰ï¼ˆæ¡å¯¸å¯¸æ³•ã‚’è–„ãè¨˜è¼‰ï¼‰
    - ãƒ‘ã‚¿ãƒ¼ãƒ³æç”»ã®ä¸å…·åˆä¿®æ­£ï¼ˆç‚¹ã—ã‹è¦‹ãˆãªã„å•é¡Œï¼‰
    
    v1.13.4 (2024-12-28)
    - ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠç”»é¢ã«ã€Œç›®æ¬¡ã«æˆ»ã‚‹ã€ãƒœã‚¿ãƒ³ã‚’è¿½åŠ 
    
    v1.13.3 (2024-12-28)
    - 90åº¦ï¼ˆç›´è§’ï¼‰ã®ã‚³ãƒ¼ãƒŠãƒ¼ã«ã¯è§’åº¦å…¥åŠ›æ¬„ã‚’è¡¨ç¤ºã—ãªã„
    - 90åº¦ä»¥å¤–ã®ã‚³ãƒ¼ãƒŠãƒ¼ã®ã¿è§’åº¦å…¥åŠ›æ¬„ã‚’è¡¨ç¤º
    
    v1.13.2 (2024-12-28)
    - è§’åº¦è‡ªå‹•è¨ˆç®—æ©Ÿèƒ½ã‚’å‰Šé™¤
    - è§’åº¦ã¯ç¾å ´ã§æ¸¬å®šã—ã¦æ‰‹å‹•å…¥åŠ›ã™ã‚‹ä»•æ§˜ã«å¤‰æ›´
    
    v1.13.1 (2024-12-28)
    - ã‚³ãƒ¼ãƒŠãƒ¼è§’åº¦è¨ˆç®—ã‚’ä¿®æ­£
    - ã‚³ãƒ¼ãƒŠãƒ¼ç‚¹ã‚’åŸºæº–ã«ã—ãŸæ­£ã—ã„è§’åº¦è¨ˆç®—ã«å¤‰æ›´
    - å…¨ã¦ã®ã‚³ãƒ¼ãƒŠãƒ¼ã§åŒã˜è§’åº¦ãŒè¨ˆç®—ã•ã‚Œã‚‹ã‚ˆã†ã«ä¿®æ­£
    
    v1.13.0 (2024-12-28)
    - ã‚³ãƒ¼ãƒŠãƒ¼ã”ã¨ã«è§’åº¦ã‚’è¡¨ç¤ºã™ã‚‹ä»•æ§˜ã«å¤‰æ›´
    - è¾ºã®å‚¾ãã§ã¯ãªãã‚³ãƒ¼ãƒŠãƒ¼ï¼ˆ2ã¤ã®è¾ºã®é–“ï¼‰ã®è§’åº¦ã‚’è¨ˆç®—
    - ä¸¡è¾ºã®èŠ¯å¯¸æ³•å…¥åŠ›å¾Œã«è‡ªå‹•ã§ã‚³ãƒ¼ãƒŠãƒ¼è§’åº¦ã‚’è¨ˆç®—
    
    v1.12.5 (2024-12-28)
    - è§’åº¦è¨ˆç®—å¾Œã«createInputs()ã‚’å‘¼ã°ãªã„ã‚ˆã†ä¿®æ­£
    - è§’åº¦å…¥åŠ›æ¬„ãŒãƒªã‚»ãƒƒãƒˆã•ã‚Œã‚‹å•é¡Œã‚’ä¿®æ­£
    
    v1.12.4 (2024-12-28)
    - æ–œã‚ç·šã®å…¥åŠ›æ¬„ã‚’ã€ŒèŠ¯å¯¸æ³•ã€ã«å¤‰æ›´
    - èŠ¯å¯¸æ³•å…¥åŠ›æ™‚ã«è§’åº¦ã‚’è‡ªå‹•è¨ˆç®—
    - å‚ç›´ãƒ»æ°´å¹³ç·šã¯ã€Œå¤–æ³•å¯¸æ³•ã€ã®ã¾ã¾ç¶­æŒ
    
    v1.12.3 (2024-12-28)
    - ä½œå›³æ™‚ã¯è§’åº¦ã‚’è‡ªå‹•å…¥åŠ›ã—ãªã„ä»•æ§˜ã«å¤‰æ›´
    - å¤–æ³•å¯¸æ³•å…¥åŠ›å¾Œã«è§’åº¦ã‚’è‡ªå‹•è¨ˆç®—ã—ã¦è¡¨ç¤º
    - æ°´å¹³ãƒ»å‚ç›´ç·šãŒãªã„å ´åˆã¯æ‰‹å‹•å…¥åŠ›
    
    v1.12.2 (2024-12-28)
    - å½¢çŠ¶å…¨ä½“ã‹ã‚‰æ°´å¹³ãƒ»å‚ç›´ç·šã‚’æ¤œç´¢ã—ã¦è§’åº¦è¨ˆç®—
    - ç›´æ¥éš£æ¥ã—ã¦ã„ãªã„æ°´å¹³ãƒ»å‚ç›´ç·šã§ã‚‚è§’åº¦é€†ç®—å¯èƒ½
    - è¤‡æ•°ã®äº¤ç‚¹å€™è£œã‹ã‚‰æœ€é©ãªè§’åº¦ã‚’è‡ªå‹•é¸æŠ
    
    v1.12.1 (2024-12-28)
    - éš£æ¥ã™ã‚‹æ°´å¹³ãƒ»å‚ç›´ç·šã‹ã‚‰æ–œã‚è§’åº¦ã‚’è‡ªå‹•è¨ˆç®—
    - å»¶é•·ç·šã®äº¤ç‚¹ã‚’åˆ©ç”¨ã—ãŸè§’åº¦é€†ç®—æ©Ÿèƒ½ã‚’è¿½åŠ 
    - å¤–æ³•å¯¸æ³•å…¥åŠ›æ™‚ã«è‡ªå‹•ã§è§’åº¦ã‚’è¨ˆç®—ãƒ»è¡¨ç¤º
    
    v1.12.0 (2024-12-28)
    - æ–œã‚ã‚³ãƒ¼ãƒŠãƒ¼ã®è‡ªå‹•æ¤œå‡ºã¨è­¦å‘Šæ©Ÿèƒ½ã‚’è¿½åŠ 
    - ã‚³ãƒ¼ãƒŠãƒ¼è§’åº¦ã®è‡ªå‹•è¨ˆç®—ã¨è¡¨ç¤ºæ©Ÿèƒ½ã‚’è¿½åŠ 
    - ç‚¹ã®ç¨®é¡ã«é–¢ã‚ã‚‰ãšæ–œã‚ã‚³ãƒ¼ãƒŠãƒ¼ã‚’æ¤œå‡º
    - è§’åº¦å…¥åŠ›æ¬„ã‚’ã‚³ãƒ¼ãƒŠãƒ¼ã”ã¨ã«è¿½åŠ ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå¤‰æ›´å¯èƒ½ï¼‰
    
    v1.11.1 (2024-12-27)
    - ä½¿ã„æ–¹ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ã‚’è¿½åŠ ï¼ˆmodalè¡¨ç¤ºï¼‰
    - ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠç”»é¢ã«ã€Œâ“ ä½¿ã„æ–¹ã€ãƒœã‚¿ãƒ³ã‚’è¿½åŠ 
    - æ¡å¯¸ç”»é¢ã«ã‚‚ã€Œâ“ ä½¿ã„æ–¹ã€ãƒœã‚¿ãƒ³ã‚’è¿½åŠ 
    
    v1.11.0 (2024-12-27)
    - ç›´ç·šãŒä¸¦ã‚“ã å ´åˆã«è¨ˆç®—çµæœã®å›³ãŒè¡¨ç¤ºã•ã‚Œãªã„å•é¡Œã‚’ä¿®æ­£
    - ãƒ•ã‚¡ã‚¤ãƒ«åå…¥åŠ›æ¬„ã‚’å‰Šé™¤
    - ä¿å­˜ç¯„å›²ãƒˆã‚°ãƒ«ã‚’å‰Šé™¤
    ========================================
    -->
    <!-- jsPDF ãƒ©ã‚¤ãƒ–ãƒ©ãƒªï¼ˆPDFä¿å­˜ç”¨ï¼‰ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- html2canvas ãƒ©ã‚¤ãƒ–ãƒ©ãƒªï¼ˆãƒšãƒ¼ã‚¸å…¨ä½“ã‚­ãƒ£ãƒ—ãƒãƒ£ç”¨ï¼‰ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, 'Hiragino Kaku Gothic ProN', sans-serif;
            background: #f5f7fa;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 700px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            padding: 40px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }
        
        h1 {
            text-align: center;
            color: #1a1a1a;
            margin-bottom: 40px;
            font-size: 28px;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        
        h2 {
            color: #1a1a1a;
            margin: 30px 0 20px;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            opacity: 0.6;
        }
        
        /* ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠç”»é¢ */
        .pattern-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }
        
        .pattern-btn {
            background: white;
            color: #1a1a1a;
            border: 2px solid #e5e7eb;
            padding: 24px 16px;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            min-height: 110px;
        }
        
        .pattern-btn svg {
            width: 50px;
            height: 50px;
        }
        
        .pattern-btn:hover {
            border-color: #3b82f6;
            background: #f0f9ff;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.15);
        }
        
        .pattern-btn:active {
            transform: translateY(0);
        }
        
        .pattern-btn.custom {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
            grid-column: 1 / -1;
        }
        
        .pattern-btn.custom:hover {
            background: #2563eb;
            border-color: #2563eb;
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.25);
        }
        
        .pattern-btn .delete-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .pattern-btn .delete-btn:hover {
            background: #dc2626;
            transform: scale(1.1);
        }
        
        /* æ¡å¯¸ç”»é¢ */
        .measurement-screen {
            display: none;
        }
        
        .back-btn {
            background: #f3f4f6;
            color: #1a1a1a;
            border: 1px solid #e5e7eb;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 20px;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        
        .back-btn:hover {
            background: #e5e7eb;
            border-color: #d1d5db;
        }
        
        .drawing-area {
            position: relative;
            width: 100%;
            height: 400px;
            background: #f9fafb;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            margin: 20px 0;
            overflow: hidden;
            touch-action: none;
        }
        
        canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }
        
        .dimension-inputs {
            margin: 20px 0;
        }
        
        .dimension-item {
            background: #f9fafb;
            padding: 16px;
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            margin-bottom: 12px;
        }
        
        .dimension-item label {
            display: block;
            color: #1a1a1a;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .dimension-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .dimension-row input {
            padding: 10px 12px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            font-size: 15px;
            transition: all 0.2s ease;
        }
        
        .dimension-row input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        .results {
            background: #f9fafb;
            padding: 20px;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            margin-top: 20px;
        }
        
        .result-item {
            padding: 12px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .result-label {
            color: #555;
            font-weight: bold;
        }
        
        .result-value {
            color: #667eea;
            font-weight: bold;
            font-size: 18px;
        }
        
        .save-pattern-btn {
            width: 100%;
            background: #10b981;
            color: white;
            border: none;
            padding: 14px;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.2s ease;
        }
        
        .save-pattern-btn:hover {
            background: #059669;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.25);
        }
        
        .alert {
            background: #fff3cd;
            color: #856404;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #ffc107;
        }
        
        .success {
            background: #d4edda;
            color: #155724;
            border-left-color: #28a745;
        }
        
        /* ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ãƒ¢ãƒ¼ãƒ€ãƒ« */
        .manual-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            overflow-y: auto;
        }
        
        .manual-content {
            background: white;
            max-width: 800px;
            margin: 20px auto;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        
        .manual-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #ef4444;
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .manual-close:hover {
            background: #dc2626;
            transform: scale(1.1);
        }
        
        .manual-content h1 {
            color: #1e40af;
            border-bottom: 3px solid #3b82f6;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        
        .manual-content h2 {
            color: #2563eb;
            margin-top: 30px;
            margin-bottom: 15px;
        }
        
        .manual-content h3 {
            color: #3b82f6;
            margin-top: 20px;
            margin-bottom: 10px;
        }
        
        .manual-content pre {
            background: #f3f4f6;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            border-left: 4px solid #3b82f6;
        }
        
        .manual-content ul, .manual-content ol {
            padding-left: 25px;
            line-height: 1.8;
        }
        
        .manual-content li {
            margin-bottom: 8px;
        }
        
        .manual-content strong {
            color: #1e40af;
        }
        
        /* ä¿å­˜ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¤ãƒ†ãƒ ã®ãƒ›ãƒãƒ¼åŠ¹æœï¼ˆNEW - v1.16.0ï¼‰ */
        .saved-data-item:hover {
            border-color: #3b82f6 !important;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
            transform: translateY(-2px);
        }
        
        /* ã‚¢ãƒ©ãƒ¼ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆNEW - v1.17.0ï¼‰ */
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠç”»é¢ -->
        <div id="pattern-select-screen">
            <h1>èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ </h1>
            
            <!-- ãƒœã‚¿ãƒ³ã‚¨ãƒªã‚¢ -->
            <div style="margin-bottom: 20px; text-align: center; display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                <button onclick="window.location.href='https://as9source.github.io/'" 
                   style="display: inline-block; padding: 10px 20px; background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%); color: white; border: none; border-radius: 8px; font-weight: bold; font-size: 14px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); cursor: pointer;">
                    â† ç›®æ¬¡ã«æˆ»ã‚‹
                </button>
                <button onclick="showSavedDataList()" 
                   style="display: inline-block; padding: 10px 20px; background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; border: none; border-radius: 8px; font-weight: bold; font-size: 14px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); cursor: pointer;">
                    ğŸ“‚ ä¿å­˜ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰é–‹ã
                </button>
                <button onclick="openManual()" 
                   style="display: inline-block; padding: 10px 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; font-weight: bold; font-size: 14px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); cursor: pointer;">
                    â“ ä½¿ã„æ–¹
                </button>
            </div>
            
            <h2>åŸºæœ¬ãƒ‘ã‚¿ãƒ¼ãƒ³</h2>
            <div class="pattern-grid">
                <button class="pattern-btn" onclick="selectPattern('i')">
                    <svg viewBox="0 0 60 60">
                        <line x1="10" y1="30" x2="50" y2="30" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                    </svg>
                    Iå­—
                </button>
                <button class="pattern-btn" onclick="selectPattern('l-left')">
                    <svg viewBox="0 0 60 60">
                        <line x1="15" y1="10" x2="15" y2="50" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                        <line x1="15" y1="10" x2="45" y2="10" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                    </svg>
                    å·¦Lå­—
                </button>
                <button class="pattern-btn" onclick="selectPattern('l-right')">
                    <svg viewBox="0 0 60 60">
                        <line x1="45" y1="10" x2="45" y2="50" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                        <line x1="15" y1="10" x2="45" y2="10" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                    </svg>
                    å³Lå­—
                </button>
                <button class="pattern-btn" onclick="selectPattern('u')">
                    <svg viewBox="0 0 60 60">
                        <line x1="15" y1="50" x2="15" y2="10" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                        <line x1="15" y1="10" x2="45" y2="10" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                        <line x1="45" y1="10" x2="45" y2="50" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                    </svg>
                    ã‚³ã®å­—
                </button>
            </div>
            
            <div id="saved-patterns-section" style="display: none;">
                <h2>ä¿å­˜æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³</h2>
                <div class="pattern-grid" id="saved-patterns-grid"></div>
            </div>
            
            <h2>ã‚«ã‚¹ã‚¿ãƒ ä½œå›³</h2>
            <div class="pattern-grid">
                <button class="pattern-btn custom" onclick="selectPattern('custom')">è‡ªç”±ã«ç·šã‚’å¼•ã</button>
            </div>
            
            <!-- ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ± -->
            <div style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #e5e7eb; text-align: center; color: #6b7280; font-size: 13px;">
                <div style="margin-bottom: 5px;">èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ  v1.17.4</div>
                <div>æœ€çµ‚æ›´æ–°: 2024-12-28</div>
            </div>
        </div>
        
        <!-- ä¿å­˜ãƒ‡ãƒ¼ã‚¿ãƒªã‚¹ãƒˆç”»é¢ï¼ˆNEW - v1.16.0ï¼‰ -->
        <div id="saved-data-screen" style="display: none;">
            <h1>ğŸ“‚ ä¿å­˜ãƒ‡ãƒ¼ã‚¿</h1>
            
            <button onclick="backToSelectFromSaved()" 
                style="margin-bottom: 20px; padding: 12px 24px; background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%); color: white; border: none; border-radius: 8px; font-weight: bold; font-size: 14px; cursor: pointer;">
                â† ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠã«æˆ»ã‚‹
            </button>
            
            <!-- æ¤œç´¢ãƒãƒ¼ -->
            <div style="margin-bottom: 20px; background: #f3f4f6; padding: 15px; border-radius: 8px;">
                <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 10px;">
                    <input type="text" id="search-site-name" placeholder="ğŸ” ç¾å ´åã§æ¤œç´¢" 
                           oninput="filterSavedData()"
                           style="padding: 10px; border: 2px solid #d1d5db; border-radius: 8px; font-size: 14px;">
                    <select id="search-color" onchange="filterSavedData()"
                            style="padding: 10px; border: 2px solid #d1d5db; border-radius: 8px; font-size: 14px; background: white;">
                        <option value="">ã™ã¹ã¦ã®è‰²</option>
                        <option value="B7">B7</option>
                        <option value="B1">B1</option>
                        <option value="YW">YW</option>
                        <option value="H2">H2</option>
                        <option value="S1">S1</option>
                        <option value="ãã®ä»–">ãã®ä»–</option>
                    </select>
                </div>
            </div>
            
            <!-- ä¿å­˜ãƒ‡ãƒ¼ã‚¿ä¸€è¦§ -->
            <div id="saved-data-list"></div>
            
            <!-- ãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆ -->
            <div id="no-saved-data" style="display: none; text-align: center; padding: 40px; color: #9ca3af;">
                <div style="font-size: 48px; margin-bottom: 16px;">ğŸ“­</div>
                <div style="font-size: 18px; font-weight: bold; margin-bottom: 8px;">ä¿å­˜ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“</div>
                <div style="font-size: 14px;">æ¡å¯¸ç”»é¢ã§ã€Œä¿å­˜ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã¨ãƒ‡ãƒ¼ã‚¿ãŒä¿å­˜ã•ã‚Œã¾ã™</div>
            </div>
        </div>
        
        <!-- æ¡å¯¸ç”»é¢ -->
        <div id="measurement-screen" class="measurement-screen">
            <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                <button onclick="backToSelect()" 
                   style="flex: 1; display: flex; align-items: center; justify-content: center; padding: 12px; background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%); color: white; border: none; border-radius: 8px; font-weight: bold; font-size: 14px; cursor: pointer; white-space: nowrap;">
                    â† ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠã«æˆ»ã‚‹
                </button>
                <button onclick="savePattern()" 
                   style="flex: 1; display: flex; align-items: center; justify-content: center; padding: 12px; background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: white; border: none; border-radius: 8px; font-weight: bold; font-size: 14px; cursor: pointer; white-space: nowrap;">
                    ğŸ“‹ ãƒ‘ã‚¿ãƒ¼ãƒ³ä¿å­˜
                </button>
                <button onclick="openManual()" 
                   style="flex: 1; display: flex; align-items: center; justify-content: center; padding: 12px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; font-weight: bold; font-size: 14px; cursor: pointer; white-space: nowrap;">
                    â“ ä½¿ã„æ–¹
                </button>
            </div>
            
            <h1 id="pattern-title">æ¡å¯¸å…¥åŠ›</h1>
            
            <!-- ç¾å ´åã¨ã‚µãƒƒã‚·è‰²å…¥åŠ›æ¬„ï¼ˆNEW - v1.15.0ï¼‰ -->
            <div style="background: #fff3cd; padding: 15px; border-radius: 8px; margin-bottom: 15px; border: 2px solid #ffc107;">
                <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 10px;">
                    <div>
                        <label style="display: block; color: #856404; font-weight: bold; margin-bottom: 8px; font-size: 14px;">
                            ğŸ“ ç¾å ´å <span style="color: #dc2626;">*å¿…é ˆ</span>
                        </label>
                        <input type="text" id="site-name" placeholder="ä¾‹: ã€‡ã€‡æ§˜é‚¸" 
                               oninput="checkRequiredFields()"
                               style="width: 100%; padding: 12px; border: 2px solid #ffc107; border-radius: 8px; font-size: 16px;">
                    </div>
                    <div>
                        <label style="display: block; color: #856404; font-weight: bold; margin-bottom: 8px; font-size: 14px;">
                            ğŸ¨ è‰² <span style="color: #dc2626;">*å¿…é ˆ</span>
                        </label>
                        <select id="sash-color" onchange="checkRequiredFields()"
                                style="width: 100%; padding: 12px; border: 2px solid #ffc107; border-radius: 8px; font-size: 16px; background: white; cursor: pointer;">
                            <option value="">é¸æŠã—ã¦ãã ã•ã„</option>
                            <option value="B7">B7</option>
                            <option value="B1">B1</option>
                            <option value="YW">YW</option>
                            <option value="H2">H2</option>
                            <option value="S1">S1</option>
                            <option value="ãã®ä»–">ãã®ä»–</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <div id="alert" class="alert" style="display: none;"></div>
            
            <div class="drawing-area">
                <canvas id="canvas"></canvas>
            </div>
            
            <div id="drawing-controls" style="display: none; margin-top: 10px; display: flex; gap: 10px; flex-wrap: wrap;">
                <button onclick="clearDrawing()" style="flex: 1; min-width: 110px; padding: 12px; background: #ef4444; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s ease;">ğŸ—‘ï¸ ã‚¯ãƒªã‚¢</button>
                <button onclick="undoLastLine()" style="flex: 1; min-width: 110px; padding: 12px; background: #f59e0b; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s ease;">â†¶ æˆ»ã‚‹</button>
                <button onclick="cutEdge()" style="flex: 1; min-width: 110px; padding: 12px; background: #8b5cf6; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s ease;">âœ‚ï¸ ç¸åˆ‡ã‚Š</button>
                <button onclick="finishDrawing()" style="flex: 1; min-width: 110px; padding: 12px; background: #10b981; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s ease;">âœ“ ä½œå›³çµ‚äº†</button>
            </div>
            
            <div class="dimension-inputs" id="dimension-inputs"></div>
            
            <div class="results">
                <h2>è¨ˆç®—çµæœ</h2>
                <div id="results-content">
                    <p style="color: #999; text-align: center;">å¯¸æ³•ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„</p>
                </div>
            </div>
            
            <!-- ä¸‹éƒ¨ãƒœã‚¿ãƒ³ï¼ˆv1.16.2ï¼‰ -->
            <div style="display: flex; gap: 10px; margin-top: 20px; padding-top: 20px; border-top: 2px solid #e5e7eb;">
                <button onclick="saveCurrentData()" 
                   style="flex: 1; display: flex; align-items: center; justify-content: center; padding: 14px; background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; border: none; border-radius: 8px; font-weight: bold; font-size: 15px; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    ğŸ’¾ ç¾å ´ã‚’ä¿å­˜
                </button>
                <button onclick="backToSelect()" 
                   style="flex: 1; display: flex; align-items: center; justify-content: center; padding: 14px; background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%); color: white; border: none; border-radius: 8px; font-weight: bold; font-size: 15px; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    â† ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠã«æˆ»ã‚‹
                </button>
            </div>
        </div>
    </div>
    
    <!-- ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="manual-modal" class="manual-modal">
        <div class="manual-content">
            <button class="manual-close" onclick="closeManual()">Ã—</button>
            
            <h1>ğŸ“± èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ  ä½¿ã„æ–¹ãƒãƒ‹ãƒ¥ã‚¢ãƒ«</h1>
            
            <h2>ğŸ¯ ã“ã®ã‚·ã‚¹ãƒ†ãƒ ã«ã¤ã„ã¦</h2>
            <p><strong>å¤–æ³•å¯¸æ³•ã‹ã‚‰èº¯ä½“èŠ¯å¯¸æ³•ã‚’è‡ªå‹•è¨ˆç®—ã—ã¾ã™ã€‚</strong></p>
            <p>ç¾å ´ã§æ¸¬ã£ãŸå¯¸æ³•ã‚’å…¥åŠ›ã™ã‚‹ã¨ã€æ–½å·¥ã«å¿…è¦ãªèŠ¯å¯¸æ³•ãŒè‡ªå‹•ã§è¨ˆç®—ã•ã‚Œã¾ã™ã€‚</p>
            
            <h2>ğŸ“ åŸºæœ¬çš„ãªæµã‚Œ</h2>
            <ol>
                <li><strong>ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’é¸ã¶</strong> - Iå­—ã€Lå­—ã€ã‚³ã®å­—ã€ã¾ãŸã¯è‡ªç”±ä½œå›³</li>
                <li><strong>å¯¸æ³•ã‚’å…¥åŠ›ã™ã‚‹</strong> - å¤–æ³•å¯¸æ³•ã€èº¯ä½“å¹…ã€èº¯ä½“é«˜ã•</li>
                <li><strong>è¨ˆç®—çµæœã‚’ç¢ºèªã™ã‚‹</strong> - èº¯ä½“èŠ¯å¯¸æ³•ãŒè‡ªå‹•è¨ˆç®—ã•ã‚Œã‚‹</li>
                <li><strong>ä¿å­˜ãƒ»å…±æœ‰ã™ã‚‹</strong> - PDFã€ç”»åƒã€ã¾ãŸã¯LINEãªã©ã§å…±æœ‰</li>
            </ol>
            
            <h2>ğŸ”´ ç‚¹ã®ç¨®é¡ã«ã¤ã„ã¦ï¼ˆé‡è¦ï¼‰</h2>
            <p>è¨ˆç®—çµæœã¯ç‚¹ã®ç¨®é¡ã«ã‚ˆã£ã¦å¤‰ã‚ã‚Šã¾ã™ï¼š</p>
            
            <h3>ğŸ”» èµ¤â–¼ï¼ˆã‚³ãƒ¼ãƒŠãƒ¼ï¼‰</h3>
            <ul>
                <li>2ã¤ã®è¾ºãŒæ¥ç¶šã™ã‚‹è§’</li>
                <li><strong>ä¸¡å´ã®è¾ºã®å¹…ã®åŠåˆ†ãšã¤ã‚’å¼•ã</strong></li>
            </ul>
            
            <h3>â­ é’â˜…ï¼ˆã‚¨ãƒ³ãƒ‰ï¼‰</h3>
            <ul>
                <li>è¾ºã®ç«¯ç‚¹ï¼ˆå£ãªã—ï¼‰</li>
                <li><strong>éš£æ¥ã™ã‚‹è¾ºã®å¹…ã‚’å¼•ã‹ãªã„</strong></li>
            </ul>
            
            <h3>ğŸŸ© ç·‘â– ï¼ˆå£ï¼‰</h3>
            <ul>
                <li>å£ã‚„æ®µå·®ã«æ¥ã™ã‚‹ç‚¹</li>
                <li><strong>éš£æ¥ã™ã‚‹è¾ºã®å¹…ã‚’å¼•ã‹ãªã„</strong></li>
            </ul>
            
            <h2>âš ï¸ ã‚ˆãã‚ã‚‹è³ªå•</h2>
            
            <h3>Q1: ç‚¹ã®è‰²ãŒå¤‰ã‚ã‚‰ãªã„</h3>
            <p><strong>A:</strong> ä½œå›³ç”»é¢ã®ç‚¹ã‚’ç›´æ¥ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚</p>
            
            <h3>Q2: è¨ˆç®—çµæœãŒè¡¨ç¤ºã•ã‚Œãªã„</h3>
            <p><strong>A:</strong> å¤–æ³•å¯¸æ³•ã€èº¯ä½“å¹…ã€èº¯ä½“é«˜ã•ãŒã™ã¹ã¦å…¥åŠ›ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚</p>
            
            <hr style="margin: 30px 0; border: none; border-top: 2px solid #e5e7eb;">
            
            <p style="text-align: center; color: #6b7280; margin-top: 30px;">ä½¿ã„æ–¹ã§å›°ã£ãŸã“ã¨ãŒã‚ã‚Œã°ã€ã“ã®ç”»é¢ã‚’è¦‹è¿”ã—ã¦ãã ã•ã„ã€‚</p>
        </div>
    </div>
    
    <script>
        let currentPattern = null;
        let lines = [];
        let dimensions = {};
        let isDrawing = false;
        let isDragging = false;
        let startPoint = null;
        let canvas, ctx;
        let drawingPoints = [];
        let lastClickTime = 0;
        let lastTapTime = 0;
        let commonWidth = null;
        let useIndividualWidth = false;
        let commonHeight = null;
        let corners = {};
        let isAfterCut = false;  // ç¸åˆ‡ã‚Šç›´å¾Œãƒ•ãƒ©ã‚°ï¼ˆv1.17.2ï¼‰
        
        // ã‚³ãƒ¼ãƒŠãƒ¼ã‚’æ¤œå‡º
        function detectCorners() {
            if (!corners) {
                corners = {};
            }
            
            if (!lines || lines.length === 0) {
                corners = {};
                return;
            }
            
            const newCorners = {};
            const tolerance = 5;
            
            lines.forEach((line, idx) => {
                if (!line) return;
                
                const startKey = findCornerKeyForDetection(line.x1, line.y1, tolerance, newCorners);
                if (!newCorners[startKey]) {
                    const oldCorner = corners[startKey];
                    newCorners[startKey] = { 
                        x: line.x1, 
                        y: line.y1, 
                        hasStep: oldCorner ? oldCorner.hasStep : false, 
                        depth: oldCorner ? oldCorner.depth : null,
                        angle: oldCorner ? oldCorner.angle : null,
                        lines: [] 
                    };
                }
                newCorners[startKey].lines.push({ lineId: line.id, point: 'start' });
                
                const endKey = findCornerKeyForDetection(line.x2, line.y2, tolerance, newCorners);
                if (!newCorners[endKey]) {
                    const oldCorner = corners[endKey];
                    newCorners[endKey] = { 
                        x: line.x2, 
                        y: line.y2, 
                        hasStep: oldCorner ? oldCorner.hasStep : false, 
                        depth: oldCorner ? oldCorner.depth : null,
                        angle: oldCorner ? oldCorner.angle : null,
                        lines: [] 
                    };
                }
                newCorners[endKey].lines.push({ lineId: line.id, point: 'end' });
            });
            
            corners = newCorners;
        }
        
        function findCornerKeyForDetection(x, y, tolerance, cornersObj) {
            for (const key in cornersObj) {
                const corner = cornersObj[key];
                const dist = Math.sqrt(Math.pow(x - corner.x, 2) + Math.pow(y - corner.y, 2));
                if (dist < tolerance) {
                    return key;
                }
            }
            return `${Math.round(x)},${Math.round(y)}`;
        }
        
        function findCornerKey(x, y, tolerance) {
            if (!corners) return `${Math.round(x)},${Math.round(y)}`;
            
            for (const key in corners) {
                const corner = corners[key];
                const dist = Math.sqrt(Math.pow(x - corner.x, 2) + Math.pow(y - corner.y, 2));
                if (dist < tolerance) {
                    return key;
                }
            }
            return `${Math.round(x)},${Math.round(y)}`;
        }
        
        window.onload = function() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            resizeCanvas();
            loadSavedPatterns();
        };
        
        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            // ã‚µã‚¤ã‚ºãŒå–å¾—ã§ããªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆv1.14.1ï¼‰
            const width = rect.width || canvas.parentElement?.clientWidth || 800;
            const height = rect.height || canvas.parentElement?.clientHeight || 600;
            
            canvas.width = width;
            canvas.height = height;
            
            if (lines.length > 0) {
                drawLines();
            }
        }
        
        function selectPattern(type) {
            currentPattern = type;
            document.getElementById('pattern-select-screen').style.display = 'none';
            document.getElementById('measurement-screen').style.display = 'block';
            
            lines = [];
            dimensions = {};
            drawingPoints = [];
            commonWidth = null;
            commonHeight = null;
            useIndividualWidth = false;
            currentSaveId = null; // æ–°è¦ä½œæˆæ™‚ã¯IDã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆv1.16.0ï¼‰
            
            // ç¾å ´åã¨è‰²ã‚’ã‚¯ãƒªã‚¢ï¼ˆv1.16.0ï¼‰
            document.getElementById('site-name').value = '';
            document.getElementById('sash-color').value = '';
            
            // canvasã‚µã‚¤ã‚ºã‚’ç¢ºå®Ÿã«è¨­å®šã—ã¦ã‹ã‚‰æç”»ï¼ˆv1.14.1ï¼‰
            setTimeout(() => {
                resizeCanvas();
                
                setTimeout(() => {
                    if (type === 'i') {
                        document.getElementById('pattern-title').textContent = 'Iå­—å‹ æ¡å¯¸';
                        createIPattern();
                    } else if (type === 'l-left') {
                        document.getElementById('pattern-title').textContent = 'å·¦Lå­—å‹ æ¡å¯¸';
                        createLPatternLeft();
                    } else if (type === 'l-right') {
                        document.getElementById('pattern-title').textContent = 'å³Lå­—å‹ æ¡å¯¸';
                        createLPatternRight();
                    } else if (type === 'u') {
                        document.getElementById('pattern-title').textContent = 'ã‚³ã®å­—å‹ æ¡å¯¸';
                        createUPattern();
                    } else if (type === 'custom') {
                        document.getElementById('pattern-title').textContent = 'è‡ªç”±ä½œå›³';
                        setupCustomDrawing();
                    } else {
                        loadCustomPattern(type);
                    }
                }, 50);
            }, 10);
        }
        
        function createIPattern() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const lineLength = Math.min(canvas.width, canvas.height) * 0.6;
            
            lines = [
                { 
                    id: 'A', 
                    x1: centerX - lineLength/2, y1: centerY, 
                    x2: centerX + lineLength/2, y2: centerY, 
                    name: 'è¾ºA', 
                    start: 'wall',
                    end: 'wall'
                }
            ];
            drawLines();
            createInputs();
            setupPointClickListener();
        }
        
        function createLPatternLeft() {
            const size = Math.min(canvas.width, canvas.height) * 0.5;
            const margin = Math.min(canvas.width, canvas.height) * 0.2;
            
            lines = [
                { 
                    id: 'A', 
                    x1: margin, y1: margin, 
                    x2: margin, y2: margin + size, 
                    name: 'è¾ºAï¼ˆç¸¦ï¼‰', 
                    start: 'corner',
                    end: 'wall'
                },
                { 
                    id: 'B', 
                    x1: margin, y1: margin, 
                    x2: margin + size, y2: margin, 
                    name: 'è¾ºBï¼ˆæ¨ªï¼‰', 
                    start: 'corner',
                    end: 'wall'
                }
            ];
            drawLines();
            createInputs();
            setupPointClickListener();
        }
        
        function createLPatternRight() {
            const size = Math.min(canvas.width, canvas.height) * 0.5;
            const margin = Math.min(canvas.width, canvas.height) * 0.2;
            
            lines = [
                { 
                    id: 'A', 
                    x1: margin, y1: margin, 
                    x2: margin + size, y2: margin, 
                    name: 'è¾ºAï¼ˆæ¨ªï¼‰', 
                    start: 'wall',
                    end: 'corner'
                },
                { 
                    id: 'B', 
                    x1: margin + size, y1: margin, 
                    x2: margin + size, y2: margin + size, 
                    name: 'è¾ºBï¼ˆç¸¦ï¼‰', 
                    start: 'corner',
                    end: 'wall'
                }
            ];
            drawLines();
            createInputs();
            setupPointClickListener();
        }
        
        function createUPattern() {
            const width = Math.min(canvas.width, canvas.height) * 0.5;
            const height = Math.min(canvas.width, canvas.height) * 0.4;
            const margin = Math.min(canvas.width, canvas.height) * 0.2;
            
            lines = [
                { 
                    id: 'A', 
                    x1: margin, y1: margin + height, 
                    x2: margin, y2: margin, 
                    name: 'è¾ºA', 
                    start: 'wall',
                    end: 'corner'
                },
                { 
                    id: 'B', 
                    x1: margin, y1: margin, 
                    x2: margin + width, y2: margin, 
                    name: 'è¾ºB', 
                    start: 'corner',
                    end: 'corner'
                },
                { 
                    id: 'C', 
                    x1: margin + width, y1: margin, 
                    x2: margin + width, y2: margin + height, 
                    name: 'è¾ºC', 
                    start: 'corner',
                    end: 'wall'
                }
            ];
            drawLines();
            createInputs();
            setupPointClickListener();
        }
        
        function setupPointClickListener() {
            canvas.removeEventListener('click', handlePointClick);
            canvas.removeEventListener('touchend', handlePointClickTouch);
            canvas.addEventListener('click', handlePointClick);
            canvas.addEventListener('touchend', handlePointClickTouch);
        }
        
        function handlePointClickTouch(e) {
            if (isDrawing || isDragging) return;
            if (drawingPoints.length > 0) return;
            
            e.preventDefault();
            const touch = e.changedTouches[0];
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (touch.clientX - rect.left) * scaleX;
            const y = (touch.clientY - rect.top) * scaleY;
            
            const clickRadius = 25;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                const distStart = Math.sqrt(Math.pow(x - line.x1, 2) + Math.pow(y - line.y1, 2));
                if (distStart < clickRadius) {
                    scrollToInput(line.id);
                    return;
                }
                
                const distEnd = Math.sqrt(Math.pow(x - line.x2, 2) + Math.pow(y - line.y2, 2));
                if (distEnd < clickRadius) {
                    scrollToInput(line.id);
                    return;
                }
                
                const distToLine = distanceToLineSegment(x, y, line.x1, line.y1, line.x2, line.y2);
                if (distToLine < 15) {
                    scrollToInput(line.id);
                    return;
                }
            }
        }
        
        function drawLines() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            detectCorners();
            
            if (lines.length === 0) return;
            
            const shouldTransform = currentPattern !== 'custom';
            
            let transform = (x, y) => ({ x, y });
            
            if (shouldTransform) {
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                lines.forEach(line => {
                    minX = Math.min(minX, line.x1, line.x2);
                    minY = Math.min(minY, line.y1, line.y2);
                    maxX = Math.max(maxX, line.x1, line.x2);
                    maxY = Math.max(maxY, line.y1, line.y2);
                });
                
                let shapeWidth = maxX - minX;
                let shapeHeight = maxY - minY;
                
                // å¹…ã¾ãŸã¯é«˜ã•ãŒ0ã®å ´åˆã®å¯¾ç­–ï¼ˆv1.14.0ï¼‰
                if (shapeWidth < 1) shapeWidth = 100;
                if (shapeHeight < 1) shapeHeight = 100;
                
                const margin = 50;
                const canvasWidth = canvas.width - margin * 2;
                const canvasHeight = canvas.height - margin * 2;
                const scaleX = canvasWidth / shapeWidth;
                const scaleY = canvasHeight / shapeHeight;
                const scale = Math.min(scaleX, scaleY, 1);
                const scaledWidth = shapeWidth * scale;
                const scaledHeight = shapeHeight * scale;
                const offsetX = margin + (canvasWidth - scaledWidth) / 2 - minX * scale;
                const offsetY = margin + (canvasHeight - scaledHeight) / 2 - minY * scale;
                
                transform = (x, y) => ({
                    x: x * scale + offsetX,
                    y: y * scale + offsetY
                });
            }
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 5;
            ctx.lineCap = 'round';
            
            lines.forEach((line, index) => {
                const p1 = transform(line.x1, line.y1);
                const p2 = transform(line.x2, line.y2);
                
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
                
                const midX = (p1.x + p2.x) / 2;
                const midY = (p1.y + p2.y) / 2;
                
                const dim = dimensions[line.id];
                if (dim && dim.length) {
                    ctx.font = 'bold 18px sans-serif';
                    ctx.fillStyle = '#3b82f6';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    const text = `${dim.length}`;
                    const metrics = ctx.measureText(text);
                    const padding = 8;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.fillRect(midX - metrics.width/2 - padding, midY - 12, metrics.width + padding*2, 24);
                    
                    ctx.fillStyle = '#3b82f6';
                    ctx.fillText(text, midX, midY);
                }
                
                ctx.font = 'bold 13px sans-serif';
                const textWidth = ctx.measureText(line.name).width;
                const padding = 8;
                const bgWidth = textWidth + padding * 2;
                const bgHeight = 20;
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.fillRect(midX - bgWidth/2, midY - bgHeight/2 - 35, bgWidth, bgHeight);
                
                ctx.fillStyle = '#333';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(line.name, midX, midY - 35);
            });
            
            const drawnCorners = new Set();
            
            if (corners) {
                for (const cornerKey in corners) {
                    const corner = corners[cornerKey];
                    
                    if (!corner || drawnCorners.has(cornerKey)) continue;
                    drawnCorners.add(cornerKey);
                    
                    if (!corner.lines || corner.lines.length === 0) continue;
                    
                    const firstLineRef = corner.lines[0];
                    const firstLine = lines.find(l => l.id === firstLineRef.lineId);
                    if (!firstLine) continue;
                    
                    const cornerX = corner.x !== undefined ? corner.x : (firstLine[firstLineRef.point === 'start' ? 'x1' : 'x2']);
                    const cornerY = corner.y !== undefined ? corner.y : (firstLine[firstLineRef.point === 'start' ? 'y1' : 'y2']);
                    
                    if (corner.hasStep && corner.lines.length >= 2) {
                        const line1Ref = corner.lines[0];
                        const line2Ref = corner.lines[1];
                        const line1 = lines.find(l => l.id === line1Ref.lineId);
                        const line2 = lines.find(l => l.id === line2Ref.lineId);
                        
                        if (line1 && line2) {
                            const state1 = line1[line1Ref.point] || 'wall';
                            const state2 = line2[line2Ref.point] || 'wall';
                            
                            const offset = 32;  // 20 â†’ 32ï¼ˆç‚¹ãŒå¤§ãããªã£ãŸãŸã‚ v1.17.4ï¼‰
                            
                            let dx1, dy1;
                            if (line1Ref.point === 'start') {
                                dx1 = line1.x2 - line1.x1;
                                dy1 = line1.y2 - line1.y1;
                            } else {
                                dx1 = line1.x1 - line1.x2;
                                dy1 = line1.y1 - line1.y2;
                            }
                            const len1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
                            
                            let dx2, dy2;
                            if (line2Ref.point === 'start') {
                                dx2 = line2.x2 - line2.x1;
                                dy2 = line2.y2 - line2.y1;
                            } else {
                                dx2 = line2.x1 - line2.x2;
                                dy2 = line2.y1 - line2.y2;
                            }
                            const len2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                            
                            if (len1 > 0 && len2 > 0) {
                                const dirX1 = dx1 / len1;
                                const dirY1 = dy1 / len1;
                                const dirX2 = dx2 / len2;
                                const dirY2 = dy2 / len2;
                                
                                const p1 = transform(cornerX + dirX1 * offset, cornerY + dirY1 * offset);
                                const p2 = transform(cornerX + dirX2 * offset, cornerY + dirY2 * offset);
                                
                                drawPoint(p1.x, p1.y, state1);
                                drawPoint(p2.x, p2.y, state2);
                            } else {
                                const p = transform(cornerX, cornerY);
                                drawPoint(p.x, p.y, state1);
                            }
                        }
                    } else {
                        const state = firstLine[firstLineRef.point] || 'wall';
                        const p = transform(cornerX, cornerY);
                        drawPoint(p.x, p.y, state);
                    }
                }
            }
            
            drawingPoints.forEach((point, index) => {
                ctx.fillStyle = '#f39c12';
                ctx.beginPath();
                ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }
        
        function drawPoint(x, y, state) {
            const colors = {
                'corner': '#e74c3c',
                'end': '#3498db',
                'wall': '#2ecc71',
                'cut': '#f59e0b'  // ç¸åˆ‡ã‚Šç«¯ç‚¹ï¼šã‚ªãƒ¬ãƒ³ã‚¸ï¼ˆv1.17.2ï¼‰
            };
            
            const color = colors[state] || colors['end'];
            
            ctx.save();
            
            // å½¢çŠ¶ã«å¿œã˜ã¦æç”»ï¼ˆv1.17.3 - ã‚µã‚¤ã‚ºæ‹¡å¤§ï¼‰
            if (state === 'corner') {
                // ã‚³ãƒ¼ãƒŠãƒ¼: èµ¤ã„â–¼ï¼ˆä¸‹å‘ãä¸‰è§’å½¢ï¼‰
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(x, y + 14);                // ä¸‹ã®é ‚ç‚¹ï¼ˆ10â†’14ï¼‰
                ctx.lineTo(x - 14, y - 11);           // å·¦ä¸Šï¼ˆ-10/-8 â†’ -14/-11ï¼‰
                ctx.lineTo(x + 14, y - 11);           // å³ä¸Šï¼ˆ+10/-8 â†’ +14/-11ï¼‰
                ctx.closePath();
                ctx.fill();
                
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 4;                    // 3â†’4
                ctx.stroke();
                
            } else if (state === 'wall') {
                // å£: ç·‘ã®â– ï¼ˆæ­£æ–¹å½¢ï¼‰
                ctx.fillStyle = color;
                ctx.fillRect(x - 14, y - 14, 28, 28); // 20x20 â†’ 28x28
                
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 4;                    // 3â†’4
                ctx.strokeRect(x - 14, y - 14, 28, 28);
                
            } else if (state === 'cut') {
                // ç¸åˆ‡ã‚Šç«¯ç‚¹: é»„è‰²ã®â˜…ï¼ˆæ˜Ÿï¼‰
                ctx.fillStyle = color;
                ctx.beginPath();
                const outerRadius = 17;               // 12â†’17
                const innerRadius = 7;                // 5â†’7
                const spikes = 5;
                
                for (let i = 0; i < spikes * 2; i++) {
                    const angle = (i * Math.PI) / spikes - Math.PI / 2;
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    const px = x + Math.cos(angle) * radius;
                    const py = y + Math.sin(angle) * radius;
                    if (i === 0) {
                        ctx.moveTo(px, py);
                    } else {
                        ctx.lineTo(px, py);
                    }
                }
                ctx.closePath();
                ctx.fill();
                
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 4;                    // 3â†’4
                ctx.stroke();
                
            } else {
                // ã‚¨ãƒ³ãƒ‰: é’ã„â˜…ï¼ˆæ˜Ÿï¼‰
                ctx.fillStyle = color;
                ctx.beginPath();
                const outerRadius = 17;               // 12â†’17
                const innerRadius = 7;                // 5â†’7
                const spikes = 5;
                
                for (let i = 0; i < spikes * 2; i++) {
                    const angle = (i * Math.PI) / spikes - Math.PI / 2;
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    const px = x + Math.cos(angle) * radius;
                    const py = y + Math.sin(angle) * radius;
                    if (i === 0) {
                        ctx.moveTo(px, py);
                    } else {
                        ctx.lineTo(px, py);
                    }
                }
                ctx.closePath();
                ctx.fill();
                
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 4;                    // 3â†’4
                ctx.stroke();
            }
            
            ctx.restore();
        }
        
        // 2ã¤ã®ç·šãŒ90åº¦ã‹ã©ã†ã‹åˆ¤å®š
        function is90Degrees(line1, line2, point1, point2) {
            const dx1 = line1.x2 - line1.x1;
            const dy1 = line1.y2 - line1.y1;
            const dx2 = line2.x2 - line2.x1;
            const dy2 = line2.y2 - line2.y1;
            const dotProduct = dx1 * dx2 + dy1 * dy2;
            const magnitude1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
            const magnitude2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
            
            if (magnitude1 === 0 || magnitude2 === 0) return false;
            
            const cosAngle = dotProduct / (magnitude1 * magnitude2);
            return Math.abs(cosAngle) < 0.1;
        }
        
        // æ–œã‚ã‚³ãƒ¼ãƒŠãƒ¼ã‹ã©ã†ã‹åˆ¤å®šï¼ˆv1.12.0ï¼‰
        function isDiagonalCorner(line1, line2, point1, point2) {
            if (is90Degrees(line1, line2, point1, point2)) {
                return false;
            }
            const line1IsDiagonal = isLineDiagonal(line1);
            const line2IsDiagonal = isLineDiagonal(line2);
            return line1IsDiagonal || line2IsDiagonal;
        }
        
        // ã‚³ãƒ¼ãƒŠãƒ¼ã®è§’åº¦ã‚’è¨ˆç®—ï¼ˆv1.12.0 / v1.13.0ä¿®æ­£ï¼‰
        function getCornerAngle(line1, line2) {
            const angle1 = Math.atan2(line1.y2 - line1.y1, line1.x2 - line1.x1) * (180 / Math.PI);
            const angle2 = Math.atan2(line2.y2 - line2.y1, line2.x2 - line2.x1) * (180 / Math.PI);
            let angleDiff = angle2 - angle1;
            while (angleDiff > 180) angleDiff -= 360;
            while (angleDiff < -180) angleDiff += 360;
            return Math.abs(angleDiff);
        }
        
        // ã‚³ãƒ¼ãƒŠãƒ¼ç‚¹ã‚’åŸºæº–ã«ã—ãŸè§’åº¦è¨ˆç®—ï¼ˆNEW - v1.13.1ï¼‰
        function getCornerAngleFromRefs(line1, line1Point, line2, line2Point) {
            // line1ã®ã‚³ãƒ¼ãƒŠãƒ¼ç‚¹ã¨ã‚‚ã†ä¸€æ–¹ã®ç«¯ç‚¹
            const corner1X = line1Point === 'start' ? line1.x1 : line1.x2;
            const corner1Y = line1Point === 'start' ? line1.y1 : line1.y2;
            const other1X = line1Point === 'start' ? line1.x2 : line1.x1;
            const other1Y = line1Point === 'start' ? line1.y2 : line1.y1;
            
            // line2ã®ã‚³ãƒ¼ãƒŠãƒ¼ç‚¹ã¨ã‚‚ã†ä¸€æ–¹ã®ç«¯ç‚¹
            const corner2X = line2Point === 'start' ? line2.x1 : line2.x2;
            const corner2Y = line2Point === 'start' ? line2.y1 : line2.y2;
            const other2X = line2Point === 'start' ? line2.x2 : line2.x1;
            const other2Y = line2Point === 'start' ? line2.y2 : line2.y1;
            
            // ã‚³ãƒ¼ãƒŠãƒ¼ã‹ã‚‰ã‚‚ã†ä¸€æ–¹ã®ç«¯ç‚¹ã¸ã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«
            const dx1 = other1X - corner1X;
            const dy1 = other1Y - corner1Y;
            const dx2 = other2X - corner2X;
            const dy2 = other2Y - corner2Y;
            
            // å†…ç©ã‚’ä½¿ã£ã¦è§’åº¦ã‚’è¨ˆç®—
            const dot = dx1 * dx2 + dy1 * dy2;
            const len1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
            const len2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
            
            if (len1 === 0 || len2 === 0) return 0;
            
            const cosAngle = dot / (len1 * len2);
            const angle = Math.acos(Math.max(-1, Math.min(1, cosAngle))) * (180 / Math.PI);
            
            return angle;
        }
        
        // ç·šãŒæ–œã‚ã‹ã©ã†ã‹åˆ¤å®š
        function isLineDiagonal(line) {
            const dx = Math.abs(line.x2 - line.x1);
            const dy = Math.abs(line.y2 - line.y1);
            const threshold = 5;
            return dx > threshold && dy > threshold;
        }
        
        // ç·šãŒæ°´å¹³ã‹ã©ã†ã‹åˆ¤å®šï¼ˆv1.12.1ï¼‰
        function isLineHorizontal(line) {
            const dy = Math.abs(line.y2 - line.y1);
            const threshold = 5;
            return dy < threshold;
        }
        
        // ç·šãŒå‚ç›´ã‹ã©ã†ã‹åˆ¤å®šï¼ˆv1.12.1ï¼‰
        function isLineVertical(line) {
            const dx = Math.abs(line.x2 - line.x1);
            const threshold = 5;
            return dx < threshold;
        }
        
        // ç·šã®è§’åº¦ã‚’è¨ˆç®—ï¼ˆåº¦ï¼‰
        function getLineAngle(line) {
            const dx = line.x2 - line.x1;
            const dy = line.y2 - line.y1;
            const radians = Math.atan2(dy, dx);
            return radians * (180 / Math.PI);
        }
        
        // å½¢çŠ¶å…¨ä½“ã‹ã‚‰æ°´å¹³ãƒ»å‚ç›´ç·šã®å»¶é•·äº¤ç‚¹ã§æ–œã‚ç·šã®è§’åº¦ã‚’è¨ˆç®—ï¼ˆNEW - v1.12.2ï¼‰
        function calculateAngleFromIntersection(diagonalLine) {
            if (!isLineDiagonal(diagonalLine)) return null;
            
            // å½¢çŠ¶å…¨ä½“ã‹ã‚‰å…¨ã¦ã®æ°´å¹³ç·šã¨å‚ç›´ç·šã‚’æ¢ã™
            const horizontalLines = [];
            const verticalLines = [];
            
            lines.forEach(line => {
                if (line.id === diagonalLine.id) return; // è‡ªåˆ†è‡ªèº«ã¯é™¤å¤–
                
                if (isLineHorizontal(line)) {
                    horizontalLines.push(line);
                }
                if (isLineVertical(line)) {
                    verticalLines.push(line);
                }
            });
            
            if (horizontalLines.length === 0 || verticalLines.length === 0) {
                return null; // æ°´å¹³ç·šã¾ãŸã¯å‚ç›´ç·šãŒãªã„
            }
            
            // æ–œã‚ç·šã®å§‹ç‚¹ã¨çµ‚ç‚¹ã€ãã‚Œãã‚Œã§æœ€é©ãªäº¤ç‚¹ã‚’æ¢ã™
            const candidates = [];
            
            // å§‹ç‚¹ã‹ã‚‰è¨ˆç®—
            const startPoint = { x: diagonalLine.x1, y: diagonalLine.y1 };
            const startResult = findBestIntersection(startPoint, horizontalLines, verticalLines);
            if (startResult) {
                candidates.push(startResult);
            }
            
            // çµ‚ç‚¹ã‹ã‚‰è¨ˆç®—
            const endPoint = { x: diagonalLine.x2, y: diagonalLine.y2 };
            const endResult = findBestIntersection(endPoint, horizontalLines, verticalLines);
            if (endResult) {
                candidates.push(endResult);
            }
            
            if (candidates.length === 0) return null;
            
            // æœ€ã‚‚å¦¥å½“ãªè§’åº¦ã‚’é¸æŠï¼ˆ0-90åº¦ã®ç¯„å›²å†…ã®ã‚‚ã®ï¼‰
            let bestAngle = null;
            for (const candidate of candidates) {
                const angle = candidate.angle;
                if (angle >= 0 && angle <= 90) {
                    if (bestAngle === null || Math.abs(angle - 45) < Math.abs(bestAngle - 45)) {
                        bestAngle = angle;
                    }
                }
            }
            
            return bestAngle;
        }
        
        // ç‚¹ã‹ã‚‰æœ€é©ãªæ°´å¹³ãƒ»å‚ç›´ç·šã®äº¤ç‚¹ã‚’è¦‹ã¤ã‘ã‚‹ï¼ˆNEW - v1.12.2ï¼‰
        function findBestIntersection(point, horizontalLines, verticalLines) {
            let bestResult = null;
            let minDistance = Infinity;
            
            // å…¨ã¦ã®æ°´å¹³ç·šã¨å‚ç›´ç·šã®çµ„ã¿åˆã‚ã›ã‚’è©¦ã™
            horizontalLines.forEach(hLine => {
                verticalLines.forEach(vLine => {
                    // äº¤ç‚¹ã‚’è¨ˆç®—ï¼ˆå‚ç›´ç·šã®xåº§æ¨™ã€æ°´å¹³ç·šã®yåº§æ¨™ï¼‰
                    const intersectionX = vLine.x1; // å‚ç›´ç·šã¯xåº§æ¨™ãŒä¸€å®š
                    const intersectionY = hLine.y1; // æ°´å¹³ç·šã¯yåº§æ¨™ãŒä¸€å®š
                    
                    // ç‚¹ã‹ã‚‰äº¤ç‚¹ã¾ã§ã®è·é›¢
                    const dx = Math.abs(point.x - intersectionX);
                    const dy = Math.abs(point.y - intersectionY);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // äº¤ç‚¹ãŒç‚¹ã«è¿‘ã™ãã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—ï¼ˆåŒã˜ä½ç½®ï¼‰
                    if (distance < 10) return;
                    
                    // è§’åº¦ã‚’è¨ˆç®—
                    if (dx === 0 || dy === 0) return; // æ°´å¹³ã¾ãŸã¯å‚ç›´ã®å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
                    
                    const angleRad = Math.atan2(dy, dx);
                    const angleDeg = Math.abs(angleRad * (180 / Math.PI));
                    
                    // ã‚ˆã‚Šè¿‘ã„äº¤ç‚¹ã‚’é¸æŠ
                    if (distance < minDistance) {
                        minDistance = distance;
                        bestResult = {
                            intersection: { x: intersectionX, y: intersectionY },
                            distance: distance,
                            angle: angleDeg,
                            horizontalLine: hLine,
                            verticalLine: vLine
                        };
                    }
                });
            });
            
            return bestResult;
        }
        
        function createInputs() {
            const container = document.getElementById('dimension-inputs');
            container.innerHTML = '';
            
            detectCorners();
            
            const infoDiv = document.createElement('div');
            infoDiv.style.cssText = 'background: #e3f2fd; padding: 12px; border-radius: 8px; margin-bottom: 15px;';
            infoDiv.innerHTML = `
                <p style="margin: 0; color: #555; font-size: 14px; line-height: 1.6;">
                    <span style="color: #e74c3c; font-size: 16px;">â–¼</span> <strong>èµ¤ã„ä¸‰è§’ï¼ã‚³ãƒ¼ãƒŠãƒ¼</strong>ï¼ˆèº¯ä½“å¹…Ã·2ã‚’å¼•ãï¼‰ã€€
                    <span style="color: #3498db; font-size: 16px;">â˜…</span> <strong>é’ã„æ˜Ÿï¼ã‚¨ãƒ³ãƒ‰</strong>ï¼ˆå£ãªã—ï¼‰ã€€
                    <span style="color: #2ecc71; font-size: 16px;">â– </span> <strong>ç·‘ã®å››è§’ï¼å£</strong>ï¼ˆå£ã‚ã‚Šï¼‰
                </p>
            `;
            container.appendChild(infoDiv);
            
            const widthDiv = document.createElement('div');
            widthDiv.style.cssText = 'background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px;';
            widthDiv.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                    <div>
                        <label style="display: block; color: #555; font-weight: bold; margin-bottom: 8px;">èº¯ä½“å¹… (mm)</label>
                        <input type="number" id="common-width" placeholder="ä¾‹: 180" value="${commonWidth || ''}" 
                               oninput="updateCommonWidth(this.value)" 
                               style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px;">
                    </div>
                    <div>
                        <label style="display: block; color: #555; font-weight: bold; margin-bottom: 8px;">èº¯ä½“é«˜ã• (mm)</label>
                        <input type="number" id="common-height" placeholder="ä¾‹: 1100" value="${commonHeight || ''}" 
                               oninput="updateCommonHeight(this.value)" 
                               style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px;">
                    </div>
                </div>
                <div>
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="individual-width-check" ${useIndividualWidth ? 'checked' : ''} 
                               onchange="toggleIndividualWidth(this.checked)"
                               style="width: 18px; height: 18px; margin-right: 8px; cursor: pointer;">
                        <span style="color: #555; font-size: 14px;">è¾ºã”ã¨ã«èº¯ä½“å¹…ã‚’è¨­å®š</span>
                    </label>
                </div>
            `;
            container.appendChild(widthDiv);
            
            lines.forEach((line, lineIndex) => {
                const div = document.createElement('div');
                div.className = 'dimension-item';
                div.setAttribute('data-line-id', line.id);
                
                const startKey = findCornerKey(line.x1, line.y1, 5);
                const endKey = findCornerKey(line.x2, line.y2, 5);
                const startCorner = corners[startKey];
                const endCorner = corners[endKey];
                
                const startHasStep = startCorner && startCorner.hasStep;
                const endHasStep = endCorner && endCorner.hasStep;
                
                let startState = line.start || 'wall';
                let endState = line.end || 'wall';
                
                const isDiagonal = isLineDiagonal(line);
                
                const widthInput = useIndividualWidth ? `
                    <input type="number" placeholder="èº¯ä½“å¹… (mm)" 
                           oninput="updateDimension('${line.id}', 'width', this.value)"
                           value="${dimensions[line.id]?.width || ''}"
                           style="padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 16px;">
                ` : '';
                
                const pointButtons = `
                    <div style="display: flex; gap: 8px;">
                        <button onclick="changePointState('${line.id}', 'start')" style="padding: 6px 12px; background: ${getStateColor(startState)}; color: white; border: none; border-radius: 6px; font-size: 12px; font-weight: bold; cursor: pointer;">
                            å§‹ç‚¹: ${getStateLabel(startState)}
                        </button>
                        <button onclick="changePointState('${line.id}', 'end')" style="padding: 6px 12px; background: ${getStateColor(endState)}; color: white; border: none; border-radius: 6px; font-size: 12px; font-weight: bold; cursor: pointer;">
                            çµ‚ç‚¹: ${getStateLabel(endState)}
                        </button>
                    </div>
                `;

                // æ–œã‚ã‚³ãƒ¼ãƒŠãƒ¼ã®è­¦å‘Šãƒã‚§ãƒƒã‚¯ï¼ˆv1.12.0ï¼‰
                let diagonalCornerWarning = '';
                
                if (startCorner && startCorner.lines && startCorner.lines.length >= 2) {
                    for (let ref of startCorner.lines) {
                        if (ref.lineId !== line.id) {
                            const adjacentLine = lines.find(l => l.id === ref.lineId);
                            if (adjacentLine && isDiagonalCorner(line, adjacentLine, 'start', ref.point)) {
                                const cornerAngle = getCornerAngle(line, adjacentLine);
                                diagonalCornerWarning += `
                                    <div style="margin-top: 10px; padding: 12px; background: #fee; border: 2px solid #e74c3c; border-radius: 8px;">
                                        <p style="margin: 0; color: #c0392b; font-weight: bold; font-size: 14px;">
                                            âš ï¸ å§‹ç‚¹ã¯æ–œã‚ã‚³ãƒ¼ãƒŠãƒ¼ã§ã™ï¼ˆè§’åº¦: ${cornerAngle.toFixed(1)}Â°ï¼‰
                                        </p>
                                        <p style="margin: 5px 0 0 0; color: #c0392b; font-size: 13px;">
                                            å¤–æ³•å¯¸æ³•ã‹ã‚‰èŠ¯å¯¸æ³•ã‚’è¨ˆç®—ã§ãã¾ã›ã‚“ã€‚<br>
                                            <strong>ç¾åœ°ã§èŠ¯å¯¸æ³•ã‚’ç›´æ¥æ¸¬å®šã—ã¦ãã ã•ã„ã€‚</strong>
                                        </p>
                                    </div>
                                `;
                                break;
                            }
                        }
                    }
                }
                
                if (endCorner && endCorner.lines && endCorner.lines.length >= 2) {
                    for (let ref of endCorner.lines) {
                        if (ref.lineId !== line.id) {
                            const adjacentLine = lines.find(l => l.id === ref.lineId);
                            if (adjacentLine && isDiagonalCorner(line, adjacentLine, 'end', ref.point)) {
                                const cornerAngle = getCornerAngle(line, adjacentLine);
                                diagonalCornerWarning += `
                                    <div style="margin-top: 10px; padding: 12px; background: #fee; border: 2px solid #e74c3c; border-radius: 8px;">
                                        <p style="margin: 0; color: #c0392b; font-weight: bold; font-size: 14px;">
                                            âš ï¸ çµ‚ç‚¹ã¯æ–œã‚ã‚³ãƒ¼ãƒŠãƒ¼ã§ã™ï¼ˆè§’åº¦: ${cornerAngle.toFixed(1)}Â°ï¼‰
                                        </p>
                                        <p style="margin: 5px 0 0 0; color: #c0392b; font-size: 13px;">
                                            å¤–æ³•å¯¸æ³•ã‹ã‚‰èŠ¯å¯¸æ³•ã‚’è¨ˆç®—ã§ãã¾ã›ã‚“ã€‚<br>
                                            <strong>ç¾åœ°ã§èŠ¯å¯¸æ³•ã‚’ç›´æ¥æ¸¬å®šã—ã¦ãã ã•ã„ã€‚</strong>
                                        </p>
                                    </div>
                                `;
                                break;
                            }
                        }
                    }
                }

                div.innerHTML = `
                    <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <span style="font-weight: bold; color: #667eea;">${line.name}${isDiagonal ? ' <span style="color: #ff9800;">ğŸ“æ–œã‚</span>' : ''}</span>
                        ${pointButtons}
                    </label>
                    ${diagonalCornerWarning}
                    <div class="dimension-row" style="display: grid; grid-template-columns: ${useIndividualWidth ? '1fr 1fr' : '1fr'}; gap: 10px;">
                        <input type="number" placeholder="${isDiagonal ? 'èŠ¯å¯¸æ³• (mm)' : 'å¤–æ³•å¯¸æ³• (mm)'}" 
                               oninput="updateDimension('${line.id}', 'length', this.value)"
                               value="${dimensions[line.id]?.length || ''}"
                               style="padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 16px;">
                        ${widthInput}
                    </div>
                `;
                container.appendChild(div);
                
                if (!dimensions[line.id]) {
                    dimensions[line.id] = { length: null, width: null };
                }
                
                // ã‚³ãƒ¼ãƒŠãƒ¼è¨­å®šï¼ˆæ®µå·®+è§’åº¦ï¼‰ã‚’è¿½åŠ 
                if (endCorner && endCorner.lines.length >= 2 && lineIndex < lines.length - 1) {
                    const cornerDiv = document.createElement('div');
                    cornerDiv.style.cssText = 'margin: 10px 0 20px 0; padding: 12px; background: #e8f5e9; border-radius: 6px; border: 2px solid #4caf50;';
                    
                    const nextLine = lines[lineIndex + 1];
                    const cornerLabel = `${line.name}â”${nextLine.name}`;
                    
                    // ã‚³ãƒ¼ãƒŠãƒ¼ãŒ90åº¦ã‹ã©ã†ã‹åˆ¤å®šï¼ˆNEW - v1.13.3ï¼‰
                    const is90 = is90Degrees(line, nextLine, 'end', 'start');
                    
                    // 90åº¦ä»¥å¤–ã®å ´åˆã®ã¿è§’åº¦å…¥åŠ›æ¬„ã‚’è¡¨ç¤ºï¼ˆNEW - v1.13.3ï¼‰
                    const storedAngle = corners[endKey]?.angle;
                    const angleValue = storedAngle !== undefined && storedAngle !== null ? storedAngle.toFixed(1) : '';
                    
                    const angleInputSection = !is90 ? `
                        <div style="margin-bottom: 12px;">
                            <label style="display: block; color: #2e7d32; font-weight: bold; margin-bottom: 5px; font-size: 13px;">
                                ğŸ“ ${cornerLabel} ã‚³ãƒ¼ãƒŠãƒ¼ã®è§’åº¦ï¼ˆåº¦ï¼‰
                            </label>
                            <input type="number" 
                                   id="corner-angle-${endKey}"
                                   placeholder="ç¾å ´ã§æ¸¬å®šã—ãŸè§’åº¦ã‚’å…¥åŠ›" 
                                   value="${angleValue}"
                                   oninput="updateCornerAngle('${endKey}', this.value)"
                                   style="width: 100%; padding: 10px; border: 2px solid #4caf50; border-radius: 6px; font-size: 16px;">
                            <p style="margin: 5px 0 0 0; font-size: 12px; color: #2e7d32;">
                                â„¹ï¸ ç¾å ´ã§æ¸¬å®šã—ãŸè§’åº¦ã‚’æ‰‹å‹•ã§å…¥åŠ›ã—ã¦ãã ã•ã„
                            </p>
                        </div>
                    ` : '';
                    
                    cornerDiv.innerHTML = `
                        ${angleInputSection}
                        <label style="display: flex; align-items: center; cursor: pointer; margin-bottom: 8px;">
                            <input type="checkbox" ${endCorner.hasStep ? 'checked' : ''} 
                                   onchange="toggleCornerStep('${endKey}', this.checked)"
                                   style="width: 18px; height: 18px; margin-right: 8px; cursor: pointer;">
                            <span style="color: #2e7d32; font-weight: bold; font-size: 14px;">ğŸ“ ${cornerLabel} ã«æ®µå·®ã‚ã‚Š</span>
                        </label>
                        ${endCorner.hasStep ? `
                            <input type="number" placeholder="æ·±ã• (mm)" 
                                   value="${endCorner.depth || ''}"
                                   oninput="updateCornerDepth('${endKey}', this.value)"
                                   style="width: 100%; padding: 8px; border: 2px solid #4caf50; border-radius: 6px; font-size: 14px;">
                        ` : ''}
                    `;
                    container.appendChild(cornerDiv);
                }
            });
        }
        
        // è§’åº¦ã‚’æ›´æ–°
        function updateLineAngle(lineId, angleDegrees) {
            const lineIndex = lines.findIndex(line => line.id === lineId);
            if (lineIndex === -1) return;
            
            const line = lines[lineIndex];
            const angle = parseFloat(angleDegrees);
            if (isNaN(angle)) return;
            
            const dx = line.x2 - line.x1;
            const dy = line.y2 - line.y1;
            const length = Math.sqrt(dx * dx + dy * dy);
            
            const radians = angle * (Math.PI / 180);
            line.x2 = line.x1 + length * Math.cos(radians);
            line.y2 = line.y1 + length * Math.sin(radians);
            
            drawLines();
            createInputs();
        }
        
        function updateCommonWidth(value) {
            commonWidth = value ? parseFloat(value) : null;
            if (!useIndividualWidth) {
                lines.forEach(line => {
                    if (dimensions[line.id]) {
                        dimensions[line.id].width = commonWidth;
                    }
                });
                drawLines();
                calculate();
            }
        }
        
        function updateCommonHeight(value) {
            commonHeight = value ? parseFloat(value) : null;
            drawLines();
            calculate();
        }
        
        function toggleCornerStep(cornerKey, hasStep) {
            if (!corners[cornerKey]) return;
            
            corners[cornerKey].hasStep = hasStep;
            const corner = corners[cornerKey];
            
            if (!hasStep) {
                corners[cornerKey].depth = null;
                corner.lines.forEach(lineRef => {
                    const line = lines.find(l => l.id === lineRef.lineId);
                    if (line) {
                        line[lineRef.point] = 'corner';
                    }
                });
            } else {
                corner.lines.forEach((lineRef, index) => {
                    const line = lines.find(l => l.id === lineRef.lineId);
                    if (line) {
                        if (index === 0) {
                            line[lineRef.point] = 'end';
                        } else {
                            line[lineRef.point] = 'wall';
                        }
                    }
                });
            }
            
            drawLines();
            createInputs();
        }
        
        function updateCornerDepth(cornerKey, depth) {
            if (!corners[cornerKey]) return;
            corners[cornerKey].depth = depth ? parseFloat(depth) : null;
        }
        
        // ã‚³ãƒ¼ãƒŠãƒ¼ã®è§’åº¦ã‚’æ›´æ–°ï¼ˆNEW - v1.12.0ï¼‰
        function updateCornerAngle(cornerKey, angle) {
            if (!corners[cornerKey]) return;
            corners[cornerKey].angle = angle ? parseFloat(angle) : null;
            calculate();
        }
        
        function toggleIndividualWidth(checked) {
            useIndividualWidth = checked;
            if (!checked && commonWidth) {
                lines.forEach(line => {
                    if (dimensions[line.id]) {
                        dimensions[line.id].width = commonWidth;
                    }
                });
            }
            createInputs();
            drawLines();
            calculate();
        }
        
        function getStateColor(state) {
            const colors = {
                'corner': '#e74c3c',
                'end': '#3498db',
                'wall': '#2ecc71'
            };
            return colors[state] || colors['end'];
        }
        
        function getStateLabel(state) {
            const labels = {
                'corner': 'ã‚³ãƒ¼ãƒŠãƒ¼',
                'end': 'ã‚¨ãƒ³ãƒ‰',
                'wall': 'å£'
            };
            return labels[state] || labels['end'];
        }
        
        function changePointState(lineId, point) {
            const lineIndex = lines.findIndex(line => line.id === lineId);
            if (lineIndex === -1) return;
            
            const line = lines[lineIndex];
            const x = point === 'start' ? line.x1 : line.x2;
            const y = point === 'start' ? line.y1 : line.y2;
            const cornerKey = findCornerKey(x, y, 5);
            const corner = corners[cornerKey];
            
            const isClosed = lines.length > 0 && 
                Math.abs(lines[0].x1 - lines[lines.length - 1].x2) < 5 && 
                Math.abs(lines[0].y1 - lines[lines.length - 1].y2) < 5;
            
            const isFirstLineStart = (lineIndex === 0 && point === 'start' && !isClosed);
            const isLastLineEnd = (lineIndex === lines.length - 1 && point === 'end' && !isClosed);
            const hasStepAtCorner = corner && corner.hasStep;
            
            let states;
            if (isFirstLineStart || isLastLineEnd || hasStepAtCorner) {
                states = ['end', 'wall'];
            } else {
                states = ['corner', 'end', 'wall'];
            }
            
            const currentState = lines[lineIndex][point] || 'wall';
            const currentIndex = states.indexOf(currentState);
            const nextIndex = (currentIndex + 1) % states.length;
            lines[lineIndex][point] = states[nextIndex];
            
            if (lines[lineIndex][point] === 'corner') {
                autoSetCorners();
            }
            
            if (corner && corner.hasStep && corner.lines.length >= 2) {
                syncCornerStatesWithStep(cornerKey, lineId, point, lines[lineIndex][point]);
            }
            
            drawLines();
            createInputs();
            calculate();
        }
        
        function syncCornerStatesWithStep(cornerKey, changedLineId, changedPoint, newState) {
            const corner = corners[cornerKey];
            if (!corner) return;
            
            corner.lines.forEach(lineRef => {
                const line = lines.find(l => l.id === lineRef.lineId);
                if (!line) return;
                
                if (line.id !== changedLineId) {
                    if (newState === 'end') {
                        line[lineRef.point] = 'wall';
                    }
                }
            });
        }
        
        function updateDimension(id, type, value) {
            if (!dimensions[id]) {
                dimensions[id] = { length: null, width: null };
            }
            
            dimensions[id][type] = value ? parseFloat(value) : null;
            drawLines();
            calculate();
        }
        
        
        // ========================================
        // ä¿å­˜ãƒ‡ãƒ¼ã‚¿ç®¡ç†ï¼ˆNEW - v1.16.0ï¼‰
        // ========================================
        
        let currentSaveId = null; // ç¾åœ¨ç·¨é›†ä¸­ã®ãƒ‡ãƒ¼ã‚¿ID
        
        // ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
        function saveCurrentData() {
            const siteName = document.getElementById('site-name')?.value || '';
            const sashColor = document.getElementById('sash-color')?.value || '';
            
            if (!siteName) {
                alert('ç¾å ´åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }
            
            if (!sashColor) {
                alert('è‰²ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            // ä¿å­˜ãƒ‡ãƒ¼ã‚¿ã®æ§‹é€ 
            const saveData = {
                id: currentSaveId || Date.now().toString(),
                siteName: siteName,
                sashColor: sashColor,
                pattern: currentPattern,
                lines: JSON.parse(JSON.stringify(lines)),
                dimensions: JSON.parse(JSON.stringify(dimensions)),
                commonWidth: commonWidth,
                commonHeight: commonHeight,
                useIndividualWidth: useIndividualWidth,
                corners: JSON.parse(JSON.stringify(corners || {})),
                savedAt: new Date().toISOString(),
                updatedAt: new Date().toISOString()
            };
            
            // æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã®å–å¾—
            let savedDataList = JSON.parse(localStorage.getItem('kutai_saved_data') || '[]');
            
            // ä¸Šæ›¸ãã¾ãŸã¯æ–°è¦è¿½åŠ 
            const existingIndex = savedDataList.findIndex(data => data.id === saveData.id);
            if (existingIndex >= 0) {
                saveData.savedAt = savedDataList[existingIndex].savedAt; // ä½œæˆæ—¥æ™‚ã¯ä¿æŒ
                savedDataList[existingIndex] = saveData;
                alert('ãƒ‡ãƒ¼ã‚¿ã‚’ä¸Šæ›¸ãä¿å­˜ã—ã¾ã—ãŸ');
            } else {
                savedDataList.push(saveData);
                currentSaveId = saveData.id;
                alert('ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã—ã¾ã—ãŸ');
            }
            
            // ä¿å­˜
            localStorage.setItem('kutai_saved_data', JSON.stringify(savedDataList));
        }
        
        // ä¿å­˜ãƒ‡ãƒ¼ã‚¿ãƒªã‚¹ãƒˆç”»é¢ã‚’è¡¨ç¤º
        function showSavedDataList() {
            document.getElementById('pattern-select-screen').style.display = 'none';
            document.getElementById('measurement-screen').style.display = 'none';
            document.getElementById('saved-data-screen').style.display = 'block';
            
            displaySavedDataList();
        }
        
        // ä¿å­˜ãƒ‡ãƒ¼ã‚¿ãƒªã‚¹ãƒˆã‚’è¡¨ç¤º
        function displaySavedDataList() {
            const savedDataList = JSON.parse(localStorage.getItem('kutai_saved_data') || '[]');
            const listElement = document.getElementById('saved-data-list');
            const noDataElement = document.getElementById('no-saved-data');
            
            if (savedDataList.length === 0) {
                listElement.style.display = 'none';
                noDataElement.style.display = 'block';
                return;
            }
            
            listElement.style.display = 'block';
            noDataElement.style.display = 'none';
            
            // æ—¥ä»˜é †ã«ã‚½ãƒ¼ãƒˆï¼ˆæ–°ã—ã„é †ï¼‰
            savedDataList.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
            
            let html = '<div style="display: flex; flex-direction: column; gap: 12px;">';
            
            savedDataList.forEach(data => {
                const updatedDate = new Date(data.updatedAt).toLocaleDateString('ja-JP', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                
                html += `
                    <div class="saved-data-item" data-id="${data.id}" style="background: white; border: 2px solid #e5e7eb; border-radius: 8px; padding: 16px; cursor: pointer; transition: all 0.2s;">
                        <div style="display: flex; justify-content: space-between; align-items: start;">
                            <div onclick="loadSavedData('${data.id}')" style="flex: 1;">
                                <div style="font-size: 18px; font-weight: bold; color: #1f2937; margin-bottom: 8px;">
                                    ğŸ“ ${data.siteName} ï¼ ğŸ¨ ${data.sashColor}
                                </div>
                                <div style="font-size: 13px; color: #6b7280;">
                                    æ›´æ–°: ${updatedDate}
                                </div>
                            </div>
                            <button onclick="event.stopPropagation(); deleteSavedData('${data.id}')" 
                                style="padding: 8px 16px; background: #ef4444; color: white; border: none; border-radius: 6px; font-size: 13px; cursor: pointer;">
                                ğŸ—‘ï¸ å‰Šé™¤
                            </button>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            listElement.innerHTML = html;
        }
        
        // ä¿å­˜ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿
        function loadSavedData(id) {
            const savedDataList = JSON.parse(localStorage.getItem('kutai_saved_data') || '[]');
            const data = savedDataList.find(d => d.id === id);
            
            if (!data) {
                alert('ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                return;
            }
            
            // ç¾åœ¨ã®IDã‚’è¨­å®š
            currentSaveId = id;
            
            // ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è¨­å®š
            currentPattern = data.pattern;
            
            // ç”»é¢é·ç§»
            document.getElementById('saved-data-screen').style.display = 'none';
            document.getElementById('measurement-screen').style.display = 'block';
            
            // ãƒ‡ãƒ¼ã‚¿ã‚’å¾©å…ƒ
            lines = JSON.parse(JSON.stringify(data.lines));
            dimensions = JSON.parse(JSON.stringify(data.dimensions));
            commonWidth = data.commonWidth;
            commonHeight = data.commonHeight;
            useIndividualWidth = data.useIndividualWidth;
            corners = JSON.parse(JSON.stringify(data.corners || {}));
            
            // å…¥åŠ›å€¤ã‚’å¾©å…ƒ
            document.getElementById('site-name').value = data.siteName;
            document.getElementById('sash-color').value = data.sashColor;
            
            // ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚¿ã‚¤ãƒˆãƒ«è¨­å®š
            const patternTitles = {
                'i': 'Iå­—å‹ æ¡å¯¸',
                'l-left': 'å·¦Lå­—å‹ æ¡å¯¸',
                'l-right': 'å³Lå­—å‹ æ¡å¯¸',
                'u': 'ã‚³ã®å­—å‹ æ¡å¯¸',
                'custom': 'è‡ªç”±ä½œå›³'
            };
            document.getElementById('pattern-title').textContent = patternTitles[currentPattern] || 'æ¡å¯¸å…¥åŠ›';
            
            // canvasã‚µã‚¤ã‚ºè¨­å®šã¨æç”»
            setTimeout(() => {
                resizeCanvas();
                setTimeout(() => {
                    drawLines();
                    createInputs();
                    calculate();
                }, 50);
            }, 10);
        }
        
        // ä¿å­˜ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤
        function deleteSavedData(id) {
            if (!confirm('ã“ã®ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¦ã‚‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ')) {
                return;
            }
            
            let savedDataList = JSON.parse(localStorage.getItem('kutai_saved_data') || '[]');
            savedDataList = savedDataList.filter(data => data.id !== id);
            localStorage.setItem('kutai_saved_data', JSON.stringify(savedDataList));
            
            if (currentSaveId === id) {
                currentSaveId = null;
            }
            
            displaySavedDataList();
            alert('ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã—ãŸ');
        }
        
        // ä¿å­˜ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
        function filterSavedData() {
            const searchName = document.getElementById('search-site-name').value.toLowerCase();
            const searchColor = document.getElementById('search-color').value;
            
            const savedDataList = JSON.parse(localStorage.getItem('kutai_saved_data') || '[]');
            
            let filteredList = savedDataList;
            
            // ç¾å ´åã§ãƒ•ã‚£ãƒ«ã‚¿
            if (searchName) {
                filteredList = filteredList.filter(data => 
                    data.siteName.toLowerCase().includes(searchName)
                );
            }
            
            // è‰²ã§ãƒ•ã‚£ãƒ«ã‚¿
            if (searchColor) {
                filteredList = filteredList.filter(data => 
                    data.sashColor === searchColor
                );
            }
            
            const listElement = document.getElementById('saved-data-list');
            const noDataElement = document.getElementById('no-saved-data');
            
            if (filteredList.length === 0) {
                listElement.style.display = 'none';
                noDataElement.style.display = 'block';
                noDataElement.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #9ca3af;">
                        <div style="font-size: 48px; margin-bottom: 16px;">ğŸ”</div>
                        <div style="font-size: 18px; font-weight: bold; margin-bottom: 8px;">æ¤œç´¢çµæœãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“</div>
                        <div style="font-size: 14px;">åˆ¥ã®æ¤œç´¢æ¡ä»¶ã‚’ãŠè©¦ã—ãã ã•ã„</div>
                    </div>
                `;
                return;
            }
            
            listElement.style.display = 'block';
            noDataElement.style.display = 'none';
            
            // æ—¥ä»˜é †ã«ã‚½ãƒ¼ãƒˆ
            filteredList.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
            
            let html = '<div style="display: flex; flex-direction: column; gap: 12px;">';
            
            filteredList.forEach(data => {
                const updatedDate = new Date(data.updatedAt).toLocaleDateString('ja-JP', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                
                html += `
                    <div class="saved-data-item" data-id="${data.id}" style="background: white; border: 2px solid #e5e7eb; border-radius: 8px; padding: 16px; cursor: pointer; transition: all 0.2s;">
                        <div style="display: flex; justify-content: space-between; align-items: start;">
                            <div onclick="loadSavedData('${data.id}')" style="flex: 1;">
                                <div style="font-size: 18px; font-weight: bold; color: #1f2937; margin-bottom: 8px;">
                                    ğŸ“ ${data.siteName} ï¼ ğŸ¨ ${data.sashColor}
                                </div>
                                <div style="font-size: 13px; color: #6b7280;">
                                    æ›´æ–°: ${updatedDate}
                                </div>
                            </div>
                            <button onclick="event.stopPropagation(); deleteSavedData('${data.id}')" 
                                style="padding: 8px 16px; background: #ef4444; color: white; border: none; border-radius: 6px; font-size: 13px; cursor: pointer;">
                                ğŸ—‘ï¸ å‰Šé™¤
                            </button>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            listElement.innerHTML = html;
        }
        
        // ä¿å­˜ãƒ‡ãƒ¼ã‚¿ãƒªã‚¹ãƒˆã‹ã‚‰ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠã«æˆ»ã‚‹
        function backToSelectFromSaved() {
            document.getElementById('saved-data-screen').style.display = 'none';
            document.getElementById('pattern-select-screen').style.display = 'block';
            
            // æ¤œç´¢ãƒ•ã‚£ãƒ«ã‚¿ã‚’ãƒªã‚»ãƒƒãƒˆ
            document.getElementById('search-site-name').value = '';
            document.getElementById('search-color').value = '';
        }
        
        // ========================================
        
        
        // å¿…é ˆé …ç›®ãƒã‚§ãƒƒã‚¯ï¼ˆNEW - v1.15.0ï¼‰
        function checkRequiredFields() {
            calculate();
        }
        
        function calculate() {
            const resultsContent = document.getElementById('results-content');
            let html = '';
            let hasAll = true;
            let missingItems = [];
            
            // ç¾å ´åã¨ã‚µãƒƒã‚·è‰²ã®å¿…é ˆãƒã‚§ãƒƒã‚¯ï¼ˆNEW - v1.15.0ï¼‰
            const siteName = document.getElementById('site-name')?.value || '';
            const sashColor = document.getElementById('sash-color')?.value || '';
            
            if (!siteName) {
                hasAll = false;
                missingItems.push('ç¾å ´å');
            }
            
            if (!sashColor) {
                hasAll = false;
                missingItems.push('ã‚µãƒƒã‚·è‰²');
            }
            
            detectCorners();
            
            lines.forEach(line => {
                const dim = dimensions[line.id];
                
                if (!dim || !dim.length) {
                    hasAll = false;
                    missingItems.push(`${line.name}ã®å¤–æ³•å¯¸æ³•`);
                }
                
                const hasWidth = useIndividualWidth ? (dim && dim.width) : commonWidth;
                if (!hasWidth) {
                    hasAll = false;
                    if (useIndividualWidth) {
                        missingItems.push(`${line.name}ã®èº¯ä½“å¹…`);
                    } else if (!commonWidth) {
                        if (!missingItems.includes('èº¯ä½“å¹…')) {
                            missingItems.push('èº¯ä½“å¹…');
                        }
                    }
                }
            });
            
            if (!commonHeight) {
                hasAll = false;
                missingItems.push('èº¯ä½“é«˜ã•');
            }
            
            if (corners) {
                for (const cornerKey in corners) {
                    const corner = corners[cornerKey];
                    if (corner && corner.hasStep) {
                        if (!corner.depth) {
                            hasAll = false;
                            if (corner.lines && corner.lines.length >= 2) {
                                const line1 = lines.find(l => l.id === corner.lines[0].lineId);
                                const line2 = lines.find(l => l.id === corner.lines[1].lineId);
                                if (line1 && line2) {
                                    missingItems.push(`${line1.name}â”${line2.name}ã®æ®µå·®å¯¸æ³•`);
                                } else {
                                    missingItems.push('æ®µå·®å¯¸æ³•');
                                }
                            } else {
                                missingItems.push('æ®µå·®å¯¸æ³•');
                            }
                        }
                    }
                }
            }
            
            if (hasAll) {
                lines.forEach(line => {
                    const dim = dimensions[line.id];
                    let result = dim.length;
                    
                    if (line.start === 'corner') {
                        const adjacentWidth = getAdjacentLineWidth(line.id, 'start');
                        if (adjacentWidth > 0) {
                            result -= adjacentWidth / 2;
                        }
                    }
                    
                    if (line.end === 'corner') {
                        const adjacentWidth = getAdjacentLineWidth(line.id, 'end');
                        if (adjacentWidth > 0) {
                            result -= adjacentWidth / 2;
                        }
                    }
                    
                    const startLabel = getPointLabel(line.start);
                    const endLabel = getPointLabel(line.end);
                    
                    html += `
                        <div class="result-item">
                            <span class="result-label">${line.name} ${startLabel}â”${endLabel}</span>
                            <span class="result-value">${Math.floor(result)} mm</span>
                        </div>
                    `;
                });
                
                html = `
                    <div style="margin-bottom: 20px;">
                        <canvas id="result-canvas" width="500" height="400" style="width: 100%; border-radius: 10px;"></canvas>
                    </div>
                    
                    <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
                        <button onclick="downloadAsPDF()" style="flex: 1; min-width: 140px; padding: 12px 20px; background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                            ğŸ“„ PDFã§ä¿å­˜
                        </button>
                        <button onclick="downloadAsPNG()" style="flex: 1; min-width: 140px; padding: 12px 20px; background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                            ğŸ–¼ï¸ ç”»åƒã§ä¿å­˜
                        </button>
                        <button onclick="shareResult()" style="flex: 1; min-width: 140px; padding: 12px 20px; background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                            ğŸ“¤ å…±æœ‰
                        </button>
                    </div>
                ` + html;
                
                resultsContent.innerHTML = html;
                drawResultDiagram();
            } else {
                const warningHtml = `
                    <div style="background: #fee; border: 2px solid #e74c3c; border-radius: 10px; padding: 20px; text-align: center;">
                        <div style="color: #e74c3c; font-size: 20px; font-weight: bold; margin-bottom: 15px;">
                            âš ï¸ å…¥åŠ›ãŒå®Œäº†ã—ã¦ã„ã¾ã›ã‚“
                        </div>
                        <div style="color: #c0392b; font-size: 16px; line-height: 1.8;">
                            ä»¥ä¸‹ã®é …ç›®ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼š<br>
                            <strong>${missingItems.join('ã€')}</strong>
                        </div>
                    </div>
                `;
                resultsContent.innerHTML = warningHtml;
            }
        }
        
        function getAdjacentLineWidth(lineId, point) {
            const currentLine = lines.find(l => l.id === lineId);
            if (!currentLine) return 0;
            
            const x = point === 'start' ? currentLine.x1 : currentLine.x2;
            const y = point === 'start' ? currentLine.y1 : currentLine.y2;ã€€
            const cornerKey = findCornerKey(x, y, 5);
            
            if (!corners || !corners[cornerKey]) return 0;
            
            const corner = corners[cornerKey];
            
            for (const lineRef of corner.lines) {
                if (lineRef.lineId !== lineId) {
                    const adjacentLine = lines.find(l => l.id === lineRef.lineId);
                    if (adjacentLine) {
                        const adjacentDim = dimensions[lineRef.lineId];
                        if (adjacentDim && adjacentDim.width) {
                            return adjacentDim.width;
                        }
                    }
                }
            }
            
            return 0;
        }
        
        function drawResultDiagram() {
            const resultCanvas = document.getElementById('result-canvas');
            if (!resultCanvas) return;
            
            const ctx = resultCanvas.getContext('2d');
            
            ctx.fillStyle = '#f0f9ff';
            ctx.fillRect(0, 0, resultCanvas.width, resultCanvas.height);
            
            if (lines.length === 0) return;
            
            const realLines = [];
            const minLength = 300;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const dim = dimensions[line.id];
                
                if (!dim || !dim.length) continue;
                
                let realLength = dim.length;
                
                const dx = line.x2 - line.x1;
                const dy = line.y2 - line.y1;
                const originalLength = Math.sqrt(dx * dx + dy * dy);
                
                if (originalLength === 0) continue;
                
                const dirX = dx / originalLength;
                const dirY = dy / originalLength;
                
                let displayLength = Math.max(realLength * 0.2, minLength);
                
                let startX = line.x1;
                let startY = line.y1;
                
                for (let j = 0; j < realLines.length; j++) {
                    const prevLine = realLines[j].line;
                    
                    if (Math.abs(line.x1 - prevLine.x2) < 1 && Math.abs(line.y1 - prevLine.y2) < 1) {
                        startX = realLines[j].x2;
                        startY = realLines[j].y2;
                        break;
                    }
                    
                    if (Math.abs(line.x1 - prevLine.x1) < 1 && Math.abs(line.y1 - prevLine.y1) < 1) {
                        startX = realLines[j].x1;
                        startY = realLines[j].y1;
                        break;
                    }
                }
                
                realLines.push({
                    x1: startX,
                    y1: startY,
                    x2: startX + dirX * displayLength,
                    y2: startY + dirY * displayLength,
                    line: line
                });
            }
            
            if (realLines.length === 0) return;
            
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            
            realLines.forEach(rLine => {
                minX = Math.min(minX, rLine.x1, rLine.x2);
                minY = Math.min(minY, rLine.y1, rLine.y2);
                maxX = Math.max(maxX, rLine.x1, rLine.x2);
                maxY = Math.max(maxY, rLine.y1, rLine.y2);
            });
            
            const shapeWidth = Math.max(maxX - minX, 1);
            const shapeHeight = Math.max(maxY - minY, 1);
            
            const margin = 60;
            const canvasWidth = resultCanvas.width - margin * 2;
            const canvasHeight = resultCanvas.height - margin * 2;
            
            const scaleX = canvasWidth / shapeWidth;
            const scaleY = canvasHeight / shapeHeight;
            const scale = Math.min(scaleX, scaleY);
            
            const scaledWidth = shapeWidth * scale;
            const scaledHeight = shapeHeight * scale;
            const offsetX = margin + (canvasWidth - scaledWidth) / 2 - minX * scale;
            const offsetY = margin + (canvasHeight - scaledHeight) / 2 - minY * scale;
            
            function transformX(x) {
                return x * scale + offsetX;
            }
            
            function transformY(y) {
                return y * scale + offsetY;
            }
            
            function drawResultPoint(x, y, state) {
                const colors = {
                    'corner': '#ef4444',
                    'end': '#3b82f6',
                    'wall': '#10b981'
                };
                
                const color = colors[state] || colors['end'];
                const px = transformX(x);
                const py = transformY(y);
                
                ctx.save();
                
                // å½¢çŠ¶ã«å¿œã˜ã¦æç”»ï¼ˆv1.17.3 - ã‚µã‚¤ã‚ºæ‹¡å¤§ï¼‰
                if (state === 'corner') {
                    // ã‚³ãƒ¼ãƒŠãƒ¼: èµ¤ã„â–¼ï¼ˆä¸‹å‘ãä¸‰è§’å½¢ï¼‰
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.moveTo(px, py + 12);          // ä¸‹ã®é ‚ç‚¹ï¼ˆ8â†’12ï¼‰
                    ctx.lineTo(px - 12, py - 9);      // å·¦ä¸Šï¼ˆ-8/-6 â†’ -12/-9ï¼‰
                    ctx.lineTo(px + 12, py - 9);      // å³ä¸Šï¼ˆ+8/-6 â†’ +12/-9ï¼‰
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2.5;
                    ctx.stroke();
                    
                } else if (state === 'wall') {
                    // å£: ç·‘ã®â– ï¼ˆæ­£æ–¹å½¢ï¼‰
                    ctx.fillStyle = color;
                    ctx.fillRect(px - 12, py - 12, 24, 24);  // 16x16 â†’ 24x24
                    
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2.5;
                    ctx.strokeRect(px - 12, py - 12, 24, 24);
                    
                } else {
                    // ã‚¨ãƒ³ãƒ‰: é’ã„â˜…ï¼ˆæ˜Ÿï¼‰
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    const outerRadius = 15;           // 10 â†’ 15
                    const innerRadius = 6;            // 4 â†’ 6
                    const spikes = 5;
                    
                    for (let i = 0; i < spikes * 2; i++) {
                        const angle = (i * Math.PI) / spikes - Math.PI / 2;
                        const radius = i % 2 === 0 ? outerRadius : innerRadius;
                        const sx = px + Math.cos(angle) * radius;
                        const sy = py + Math.sin(angle) * radius;
                        if (i === 0) {
                            ctx.moveTo(sx, sy);
                        } else {
                            ctx.lineTo(sx, sy);
                        }
                    }
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2.5;
                    ctx.stroke();
                }
                
                ctx.restore();
            }
            
            detectCorners();
            
            realLines.forEach(rLine => {
                const line = rLine.line;
                
                ctx.strokeStyle = '#1a1a1a';
                ctx.lineWidth = 5;
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                ctx.moveTo(transformX(rLine.x1), transformY(rLine.y1));
                ctx.lineTo(transformX(rLine.x2), transformY(rLine.y2));
                ctx.stroke();
                
                const dim = dimensions[line.id];
                if (dim && dim.length) {
                    let result = dim.length;
                    
                    if (line.start === 'corner') {
                        const adjacentWidth = getAdjacentLineWidth(line.id, 'start');
                        if (adjacentWidth > 0) {
                            result -= adjacentWidth / 2;
                        }
                    }
                    
                    if (line.end === 'corner') {
                        const adjacentWidth = getAdjacentLineWidth(line.id, 'end');
                        if (adjacentWidth > 0) {
                            result -= adjacentWidth / 2;
                        }
                    }
                    
                    const midX = (rLine.x1 + rLine.x2) / 2;
                    const midY = (rLine.y1 + rLine.y2) / 2;
                    const dx = rLine.x2 - rLine.x1;
                    const dy = rLine.y2 - rLine.y1;
                    const lineLength = Math.sqrt(dx * dx + dy * dy);
                    
                    const perpX = -dy / lineLength;
                    const perpY = dx / lineLength;
                    
                    const offset = 30;
                    const textX = transformX(midX + perpX * offset);
                    const textY = transformY(midY + perpY * offset);
                    
                    ctx.font = 'bold 16px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    const resultText = `${Math.floor(result)}`;
                    const resultMetrics = ctx.measureText(resultText);
                    const padding = 6;
                    
                    ctx.fillStyle = 'rgba(254, 243, 199, 0.85)';
                    ctx.fillRect(textX - resultMetrics.width/2 - padding, textY - 10, resultMetrics.width + padding*2, 20);
                    
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 1.5;
                    ctx.strokeRect(textX - resultMetrics.width/2 - padding, textY - 10, resultMetrics.width + padding*2, 20);
                    
                    ctx.fillStyle = '#1e40af';
                    ctx.fillText(resultText, textX, textY);
                    
                    if (dim.width) {
                        ctx.font = '10px sans-serif';
                        const widthText = `å¹…:${dim.width}`;
                        const widthMetrics = ctx.measureText(widthText);
                        const widthY = textY + 16;
                        const widthPadding = 3;
                        
                        ctx.fillStyle = 'rgba(243, 244, 246, 0.85)';
                        ctx.fillRect(textX - widthMetrics.width/2 - widthPadding, widthY - 7, widthMetrics.width + widthPadding*2, 14);
                        
                        ctx.fillStyle = '#6b7280';
                        ctx.fillText(widthText, textX, widthY);
                    }
                }
            });
            
            const drawnCorners = new Set();
            const coordMap = new Map();
            realLines.forEach((rLine, idx) => {
                const line = rLine.line;
                const startKey = `${line.x1},${line.y1}`;
                if (!coordMap.has(startKey)) {
                    coordMap.set(startKey, { x: rLine.x1, y: rLine.y1 });
                }
                const endKey = `${line.x2},${line.y2}`;
                if (!coordMap.has(endKey)) {
                    coordMap.set(endKey, { x: rLine.x2, y: rLine.y2 });
                }
            });
            
            if (corners) {
                for (const cornerKey in corners) {
                    const corner = corners[cornerKey];
                    
                    if (!corner || drawnCorners.has(cornerKey)) continue;
                    drawnCorners.add(cornerKey);
                    
                    if (!corner.lines || corner.lines.length === 0) continue;
                    
                    const firstLineRef = corner.lines[0];
                    const firstLine = lines.find(l => l.id === firstLineRef.lineId);
                    if (!firstLine) continue;
                    
                    const cornerX = corner.x !== undefined ? corner.x : (firstLine[firstLineRef.point === 'start' ? 'x1' : 'x2']);
                    const cornerY = corner.y !== undefined ? corner.y : (firstLine[firstLineRef.point === 'start' ? 'y1' : 'y2']);
                    
                    const coordKey = `${cornerX},${cornerY}`;
                    const realCoord = coordMap.get(coordKey);
                    
                    if (!realCoord) continue;
                    
                    if (corner.hasStep && corner.lines.length >= 2) {
                        const line1Ref = corner.lines[0];
                        const line2Ref = corner.lines[1];
                        const line1 = lines.find(l => l.id === line1Ref.lineId);
                        const line2 = lines.find(l => l.id === line2Ref.lineId);
                        
                        if (line1 && line2) {
                            const state1 = line1[line1Ref.point] || 'wall';
                            const state2 = line2[line2Ref.point] || 'wall';
                            
                            const offset = 30;  // 20 â†’ 30ï¼ˆç‚¹ãŒå¤§ãããªã£ãŸãŸã‚ v1.17.4ï¼‰
                            
                            const rLine1 = realLines.find(rl => rl.line.id === line1.id);
                            const rLine2 = realLines.find(rl => rl.line.id === line2.id);
                            
                            if (rLine1 && rLine2) {
                                let dx1, dy1;
                                if (line1Ref.point === 'start') {
                                    dx1 = rLine1.x2 - rLine1.x1;
                                    dy1 = rLine1.y2 - rLine1.y1;
                                } else {
                                    dx1 = rLine1.x1 - rLine1.x2;
                                    dy1 = rLine1.y1 - rLine1.y2;
                                }
                                const len1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
                                
                                let dx2, dy2;
                                if (line2Ref.point === 'start') {
                                    dx2 = rLine2.x2 - rLine2.x1;
                                    dy2 = rLine2.y2 - rLine2.y1;
                                } else {
                                    dx2 = rLine2.x1 - rLine2.x2;
                                    dy2 = rLine2.y1 - rLine2.y2;
                                }
                                const len2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                                
                                if (len1 > 0 && len2 > 0) {
                                    const dirX1 = dx1 / len1;
                                    const dirY1 = dy1 / len1;
                                    const dirX2 = dx2 / len2;
                                    const dirY2 = dy2 / len2;
                                    
                                    drawResultPoint(realCoord.x + dirX1 * offset, realCoord.y + dirY1 * offset, state1);
                                    drawResultPoint(realCoord.x + dirX2 * offset, realCoord.y + dirY2 * offset, state2);
                                } else {
                                    drawResultPoint(realCoord.x, realCoord.y, state1);
                                }
                            } else {
                                drawResultPoint(realCoord.x, realCoord.y, state1);
                            }
                        }
                    } else {
                        const state = firstLine[firstLineRef.point] || 'wall';
                        drawResultPoint(realCoord.x, realCoord.y, state);
                    }
                }
            }
            
            const legendX = resultCanvas.width - 85;
            const legendY = resultCanvas.height - 70;
            
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'left';
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillText('ç‚¹ã®ç¨®é¡', legendX + 1, legendY + 1);
            ctx.fillText('ç‚¹ã®ç¨®é¡', legendX - 1, legendY - 1);
            ctx.fillText('ç‚¹ã®ç¨®é¡', legendX + 1, legendY - 1);
            ctx.fillText('ç‚¹ã®ç¨®é¡', legendX - 1, legendY + 1);
            
            ctx.fillStyle = '#1f2937';
            ctx.fillText('ç‚¹ã®ç¨®é¡', legendX, legendY);
            
            const legendItems = [
                { color: '#ef4444', label: 'ã‚³ãƒ¼ãƒŠãƒ¼', shape: 'corner' },
                { color: '#3b82f6', label: 'ã‚¨ãƒ³ãƒ‰', shape: 'end' },
                { color: '#10b981', label: 'å£', shape: 'wall' }
            ];
            
            legendItems.forEach((item, index) => {
                const itemY = legendY + 22 + index * 18;
                const iconX = legendX + 6;
                
                ctx.save();
                
                // å½¢çŠ¶ã«å¿œã˜ãŸå‡¡ä¾‹ã‚¢ã‚¤ã‚³ãƒ³ã‚’æç”»ï¼ˆv1.17.2ï¼‰
                if (item.shape === 'corner') {
                    // ã‚³ãƒ¼ãƒŠãƒ¼: èµ¤ã„â–¼
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.moveTo(iconX, itemY + 6);
                    ctx.lineTo(iconX - 5, itemY - 4);
                    ctx.lineTo(iconX + 5, itemY - 4);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.fillStyle = item.color;
                    ctx.beginPath();
                    ctx.moveTo(iconX - 1, itemY + 5);
                    ctx.lineTo(iconX - 6, itemY - 5);
                    ctx.lineTo(iconX + 4, itemY - 5);
                    ctx.closePath();
                    ctx.fill();
                    
                } else if (item.shape === 'wall') {
                    // å£: ç·‘ã®â– 
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.fillRect(iconX - 4, itemY - 4, 9, 9);
                    
                    ctx.fillStyle = item.color;
                    ctx.fillRect(iconX - 5, itemY - 5, 9, 9);
                    
                } else {
                    // ã‚¨ãƒ³ãƒ‰: é’ã„â˜…
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.beginPath();
                    const outerRadius = 6;
                    const innerRadius = 2.5;
                    const spikes = 5;
                    for (let i = 0; i < spikes * 2; i++) {
                        const angle = (i * Math.PI) / spikes - Math.PI / 2;
                        const radius = i % 2 === 0 ? outerRadius : innerRadius;
                        const sx = iconX + 1 + Math.cos(angle) * radius;
                        const sy = itemY + 1 + Math.sin(angle) * radius;
                        if (i === 0) ctx.moveTo(sx, sy);
                        else ctx.lineTo(sx, sy);
                    }
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.fillStyle = item.color;
                    ctx.beginPath();
                    for (let i = 0; i < spikes * 2; i++) {
                        const angle = (i * Math.PI) / spikes - Math.PI / 2;
                        const radius = i % 2 === 0 ? outerRadius : innerRadius;
                        const sx = iconX + Math.cos(angle) * radius;
                        const sy = itemY + Math.sin(angle) * radius;
                        if (i === 0) ctx.moveTo(sx, sy);
                        else ctx.lineTo(sx, sy);
                    }
                    ctx.closePath();
                    ctx.fill();
                }
                
                ctx.restore();
                
                ctx.font = '11px sans-serif';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillText(item.label, legendX + 16, itemY + 5);
                ctx.fillText(item.label, legendX + 14, itemY + 3);
                ctx.fillText(item.label, legendX + 16, itemY + 3);
                ctx.fillText(item.label, legendX + 14, itemY + 5);
                
                ctx.fillStyle = '#374151';
                ctx.fillText(item.label, legendX + 15, itemY + 4);
            });
        }
        
        function getPointLabel(state) {
            const labels = {
                'corner': '<span style="color: #e74c3c;">â–¼</span>',
                'end': '<span style="color: #3498db;">â˜…</span>',
                'wall': '<span style="color: #2ecc71;">â– </span>'
            };
            return labels[state] || labels['end'];
        }
        
        function setupCustomDrawing() {
            document.getElementById('dimension-inputs').innerHTML = `
                <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0; color: #1976d2; font-size: 16px;">ğŸ“ ä½œå›³æ–¹æ³•</h3>
                    <p style="margin: 0; color: #555; font-size: 14px;">
                        <strong>ã‚¯ãƒªãƒƒã‚¯</strong>ã§ç‚¹ã‚’æ‰“ã¡ã€ç·šã‚’é€£ç¶šã—ã¦å¼•ã<br>
                        <strong>ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯</strong>ã¾ãŸã¯ä¸‹ã®ãƒœã‚¿ãƒ³ã§ä½œå›³çµ‚äº†
                    </p>
                    <button onclick="finishDrawing()" style="width: 100%; padding: 12px; background: #27ae60; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: bold; cursor: pointer; margin-top: 10px;">
                        âœ“ ä½œå›³çµ‚äº†
                    </button>
                    <h3 style="margin: 15px 0 10px 0; color: #1976d2; font-size: 16px;">ğŸ¨ ç‚¹ã®æ„å‘³</h3>
                    <p style="margin: 0; color: #555; font-size: 14px;">
                        <span style="color: #e74c3c;">â–¼</span> èµ¤ï¼šã‚³ãƒ¼ãƒŠãƒ¼ï¼ˆèº¯ä½“å¹…Ã·2ã‚’å¼•ãï¼‰<br>
                        <span style="color: #3498db;">â˜…</span> é’ï¼šã‚¨ãƒ³ãƒ‰ï¼ˆç«¯éƒ¨ã€å£ãªã—ï¼‰<br>
                        <span style="color: #2ecc71;">â– </span> ç·‘ï¼šå£ï¼ˆå£ã‚ã‚Šï¼‰<br>
                        <strong>ä½œå›³çµ‚äº†å¾Œã€ç‚¹ã‚’ã‚¿ãƒƒãƒ—ã§åˆ‡ã‚Šæ›¿ãˆ</strong>
                    </p>
                </div>
            `;
            
            drawingPoints = [];
            
            canvas.removeEventListener('mousedown', startDrawing);
            canvas.removeEventListener('mousemove', drawing);
            canvas.removeEventListener('mouseup', endDrawing);
            canvas.removeEventListener('click', handlePointClick);
            canvas.removeEventListener('touchend', handlePointClickTouch);
            
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('mousemove', handleCanvasMouseMove);
            
            canvas.addEventListener('touchstart', handleTouchDrawing);
            canvas.addEventListener('touchmove', handleTouchDrawingMove);
            
            updateDrawingControls();
        }
        
        function handleCanvasClick(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let x = (e.offsetX || e.clientX - rect.left) * scaleX;
            let y = (e.offsetY || e.clientY - rect.top) * scaleY;
            
            if (drawingPoints.length > 0) {
                const lastPoint = drawingPoints[drawingPoints.length - 1];
                const snapped = snapToAxis(lastPoint.x, lastPoint.y, x, y);
                x = snapped.x;
                y = snapped.y;
            }
            
            if (drawingPoints.length >= 3) {
                const startPoint = drawingPoints[0];
                const distToStart = Math.sqrt(Math.pow(x - startPoint.x, 2) + Math.pow(y - startPoint.y, 2));
                
                if (distToStart < 30) {
                    if (confirm('å›³å½¢ã‚’é–‰ã˜ã¾ã™ã‹ï¼Ÿ\nï¼ˆå§‹ç‚¹ã¨çµ‚ç‚¹ã‚’çµåˆã—ã¾ã™ï¼‰')) {
                        x = startPoint.x;
                        y = startPoint.y;
                        
                        drawingPoints.push({ x, y });
                        
                        const prevPoint = drawingPoints[drawingPoints.length - 2];
                        const currPoint = drawingPoints[drawingPoints.length - 1];
                        
                        const id = String.fromCharCode(65 + lines.length);
                        lines.push({
                            id: id,
                            x1: prevPoint.x,
                            y1: prevPoint.y,
                            x2: currPoint.x,
                            y2: currPoint.y,
                            name: `è¾º${id}`,
                            start: 'wall',
                            end: 'wall'
                        });
                        
                        autoSetCorners();
                        finishDrawing();
                        return;
                    } else {
                        return;
                    }
                }
            }
            
            const clickRadius = 20;
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                let isStartPoint = false;
                if (drawingPoints.length >= 3 && i === 0) {
                    const startPoint = drawingPoints[0];
                    const distToStart = Math.sqrt(Math.pow(line.x1 - startPoint.x, 2) + Math.pow(line.y1 - startPoint.y, 2));
                    isStartPoint = distToStart < 5;
                }
                
                const distStart = Math.sqrt(Math.pow(x - line.x1, 2) + Math.pow(y - line.y1, 2));
                const distEnd = Math.sqrt(Math.pow(x - line.x2, 2) + Math.pow(y - line.y2, 2));
                
                if (!isStartPoint && distStart < clickRadius) {
                    return;
                }
                if (distEnd < clickRadius) {
                    return;
                }
            }
            
            const currentTime = new Date().getTime();
            const timeDiff = currentTime - lastClickTime;
            lastClickTime = currentTime;
            
            if (timeDiff < 500 && drawingPoints.length > 0) {
                finishDrawing();
                return;
            }
            
            drawingPoints.push({ x, y });
            
            if (drawingPoints.length >= 2) {
                const prevPoint = drawingPoints[drawingPoints.length - 2];
                const currPoint = drawingPoints[drawingPoints.length - 1];
                
                const id = String.fromCharCode(65 + lines.length);
                lines.push({
                    id: id,
                    x1: prevPoint.x,
                    y1: prevPoint.y,
                    x2: currPoint.x,
                    y2: currPoint.y,
                    name: `è¾º${id}`,
                    start: 'wall',
                    end: 'wall'
                });
                
                autoSetCorners();
            }
            
            drawLines();
            updateDrawingControls();
        }
        
        function handleCanvasMouseMove(e) {
            if (drawingPoints.length === 0) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let x = (e.offsetX || e.clientX - rect.left) * scaleX;
            let y = (e.offsetY || e.clientY - rect.top) * scaleY;
            
            const lastPoint = drawingPoints[drawingPoints.length - 1];
            const snapped = snapToAxis(lastPoint.x, lastPoint.y, x, y);
            x = snapped.x;
            y = snapped.y;
            
            drawLines();
            
            let snapToStart = false;
            if (drawingPoints.length >= 3) {
                const startPoint = drawingPoints[0];
                const threshold = 10;
                
                if (Math.abs(y - startPoint.y) < threshold) {
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(x, startPoint.y);
                    ctx.lineTo(startPoint.x, startPoint.y);
                    ctx.stroke();
                    
                    y = startPoint.y;
                    
                    if (Math.abs(x - startPoint.x) < threshold) {
                        x = startPoint.x;
                        snapToStart = true;
                    }
                }
                
                if (Math.abs(x - startPoint.x) < threshold) {
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(startPoint.x, y);
                    ctx.lineTo(startPoint.x, startPoint.y);
                    ctx.stroke();
                    
                    x = startPoint.x;
                    
                    if (Math.abs(y - startPoint.y) < threshold) {
                        y = startPoint.y;
                        snapToStart = true;
                    }
                }
                
                if (snapToStart) {
                    ctx.fillStyle = '#f59e0b';
                    ctx.beginPath();
                    ctx.arc(startPoint.x, startPoint.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
            
            if (!snapToStart) {
                if (Math.abs(y - lastPoint.y) < 30) {
                    ctx.strokeStyle = '#10b981';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.moveTo(0, lastPoint.y);
                    ctx.lineTo(canvas.width, lastPoint.y);
                    ctx.stroke();
                }
                
                if (Math.abs(x - lastPoint.x) < 30) {
                    ctx.strokeStyle = '#10b981';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.moveTo(lastPoint.x, 0);
                    ctx.lineTo(lastPoint.x, canvas.height);
                    ctx.stroke();
                }
            }
            
            ctx.strokeStyle = snapToStart ? '#f59e0b' : '#667eea';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(lastPoint.x, lastPoint.y);
            ctx.lineTo(x, y);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        function snapToAxis(x1, y1, x2, y2) {
            const dx = Math.abs(x2 - x1);
            const dy = Math.abs(y2 - y1);
            const threshold = 30;
            
            if (dx > dy && dy < threshold) {
                return { x: x2, y: y1 };
            }
            else if (dy > dx && dx < threshold) {
                return { x: x1, y: y2 };
            }
            return { x: x2, y: y2 };
        }
        
        function handleTouchDrawing(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let x = (touch.clientX - rect.left) * scaleX;
            let y = (touch.clientY - rect.top) * scaleY;
            
            if (drawingPoints.length > 0) {
                const lastPoint = drawingPoints[drawingPoints.length - 1];
                const snapped = snapToAxis(lastPoint.x, lastPoint.y, x, y);
                x = snapped.x;
                y = snapped.y;
            }
            
            if (drawingPoints.length >= 3) {
                const startPoint = drawingPoints[0];
                const distToStart = Math.sqrt(Math.pow(x - startPoint.x, 2) + Math.pow(y - startPoint.y, 2));
                
                if (distToStart < 40) {
                    if (confirm('å›³å½¢ã‚’é–‰ã˜ã¾ã™ã‹ï¼Ÿ\nï¼ˆå§‹ç‚¹ã¨çµ‚ç‚¹ã‚’çµåˆã—ã¾ã™ï¼‰')) {
                        x = startPoint.x;
                        y = startPoint.y;
                        
                        drawingPoints.push({ x, y });
                        
                        const prevPoint = drawingPoints[drawingPoints.length - 2];
                        const currPoint = drawingPoints[drawingPoints.length - 1];
                        
                        const id = String.fromCharCode(65 + lines.length);
                        lines.push({
                            id: id,
                            x1: prevPoint.x,
                            y1: prevPoint.y,
                            x2: currPoint.x,
                            y2: currPoint.y,
                            name: `è¾º${id}`,
                            start: 'wall',
                            end: 'wall'
                        });
                        
                        autoSetCorners();
                        finishDrawing();
                        return;
                    } else {
                        return;
                    }
                }
            }
            
            const clickRadius = 25;
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                let isStartPoint = false;
                if (drawingPoints.length >= 3 && i === 0) {
                    const startPoint = drawingPoints[0];
                    const distToStart = Math.sqrt(Math.pow(line.x1 - startPoint.x, 2) + Math.pow(line.y1 - startPoint.y, 2));
                    isStartPoint = distToStart < 5;
                }
                
                const distStart = Math.sqrt(Math.pow(x - line.x1, 2) + Math.pow(y - line.y1, 2));
                const distEnd = Math.sqrt(Math.pow(x - line.x2, 2) + Math.pow(y - line.y2, 2));
                
                if (!isStartPoint && distStart < clickRadius) {
                    return;
                }
                if (distEnd < clickRadius) {
                    return;
                }
            }
            
            const currentTime = new Date().getTime();
            const timeDiff = currentTime - lastTapTime;
            lastTapTime = currentTime;
            
            if (timeDiff < 500 && drawingPoints.length > 0) {
                finishDrawing();
                return;
            }
            
            drawingPoints.push({ x, y });
            
            if (drawingPoints.length >= 2) {
                const prevPoint = drawingPoints[drawingPoints.length - 2];
                const currPoint = drawingPoints[drawingPoints.length - 1];
                
                const id = String.fromCharCode(65 + lines.length);
                lines.push({
                    id: id,
                    x1: prevPoint.x,
                    y1: prevPoint.y,
                    x2: currPoint.x,
                    y2: currPoint.y,
                    name: `è¾º${id}`,
                    start: 'wall',
                    end: 'wall'
                });
                
                autoSetCorners();
            }
            
            drawLines();
            updateDrawingControls();
        }
        
        function handleTouchDrawingMove(e) {
            if (drawingPoints.length === 0) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let x = (touch.clientX - rect.left) * scaleX;
            let y = (touch.clientY - rect.top) * scaleY;
            
            const lastPoint = drawingPoints[drawingPoints.length - 1];
            const snapped = snapToAxis(lastPoint.x, lastPoint.y, x, y);
            x = snapped.x;
            y = snapped.y;
            
            drawLines();
            
            let snapToStart = false;
            if (drawingPoints.length >= 3) {
                const startPoint = drawingPoints[0];
                const threshold = 15;
                
                if (Math.abs(y - startPoint.y) < threshold) {
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(x, startPoint.y);
                    ctx.lineTo(startPoint.x, startPoint.y);
                    ctx.stroke();
                    
                    y = startPoint.y;
                    
                    if (Math.abs(x - startPoint.x) < threshold) {
                        x = startPoint.x;
                        snapToStart = true;
                    }
                }
                
                if (Math.abs(x - startPoint.x) < threshold) {
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(startPoint.x, y);
                    ctx.lineTo(startPoint.x, startPoint.y);
                    ctx.stroke();
                    
                    x = startPoint.x;
                    
                    if (Math.abs(y - startPoint.y) < threshold) {
                        y = startPoint.y;
                        snapToStart = true;
                    }
                }
                
                if (snapToStart) {
                    ctx.fillStyle = '#f59e0b';
                    ctx.beginPath();
                    ctx.arc(startPoint.x, startPoint.y, 10, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
            
            if (!snapToStart) {
                if (Math.abs(y - lastPoint.y) < 30) {
                    ctx.strokeStyle = '#10b981';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.moveTo(0, lastPoint.y);
                    ctx.lineTo(canvas.width, lastPoint.y);
                    ctx.stroke();
                }
                
                if (Math.abs(x - lastPoint.x) < 30) {
                    ctx.strokeStyle = '#10b981';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.moveTo(lastPoint.x, 0);
                    ctx.lineTo(lastPoint.x, canvas.height);
                    ctx.stroke();
                }
            }
            
            ctx.strokeStyle = snapToStart ? '#f59e0b' : '#667eea';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(lastPoint.x, lastPoint.y);
            ctx.lineTo(x, y);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        function finishDrawing() {
            drawingPoints = [];
            drawLines();
            
            canvas.removeEventListener('click', handleCanvasClick);
            canvas.removeEventListener('mousemove', handleCanvasMouseMove);
            canvas.removeEventListener('touchstart', handleTouchDrawing);
            canvas.removeEventListener('touchmove', handleTouchDrawingMove);
            
            canvas.addEventListener('click', handlePointClick);
            canvas.addEventListener('touchend', handlePointClickTouch);
            
            if (lines.length > 0) {
                createInputs();
            }
            
            updateDrawingControls();
        }
        
        // ã‚¢ãƒ©ãƒ¼ãƒˆè¡¨ç¤ºãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ï¼ˆNEW - v1.17.0ï¼‰
        function showAlert(message, type = 'info') {
            const alertDiv = document.getElementById('alert');
            if (!alertDiv) {
                alert(message);
                return;
            }
            
            const colors = {
                'info': { bg: '#dbeafe', border: '#3b82f6', text: '#1e40af' },
                'success': { bg: '#d1fae5', border: '#10b981', text: '#065f46' },
                'warning': { bg: '#fef3c7', border: '#f59e0b', text: '#92400e' },
                'error': { bg: '#fee2e2', border: '#ef4444', text: '#991b1b' }
            };
            
            const color = colors[type] || colors.info;
            
            alertDiv.style.cssText = `
                display: block;
                padding: 12px 16px;
                margin: 10px 0;
                background: ${color.bg};
                border: 2px solid ${color.border};
                border-radius: 8px;
                color: ${color.text};
                font-weight: 600;
                animation: slideDown 0.3s ease;
            `;
            alertDiv.textContent = message;
            
            // 3ç§’å¾Œã«è‡ªå‹•ã§æ¶ˆã™
            setTimeout(() => {
                alertDiv.style.display = 'none';
            }, 3000);
        }
        
        // ç¸åˆ‡ã‚Šæ©Ÿèƒ½ï¼ˆNEW - v1.17.0ï¼‰
        function cutEdge() {
            if (drawingPoints.length === 0) {
                showAlert('ç·šã‚’å¼•ã„ã¦ã‹ã‚‰ç¸åˆ‡ã‚Šã—ã¦ãã ã•ã„', 'info');
                return;
            }
            
            // ç¾åœ¨ã®æç”»ç‚¹ã‚’ã‚¯ãƒªã‚¢ã—ã¦ã€æ¬¡ã®ç‹¬ç«‹ã—ãŸç·šã‚’æã‘ã‚‹ã‚ˆã†ã«ã™ã‚‹
            drawingPoints = [];
            drawLines();
            
            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã¯ãã®ã¾ã¾ï¼ˆæç”»ãƒ¢ãƒ¼ãƒ‰ç¶™ç¶šï¼‰
            // æç”»ãƒ¢ãƒ¼ãƒ‰ã‚’ç¶­æŒã™ã‚‹ã®ã§ã€ã™ãã«æ¬¡ã®ç·šã‚’å¼•ãå§‹ã‚ã‚‰ã‚Œã‚‹
            
            showAlert('âœ‚ï¸ ç¸åˆ‡ã‚Šã—ã¾ã—ãŸã€‚æ¬¡ã®ç·šã¯ç‹¬ç«‹ã—ãŸç·šã¨ã—ã¦å¼•ã‘ã¾ã™', 'success');
            
            // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒœã‚¿ãƒ³ã¯è¡¨ç¤ºã—ãŸã¾ã¾
            updateDrawingControls();
        }
        
        function handlePointClick(e) {
            if (isDrawing || isDragging) return;
            if (drawingPoints.length > 0) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.offsetX || e.clientX - rect.left) * scaleX;
            const y = (e.offsetY || e.clientY - rect.top) * scaleY;
            
            const clickRadius = 20;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                const distStart = Math.sqrt(Math.pow(x - line.x1, 2) + Math.pow(y - line.y1, 2));
                if (distStart < clickRadius) {
                    scrollToInput(line.id);
                    return;
                }
                
                const distEnd = Math.sqrt(Math.pow(x - line.x2, 2) + Math.pow(y - line.y2, 2));
                if (distEnd < clickRadius) {
                    scrollToInput(line.id);
                    return;
                }
                
                const distToLine = distanceToLineSegment(x, y, line.x1, line.y1, line.x2, line.y2);
                if (distToLine < 10) {
                    scrollToInput(line.id);
                    return;
                }
            }
        }
        
        function distanceToLineSegment(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const lengthSquared = dx * dx + dy * dy;
            
            if (lengthSquared === 0) {
                return Math.sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1));
            }
            
            let t = ((px - x1) * dx + (py - y1) * dy) / lengthSquared;
            t = Math.max(0, Math.min(1, t));
            
            const nearestX = x1 + t * dx;
            const nearestY = y1 + t * dy;
            
            return Math.sqrt((px - nearestX) * (px - nearestX) + (py - nearestY) * (py - nearestY));
        }
        
        function scrollToInput(lineId) {
            setTimeout(() => {
                const inputGroup = document.querySelector(`[data-line-id="${lineId}"]`);
                if (inputGroup) {
                    inputGroup.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    
                    inputGroup.style.transition = 'background-color 0.3s';
                    inputGroup.style.backgroundColor = '#fef3c7';
                    
                    setTimeout(() => {
                        inputGroup.style.backgroundColor = '';
                    }, 2000);
                }
            }, 100);
        }
        
        function autoSetCorners() {
            const tolerance = 5;
            
            const isClosed = lines.length > 0 && 
                Math.abs(lines[0].x1 - lines[lines.length - 1].x2) < tolerance && 
                Math.abs(lines[0].y1 - lines[lines.length - 1].y2) < tolerance;
            
            for (let i = 0; i < lines.length; i++) {
                for (let j = i + 1; j < lines.length; j++) {
                    const line1 = lines[i];
                    const line2 = lines[j];
                    
                    if (Math.abs(line1.x1 - line2.x1) < tolerance && Math.abs(line1.y1 - line2.y1) < tolerance) {
                        if (is90Degrees(line1, line2, 'start', 'start')) {
                            if (i !== 0 || isClosed) line1.start = 'corner';
                            if (j !== 0 || isClosed) line2.start = 'corner';
                        } else {
                            if ((i !== 0 || isClosed) && line1.start === 'corner') line2.start = 'corner';
                            if ((j !== 0 || isClosed) && line2.start === 'corner') line1.start = 'corner';
                        }
                    }
                    
                    if (Math.abs(line1.x1 - line2.x2) < tolerance && Math.abs(line1.y1 - line2.y2) < tolerance) {
                        if (is90Degrees(line1, line2, 'start', 'end')) {
                            if (i !== 0 || isClosed) line1.start = 'corner';
                            if (j !== lines.length - 1 || isClosed) line2.end = 'corner';
                        } else {
                            if ((i !== 0 || isClosed) && line1.start === 'corner') line2.end = 'corner';
                            if ((j !== lines.length - 1 || isClosed) && line2.end === 'corner') line1.start = 'corner';
                        }
                    }
                    
                    if (Math.abs(line1.x2 - line2.x1) < tolerance && Math.abs(line1.y2 - line2.y1) < tolerance) {
                        if (is90Degrees(line1, line2, 'end', 'start')) {
                            if (i !== lines.length - 1 || isClosed) line1.end = 'corner';
                            if (j !== 0 || isClosed) line2.start = 'corner';
                        } else {
                            if ((i !== lines.length - 1 || isClosed) && line1.end === 'corner') line2.start = 'corner';
                            if ((j !== 0 || isClosed) && line2.start === 'corner') line1.end = 'corner';
                        }
                    }
                    
                    if (Math.abs(line1.x2 - line2.x2) < tolerance && Math.abs(line1.y2 - line2.y2) < tolerance) {
                        if (is90Degrees(line1, line2, 'end', 'end')) {
                            if (i !== lines.length - 1 || isClosed) line1.end = 'corner';
                            if (j !== lines.length - 1 || isClosed) line2.end = 'corner';
                        } else {
                            if ((i !== lines.length - 1 || isClosed) && line1.end === 'corner') line2.end = 'corner';
                            if ((j !== lines.length - 1 || isClosed) && line2.end === 'corner') line1.end = 'corner';
                        }
                    }
                }
            }
        }
        
        function togglePointState(lineIndex, point) {
            const line = lines[lineIndex];
            
            const x = point === 'start' ? line.x1 : line.x2;
            const y = point === 'start' ? line.y1 : line.y2;
            const cornerKey = findCornerKey(x, y, 5);
            const corner = corners[cornerKey];
            
            const isClosed = lines.length > 0 && 
                Math.abs(lines[0].x1 - lines[lines.length - 1].x2) < 5 && 
                Math.abs(lines[0].y1 - lines[lines.length - 1].y2) < 5;
            
            const isFirstLineStart = (lineIndex === 0 && point === 'start' && !isClosed);
            const isLastLineEnd = (lineIndex === lines.length - 1 && point === 'end' && !isClosed);
            const hasStepAtCorner = corner && corner.hasStep;
            
            let states;
            if (isFirstLineStart || isLastLineEnd || hasStepAtCorner) {
                states = ['end', 'wall'];
            } else {
                states = ['corner', 'end', 'wall'];
            }
            
            const currentState = lines[lineIndex][point] || 'wall';
            const currentIndex = states.indexOf(currentState);
            const nextIndex = (currentIndex + 1) % states.length;
            lines[lineIndex][point] = states[nextIndex];
            
            if (lines[lineIndex][point] === 'corner') {
                autoSetCorners();
            }
            
            if (corner && corner.hasStep && corner.lines.length >= 2) {
                syncCornerStatesWithStep(cornerKey, line.id, point, lines[lineIndex][point]);
            }
        }
        
        function handleTouch(e) {
            e.preventDefault();
            const touch = e.touches[0] || e.changedTouches[0];
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (touch.clientX - rect.left) * scaleX;
            const y = (touch.clientY - rect.top) * scaleY;
            
            if (e.type === 'touchstart') {
                startDrawing({ offsetX: x, offsetY: y });
            } else if (e.type === 'touchmove') {
                drawing({ offsetX: x, offsetY: y });
            } else if (e.type === 'touchend') {
                endDrawing({ offsetX: x, offsetY: y });
            }
        }
        
        function startDrawing(e) {
            isDrawing = true;
            isDragging = false;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            startPoint = { 
                x: (e.offsetX || e.clientX - rect.left) * scaleX, 
                y: (e.offsetY || e.clientY - rect.top) * scaleY 
            };
        }
        
        function drawing(e) {
            if (!isDrawing) return;
            
            isDragging = true;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.offsetX || e.clientX - rect.left) * scaleX;
            const y = (e.offsetY || e.clientY - rect.top) * scaleY;
            
            drawLines();
            
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(startPoint.x, startPoint.y);
            ctx.lineTo(x, y);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        function endDrawing(e) {
            if (!isDrawing) return;
            
            if (isDragging) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.offsetX || e.clientX - rect.left) * scaleX;
                const y = (e.offsetY || e.clientY - rect.top) * scaleY;
                
                const id = String.fromCharCode(65 + lines.length);
                lines.push({
                    id: id,
                    x1: startPoint.x,
                    y1: startPoint.y,
                    x2: x,
                    y2: y,
                    name: `è¾º${id}`,
                    start: 'wall',
                    end: 'wall'
                });
                
                drawLines();
                createInputs();
            }
            
            isDrawing = false;
            isDragging = false;
        }
        
        function savePattern() {
            const name = prompt('ãƒ‘ã‚¿ãƒ¼ãƒ³åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:');
            if (!name) return;
            
            const savedPatterns = JSON.parse(localStorage.getItem('savedPatterns') || '{}');
            savedPatterns[name] = {
                lines: lines,
                dimensions: dimensions
            };
            localStorage.setItem('savedPatterns', JSON.stringify(savedPatterns));
            
            alert('ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä¿å­˜ã—ã¾ã—ãŸ');
        }
        
        function loadSavedPatterns() {
            const savedPatterns = JSON.parse(localStorage.getItem('savedPatterns') || '{}');
            const keys = Object.keys(savedPatterns);
            
            if (keys.length === 0) return;
            
            document.getElementById('saved-patterns-section').style.display = 'block';
            const grid = document.getElementById('saved-patterns-grid');
            grid.innerHTML = '';
            
            keys.forEach(name => {
                const btn = document.createElement('button');
                btn.className = 'pattern-btn';
                btn.innerHTML = `
                    ${name}
                    <span class="delete-btn" onclick="event.stopPropagation(); deletePattern('${name}')">Ã—</span>
                `;
                btn.onclick = () => selectPattern(name);
                grid.appendChild(btn);
            });
        }
        
        function loadCustomPattern(name) {
            const savedPatterns = JSON.parse(localStorage.getItem('savedPatterns') || '{}');
            const pattern = savedPatterns[name];
            
            if (!pattern) return;
            
            document.getElementById('pattern-title').textContent = name;
            lines = pattern.lines;
            dimensions = pattern.dimensions || {};
            
            drawLines();
            createInputs();
        }
        
        function deletePattern(name) {
            if (!confirm(`ã€Œ${name}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`)) return;
            
            const savedPatterns = JSON.parse(localStorage.getItem('savedPatterns') || '{}');
            delete savedPatterns[name];
            localStorage.setItem('savedPatterns', JSON.stringify(savedPatterns));
            
            loadSavedPatterns();
        }
        
        function undoLastLine() {
            if (lines.length === 0) return;
            
            if (drawingPoints.length === 0 && lines.length > 0) {
                drawingPoints = [];
                drawingPoints.push({ x: lines[0].x1, y: lines[0].y1 });
                
                for (let i = 0; i < lines.length; i++) {
                    drawingPoints.push({ x: lines[i].x2, y: lines[i].y2 });
                }
                
                canvas.removeEventListener('click', handlePointClick);
                canvas.removeEventListener('touchend', handlePointClickTouch);
                
                canvas.addEventListener('click', handleCanvasClick);
                canvas.addEventListener('mousemove', handleCanvasMouseMove);
                canvas.addEventListener('touchstart', handleTouchDrawing);
                canvas.addEventListener('touchmove', handleTouchDrawingMove);
            }
            
            const lastLineId = lines[lines.length - 1].id;
            lines.pop();
            delete dimensions[lastLineId];
            
            if (drawingPoints.length > 1) {
                drawingPoints.pop();
            }
            
            drawLines();
            createInputs();
            calculate();
            updateDrawingControls();
        }
        
        function clearDrawing() {
            if (lines.length > 0 && !confirm('ã™ã¹ã¦ã®ä½œå›³ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã‹ï¼Ÿ')) {
                return;
            }
            
            lines = [];
            dimensions = {};
            drawingPoints = [];
            corners = {};
            commonWidth = null;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            document.getElementById('dimension-inputs').innerHTML = '';
            document.getElementById('results-content').innerHTML = '<p style="color: #999; text-align: center;">å¯¸æ³•ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„</p>';
            
            updateDrawingControls();
            
            if (currentPattern === 'custom') {
                canvas.removeEventListener('click', handlePointClick);
                canvas.removeEventListener('touchend', handlePointClickTouch);
                
                canvas.addEventListener('click', handleCanvasClick);
                canvas.addEventListener('mousemove', handleCanvasMouseMove);
                canvas.addEventListener('touchstart', handleTouchDrawing);
                canvas.addEventListener('touchmove', handleTouchDrawingMove);
            } else {
                selectPattern(currentPattern);
            }
        }
        
        function updateDrawingControls() {
            const controls = document.getElementById('drawing-controls');
            if (controls) {
                controls.style.display = (drawingPoints.length > 0 || currentPattern === 'custom') ? 'flex' : 'none';
            }
        }
        
        function backToSelect() {
            document.getElementById('pattern-select-screen').style.display = 'block';
            document.getElementById('measurement-screen').style.display = 'none';
            loadSavedPatterns();
        }
        
        function clearAll() {
            if (!confirm('ã™ã¹ã¦ã®ä½œå›³ã¨å…¥åŠ›å†…å®¹ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã‹ï¼Ÿ')) {
                return;
            }
            
            lines = [];
            dimensions = {};
            drawingPoints = [];
            corners = {};
            commonWidth = null;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            document.getElementById('dimension-inputs').innerHTML = '';
            document.getElementById('results-content').innerHTML = '<p style="color: #999; text-align: center;">å¯¸æ³•ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„</p>';
            
            updateDrawingControls();
            
            if (currentPattern === 'Iå­—') {
                createIPattern();
            } else if (currentPattern === 'å·¦Lå­—') {
                createLPatternLeft();
            } else if (currentPattern === 'å³Lå­—') {
                createLPatternRight();
            } else if (currentPattern === 'ã‚³ã®å­—') {
                createUPattern();
            } else if (currentPattern === 'custom') {
                setupCustomDrawing();
            }
        }
        
        function getFilename() {
            const date = new Date().toISOString().slice(0, 10);
            return `kutai-keisoku_${date}`;
        }
        
        
        // å…±æœ‰ç”¨ã®è¨ˆç®—çµæœHTMLã‚’ç”Ÿæˆï¼ˆv1.14.3 / v1.14.4ã§ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆåŒ–ï¼‰
        function generateResultsHTML() {
            let resultsHTML = '<div style="display: flex; flex-direction: column; gap: 6px;">';
            
            lines.forEach(line => {
                const dim = dimensions[line.id];
                if (!dim || !dim.length) return;
                
                let result = dim.length;
                let formula = '';
                const isDiagonal = isLineDiagonal(line);
                const baseLabel = isDiagonal ? 'èŠ¯å¯¸æ³•' : 'å¤–æ³•';
                
                formula = `${baseLabel} ${dim.length}mm`;
                
                if (line.start === 'corner') {
                    const adjacentWidth = getAdjacentLineWidth(line.id, 'start');
                    if (adjacentWidth > 0) {
                        result -= adjacentWidth / 2;
                        formula += ` - èº¯ä½“å¹… ${adjacentWidth}mm Ã· 2`;
                    }
                }
                
                if (line.end === 'corner') {
                    const adjacentWidth = getAdjacentLineWidth(line.id, 'end');
                    if (adjacentWidth > 0) {
                        result -= adjacentWidth / 2;
                        formula += ` - èº¯ä½“å¹… ${adjacentWidth}mm Ã· 2`;
                    }
                }
                
                const startLabel = getPointLabel(line.start);
                const endLabel = getPointLabel(line.end);
                
                resultsHTML += `
                    <div style="padding: 6px 8px; background: white; border-radius: 4px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2px;">
                            <span style="color: #374151; font-weight: 600; font-size: 11px;">${line.name} ${startLabel}â”${endLabel}</span>
                            <strong style="color: #1e40af; font-size: 14px;">${Math.floor(result)} mm</strong>
                        </div>
                        <div style="color: #6b7280; font-size: 9px; line-height: 1.3;">
                            (${formula} = ${Math.floor(result)}mm)
                        </div>
                    </div>
                `;
            });
            
            resultsHTML += '</div>';
            
            // èº¯ä½“é«˜ã•æƒ…å ±ã‚’è¿½åŠ ï¼ˆv1.16.1ï¼‰
            if (commonHeight) {
                resultsHTML += `
                    <div style="margin-top: 12px; padding: 8px; background: #f0f9ff; border-radius: 4px; border: 1px solid #bfdbfe;">
                        <div style="color: #1e40af; font-weight: 600; font-size: 12px; margin-bottom: 4px;">
                            ğŸ“ èº¯ä½“é«˜ã•: ${commonHeight}mm
                        </div>
                `;
                
                // 1100ä»¥ä¸‹ã®å ´åˆã®ç‰¹åˆ¥è¨ˆç®—ï¼ˆv1.16.1ï¼‰
                if (commonHeight <= 1100) {
                    const calc1 = 1100 - 20 - commonHeight;
                    const calc2 = 1100 - 30 - commonHeight;
                    resultsHTML += `
                        <div style="color: #6b7280; font-size: 9px; line-height: 1.5; margin-top: 4px;">
                            1100 - 20 - ${commonHeight} = ${calc1}mm<br>
                            1100 - 30 - ${commonHeight} = ${calc2}mm
                        </div>
                    `;
                }
                
                resultsHTML += `</div>`;
            }
            
            return resultsHTML;
        }
        
        async function downloadAsPDF() {
            const resultsContent = document.getElementById('results-content');
            if (!resultsContent || !resultsContent.innerHTML || resultsContent.innerHTML.includes('å…¥åŠ›ãŒå®Œäº†ã—ã¦ã„ã¾ã›ã‚“')) {
                alert('è¨ˆç®—çµæœãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }
            
            try {
                const siteName = document.getElementById('site-name')?.value || '';
                const sashColor = document.getElementById('sash-color')?.value || '';
                
                //è¨ˆç®—çµæœéƒ¨åˆ†ã®HTMLã‚’ä½œæˆ
                const resultDiv = document.createElement('div');
                resultDiv.style.cssText = 'width: 800px; padding: 30px; background: white; font-family: sans-serif;';
                
                // ãƒ˜ãƒƒãƒ€ãƒ¼
                resultDiv.innerHTML = `
                    <div style="text-align: center; margin-bottom: 20px; border-bottom: 3px solid #2563eb; padding-bottom: 15px;">
                        <h1 style="font-size: 28px; color: #1e40af; margin: 0 0 10px 0;">èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ </h1>
                        ${siteName || sashColor ? `<h2 style="font-size: 18px; color: #374151; margin: 0 0 10px 0;">ğŸ“ ${siteName}${sashColor ? ` ï¼ ğŸ¨ ${sashColor}` : ''}</h2>` : ''}
                        <p style="font-size: 14px; color: #6b7280; margin: 0;">${new Date().toLocaleDateString('ja-JP', {year: 'numeric', month: 'long', day: 'numeric'})}</p>
                    </div>
                `;
                
                // å›³é¢
                const resultCanvas = document.getElementById('result-canvas');
                if (resultCanvas) {
                    const canvasDiv = document.createElement('div');
                    canvasDiv.style.cssText = 'margin-bottom: 20px; padding: 20px; background: #f0f9ff; border-radius: 10px;';
                    canvasDiv.innerHTML = '<h3 style="font-size: 18px; color: #1e40af; margin: 0 0 15px 0;">ğŸ“ æ¸¬å®šå›³</h3>';
                    
                    // canvasã‚’ç”»åƒã«å¤‰æ›ã—ã¦åŸ‹ã‚è¾¼ã‚€ï¼ˆv1.14.2ï¼‰
                    const canvasImg = document.createElement('img');
                    canvasImg.src = resultCanvas.toDataURL('image/png');
                    canvasImg.style.cssText = 'width: 100%; height: auto; display: block;';
                    canvasDiv.appendChild(canvasImg);
                    resultDiv.appendChild(canvasDiv);
                }
                
                
                // è¨ˆç®—çµæœ
                const resultsDiv = document.createElement('div');
                resultsDiv.style.cssText = 'padding: 12px; background: #fef3c7; border-radius: 10px; border: 2px solid #f59e0b;';
                resultsDiv.innerHTML = '<h3 style="font-size: 18px; color: #92400e; margin: 0 0 15px 0;">ğŸ“Š è¨ˆç®—çµæœ</h3>';
                resultsDiv.innerHTML += generateResultsHTML();
                resultDiv.appendChild(resultsDiv);
                
                // ä¸€æ™‚çš„ã«bodyã«è¿½åŠ 
                document.body.appendChild(resultDiv);
                
                // html2canvasã§ã‚­ãƒ£ãƒ—ãƒãƒ£
                const canvas = await html2canvas(resultDiv, {
                    scale: 2,
                    backgroundColor: '#ffffff',
                    logging: false
                });
                
                // å‰Šé™¤
                document.body.removeChild(resultDiv);
                
                // PDFä½œæˆ
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF({
                    orientation: 'portrait',
                    unit: 'mm',
                    format: 'a4'
                });
                
                const imgData = canvas.toDataURL('image/png');
                const pageWidth = 210;
                const pageHeight = 297;
                const margin = 10;
                const imgWidth = pageWidth - margin * 2;
                const imgHeight = (canvas.height * imgWidth) / canvas.width;
                
                pdf.addImage(imgData, 'PNG', margin, margin, imgWidth, Math.min(imgHeight, pageHeight - margin * 2));
                
                const filename = (siteName ? siteName + '_' : '') + getFilename() + '.pdf';
                pdf.save(filename);
                
            } catch (error) {
                console.error('PDFä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
                alert('PDFã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
            }
        }
        
        async function downloadAsPNG() {
            const resultsContent = document.getElementById('results-content');
            if (!resultsContent || !resultsContent.innerHTML || resultsContent.innerHTML.includes('å…¥åŠ›ãŒå®Œäº†ã—ã¦ã„ã¾ã›ã‚“')) {
                alert('è¨ˆç®—çµæœãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }
            
            try {
                const siteName = document.getElementById('site-name')?.value || '';
                const sashColor = document.getElementById('sash-color')?.value || '';
                
                // è¨ˆç®—çµæœéƒ¨åˆ†ã®HTMLã‚’ä½œæˆï¼ˆPDFã¨åŒã˜ï¼‰
                const resultDiv = document.createElement('div');
                resultDiv.style.cssText = 'width: 800px; padding: 30px; background: white; font-family: sans-serif;';
                
                resultDiv.innerHTML = `
                    <div style="text-align: center; margin-bottom: 20px; border-bottom: 3px solid #2563eb; padding-bottom: 15px;">
                        <h1 style="font-size: 28px; color: #1e40af; margin: 0 0 10px 0;">èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ </h1>
                        ${siteName || sashColor ? `<h2 style="font-size: 18px; color: #374151; margin: 0 0 10px 0;">ğŸ“ ${siteName}${sashColor ? ` ï¼ ğŸ¨ ${sashColor}` : ''}</h2>` : ''}
                        <p style="font-size: 14px; color: #6b7280; margin: 0;">${new Date().toLocaleDateString('ja-JP', {year: 'numeric', month: 'long', day: 'numeric'})}</p>
                    </div>
                `;
                
                const resultCanvas = document.getElementById('result-canvas');
                if (resultCanvas) {
                    const canvasDiv = document.createElement('div');
                    canvasDiv.style.cssText = 'margin-bottom: 20px; padding: 20px; background: #f0f9ff; border-radius: 10px;';
                    canvasDiv.innerHTML = '<h3 style="font-size: 18px; color: #1e40af; margin: 0 0 15px 0;">ğŸ“ æ¸¬å®šå›³</h3>';
                    // canvasã‚’ç”»åƒã«å¤‰æ›ã—ã¦åŸ‹ã‚è¾¼ã‚€ï¼ˆv1.14.2ï¼‰
                    const canvasImg = document.createElement('img');
                    canvasImg.src = resultCanvas.toDataURL('image/png');
                    canvasImg.style.cssText = 'width: 100%; height: auto; display: block;';
                    canvasDiv.appendChild(canvasImg);
                    resultDiv.appendChild(canvasDiv);
                }
                
                
                const resultsDiv = document.createElement('div');
                resultsDiv.style.cssText = 'padding: 12px; background: #fef3c7; border-radius: 10px; border: 2px solid #f59e0b;';
                resultsDiv.innerHTML = '<h3 style="font-size: 18px; color: #92400e; margin: 0 0 15px 0;">ğŸ“Š è¨ˆç®—çµæœ</h3>';
                
                resultsDiv.innerHTML += generateResultsHTML();
                resultDiv.appendChild(resultsDiv);
                
                document.body.appendChild(resultDiv);
                
                const canvas = await html2canvas(resultDiv, {
                    scale: 2,
                    backgroundColor: '#ffffff',
                    logging: false
                });
                
                document.body.removeChild(resultDiv);
                
                const imgData = canvas.toDataURL('image/png');
                const link = document.createElement('a');
                link.download = (siteName ? siteName + '_' : '') + getFilename() + '.png';
                link.href = imgData;
                link.click();
                
            } catch (error) {
                console.error('PNGä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
                alert('ç”»åƒã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
            }
        }
        
        async function shareResult() {
            const resultsContent = document.getElementById('results-content');
            if (!resultsContent || !resultsContent.innerHTML || resultsContent.innerHTML.includes('å…¥åŠ›ãŒå®Œäº†ã—ã¦ã„ã¾ã›ã‚“')) {
                alert('è¨ˆç®—çµæœãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }
            
            // å…±æœ‰æ©Ÿèƒ½ã®ãƒã‚§ãƒƒã‚¯
            if (!navigator.share && !navigator.canShare) {
                alert('ã“ã®ç«¯æœ«ã§ã¯å…±æœ‰æ©Ÿèƒ½ãŒä½¿ãˆã¾ã›ã‚“ã€‚ç”»åƒã¨ã—ã¦ä¿å­˜ã—ã¾ã™ã€‚');
                await downloadAsPNG();
                return;
            }
            
            try {
                const siteName = document.getElementById('site-name')?.value || '';
                const sashColor = document.getElementById('sash-color')?.value || '';
                
                // è¨ˆç®—çµæœéƒ¨åˆ†ã®HTMLã‚’ä½œæˆ
                const resultDiv = document.createElement('div');
                resultDiv.style.cssText = 'width: 800px; padding: 30px; background: white; font-family: sans-serif;';
                
                resultDiv.innerHTML = `
                    <div style="text-align: center; margin-bottom: 20px; border-bottom: 3px solid #2563eb; padding-bottom: 15px;">
                        <h1 style="font-size: 28px; color: #1e40af; margin: 0 0 10px 0;">èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ </h1>
                        ${siteName || sashColor ? `<h2 style="font-size: 18px; color: #374151; margin: 0 0 10px 0;">ğŸ“ ${siteName}${sashColor ? ` ï¼ ğŸ¨ ${sashColor}` : ''}</h2>` : ''}
                        <p style="font-size: 14px; color: #6b7280; margin: 0;">${new Date().toLocaleDateString('ja-JP', {year: 'numeric', month: 'long', day: 'numeric'})}</p>
                    </div>
                `;
                
                const resultCanvas = document.getElementById('result-canvas');
                if (resultCanvas) {
                    const canvasDiv = document.createElement('div');
                    canvasDiv.style.cssText = 'margin-bottom: 20px; padding: 20px; background: #f0f9ff; border-radius: 10px;';
                    canvasDiv.innerHTML = '<h3 style="font-size: 18px; color: #1e40af; margin: 0 0 15px 0;">ğŸ“ æ¸¬å®šå›³</h3>';
                    // canvasã‚’ç”»åƒã«å¤‰æ›ã—ã¦åŸ‹ã‚è¾¼ã‚€ï¼ˆv1.14.2ï¼‰
                    const canvasImg = document.createElement('img');
                    canvasImg.src = resultCanvas.toDataURL('image/png');
                    canvasImg.style.cssText = 'width: 100%; height: auto; display: block;';
                    canvasDiv.appendChild(canvasImg);
                    resultDiv.appendChild(canvasDiv);
                }
                
                
                const resultsDiv = document.createElement('div');
                resultsDiv.style.cssText = 'padding: 12px; background: #fef3c7; border-radius: 10px; border: 2px solid #f59e0b;';
                resultsDiv.innerHTML = '<h3 style="font-size: 18px; color: #92400e; margin: 0 0 15px 0;">ğŸ“Š è¨ˆç®—çµæœ</h3>';
                
                resultsDiv.innerHTML += generateResultsHTML();
                resultDiv.appendChild(resultsDiv);
                
                document.body.appendChild(resultDiv);
                
                const canvas = await html2canvas(resultDiv, {
                    scale: 2,
                    backgroundColor: '#ffffff',
                    logging: false,
                    useCORS: true
                });
                
                document.body.removeChild(resultDiv);
                
                canvas.toBlob(async (blob) => {
                    if (!blob) {
                        throw new Error('ç”»åƒã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ');
                    }
                    
                    try {
                        const filename = (siteName ? siteName + '_' : '') + getFilename() + '.png';
                        const file = new File([blob], filename, { type: 'image/png' });
                        
                        const shareData = {
                            title: 'èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ ' + (siteName ? ` - ${siteName}` : ''),
                            text: 'èº¯ä½“æ¡å¯¸ã®è¨ˆç®—çµæœã§ã™',
                            files: [file]
                        };
                        
                        // canShareã§ãƒ•ã‚¡ã‚¤ãƒ«å…±æœ‰å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
                        if (navigator.canShare && !navigator.canShare(shareData)) {
                            // ãƒ•ã‚¡ã‚¤ãƒ«å…±æœ‰ä¸å¯ã®å ´åˆã¯URLã®ã¿å…±æœ‰
                            await navigator.share({
                                title: shareData.title,
                                text: shareData.text,
                                url: window.location.href
                            });
                        } else {
                            await navigator.share(shareData);
                        }
                        
                    } catch (shareError) {
                        if (shareError.name === 'AbortError') {
                            // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ãŸå ´åˆ
                            return;
                        }
                        console.error('å…±æœ‰ã‚¨ãƒ©ãƒ¼:', shareError);
                        alert('å…±æœ‰ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ç”»åƒã¨ã—ã¦ä¿å­˜ã—ã¾ã™ã€‚');
                        await downloadAsPNG();
                    }
                }, 'image/png');
                
            } catch (error) {
                console.error('å…±æœ‰ã‚¨ãƒ©ãƒ¼:', error);
                alert('å…±æœ‰ã®æº–å‚™ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message + '\nç”»åƒã¨ã—ã¦ä¿å­˜ã—ã¾ã™ã€‚');
                await downloadAsPNG();
            }
        }
        
        function openManual() {
            document.getElementById('manual-modal').style.display = 'block';
            document.body.style.overflow = 'hidden';
        }
        
        function closeManual() {
            document.getElementById('manual-modal').style.display = 'none';
            document.body.style.overflow = 'auto';
        }
        
        window.onclick = function(event) {
            const modal = document.getElementById('manual-modal');
            if (event.target === modal) {
                closeManual();
            }
        }
    </script>
</body>
</html>
