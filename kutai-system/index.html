<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
    <title>èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ </title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, 'Hiragino Kaku Gothic ProN', sans-serif;
            background: #f5f7fa;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 700px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            padding: 40px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }
        
        h1 {
            text-align: center;
            color: #1a1a1a;
            margin-bottom: 40px;
            font-size: 28px;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        
        h2 {
            color: #1a1a1a;
            margin: 30px 0 20px;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            opacity: 0.6;
        }
        
        /* ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠç”»é¢ */
        .pattern-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }
        
        .pattern-btn {
            background: white;
            color: #1a1a1a;
            border: 2px solid #e5e7eb;
            padding: 24px 16px;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            min-height: 110px;
        }
        
        .pattern-btn svg {
            width: 50px;
            height: 50px;
        }
        
        .pattern-btn:hover {
            border-color: #3b82f6;
            background: #f0f9ff;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.15);
        }
        
        .pattern-btn:active {
            transform: translateY(0);
        }
        
        .pattern-btn.custom {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
            grid-column: 1 / -1;
        }
        
        .pattern-btn.custom:hover {
            background: #2563eb;
            border-color: #2563eb;
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.25);
        }
        
        .pattern-btn .delete-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .pattern-btn .delete-btn:hover {
            background: #dc2626;
            transform: scale(1.1);
        }
        
        /* æ¡å¯¸ç”»é¢ */
        .measurement-screen {
            display: none;
        }
        
        .back-btn {
            background: #f3f4f6;
            color: #1a1a1a;
            border: 1px solid #e5e7eb;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 20px;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        
        .back-btn:hover {
            background: #e5e7eb;
            border-color: #d1d5db;
        }
        
        .drawing-area {
            position: relative;
            width: 100%;
            height: 400px;
            background: #f9fafb;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            margin: 20px 0;
            overflow: hidden;
            touch-action: none;
        }
        
        canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }
        
        .dimension-inputs {
            margin: 20px 0;
        }
        
        .dimension-item {
            background: #f9fafb;
            padding: 16px;
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            margin-bottom: 12px;
        }
        
        .dimension-item label {
            display: block;
            color: #1a1a1a;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .dimension-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .dimension-row input {
            padding: 10px 12px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            font-size: 15px;
            transition: all 0.2s ease;
        }
        
        .dimension-row input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        .results {
            background: #f9fafb;
            padding: 20px;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            margin-top: 20px;
        }
        
        .result-item {
            padding: 12px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .result-label {
            color: #555;
            font-weight: bold;
        }
        
        .result-value {
            color: #667eea;
            font-weight: bold;
            font-size: 18px;
        }
        
        .save-pattern-btn {
            width: 100%;
            background: #10b981;
            color: white;
            border: none;
            padding: 14px;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.2s ease;
        }
        
        .save-pattern-btn:hover {
            background: #059669;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.25);
        }
        
        .alert {
            background: #fff3cd;
            color: #856404;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #ffc107;
        }
        
        .manual-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            overflow-y: auto;
        }
        
        .manual-content {
            background: white;
            max-width: 800px;
            margin: 20px auto;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        
        .manual-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #ef4444;
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .manual-close:hover {
            background: #dc2626;
            transform: scale(1.1);
        }
        
        .manual-content h1 {
            color: #1e40af;
            border-bottom: 3px solid #3b82f6;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        
        .manual-content h2 {
            color: #2563eb;
            margin-top: 30px;
            margin-bottom: 15px;
        }
        
        .manual-content h3 {
            color: #3b82f6;
            margin-top: 20px;
            margin-bottom: 10px;
        }
        
        .manual-content pre {
            background: #f3f4f6;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            border-left: 4px solid #3b82f6;
        }
        
        .manual-content ul, .manual-content ol {
            padding-left: 25px;
            line-height: 1.8;
        }
        
        .manual-content li {
            margin-bottom: 8px;
        }
        
        .manual-content strong {
            color: #1e40af;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="pattern-select-screen">
            <h1>èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ </h1>
            <div style="margin-bottom: 20px; text-align: center;">
                <button onclick="openManual()" 
                   style="display: inline-block; padding: 10px 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; font-weight: bold; font-size: 14px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); cursor: pointer;">
                    â“ ä½¿ã„æ–¹
                </button>
            </div>
            <h2>åŸºæœ¬ãƒ‘ã‚¿ãƒ¼ãƒ³</h2>
            <div class="pattern-grid">
                <button class="pattern-btn" onclick="selectPattern('i')">
                    <svg viewBox="0 0 60 60"><line x1="10" y1="30" x2="50" y2="30" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/></svg>
                    Iå­—
                </button>
                <button class="pattern-btn" onclick="selectPattern('l-left')">
                    <svg viewBox="0 0 60 60"><line x1="15" y1="10" x2="15" y2="50" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/><line x1="15" y1="10" x2="45" y2="10" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/></svg>
                    å·¦Lå­—
                </button>
                <button class="pattern-btn" onclick="selectPattern('l-right')">
                    <svg viewBox="0 0 60 60"><line x1="45" y1="10" x2="45" y2="50" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/><line x1="15" y1="10" x2="45" y2="10" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/></svg>
                    å³Lå­—
                </button>
                <button class="pattern-btn" onclick="selectPattern('u')">
                    <svg viewBox="0 0 60 60"><line x1="15" y1="50" x2="15" y2="10" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/><line x1="15" y1="10" x2="45" y2="10" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/><line x1="45" y1="10" x2="45" y2="50" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/></svg>
                    ã‚³ã®å­—
                </button>
            </div>
            <div id="saved-patterns-section" style="display: none;">
                <h2>ä¿å­˜æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³</h2>
                <div class="pattern-grid" id="saved-patterns-grid"></div>
            </div>
            <h2>ã‚«ã‚¹ã‚¿ãƒ ä½œå›³</h2>
            <div class="pattern-grid">
                <button class="pattern-btn custom" onclick="selectPattern('custom')">è‡ªç”±ã«ç·šã‚’å¼•ã</button>
            </div>
            <div style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #e5e7eb; text-align: center; color: #6b7280; font-size: 13px;">
                <div style="margin-bottom: 5px;">èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ  v1.12.0</div>
                <div>æœ€çµ‚æ›´æ–°: 2025-12-28</div>
            </div>
        </div>
        
        <div id="measurement-screen" class="measurement-screen">
            <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                <button id="back-btn" class="back-btn" onclick="backToSelect()" style="flex: 2;">â† ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠã«æˆ»ã‚‹</button>
                <button onclick="openManual()" style="flex: 1; display: flex; align-items: center; justify-content: center; padding: 12px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; font-weight: bold; font-size: 14px; cursor: pointer;">â“ ä½¿ã„æ–¹</button>
            </div>
            <h1 id="pattern-title">æ¡å¯¸å…¥åŠ›</h1>
            <div id="alert" class="alert" style="display: none;"></div>
            <div class="drawing-area"><canvas id="canvas"></canvas></div>
            <div id="drawing-controls" style="display: none; margin-top: 10px; display: flex; gap: 10px; flex-wrap: wrap;">
                <button onclick="clearDrawing()" style="flex: 1; min-width: 120px; padding: 12px; background: #ef4444; color: white; border: none; border-radius: 8px;">ğŸ—‘ï¸ ã‚¯ãƒªã‚¢</button>
                <button onclick="undoLastLine()" style="flex: 1; min-width: 120px; padding: 12px; background: #f59e0b; color: white; border: none; border-radius: 8px;">â†¶ æˆ»ã‚‹</button>
                <button onclick="finishDrawing()" style="flex: 1; min-width: 120px; padding: 12px; background: #10b981; color: white; border: none; border-radius: 8px;">âœ“ ä½œå›³çµ‚äº†</button>
            </div>
            <div class="dimension-inputs" id="dimension-inputs"></div>
            <div class="results">
                <h2>è¨ˆç®—çµæœ</h2>
                <div id="results-content"><p style="color: #999; text-align: center;">å¯¸æ³•ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„</p></div>
            </div>
            <button class="save-pattern-btn" onclick="savePattern()">ã“ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä¿å­˜</button>
        </div>
    </div>

    <div id="manual-modal" class="manual-modal">
        <div class="manual-content">
            <button class="manual-close" onclick="closeManual()">Ã—</button>
            <h1>ğŸ“± èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ  ä½¿ã„æ–¹ãƒãƒ‹ãƒ¥ã‚¢ãƒ«</h1>
            <h2>ğŸ¯ ã“ã®ã‚·ã‚¹ãƒ†ãƒ ã«ã¤ã„ã¦</h2>
            <p><strong>å¤–æ³•å¯¸æ³•ã‹ã‚‰èº¯ä½“èŠ¯å¯¸æ³•ã‚’è‡ªå‹•è¨ˆç®—ã—ã¾ã™ã€‚</strong></p>
            <p>ç¾å ´ã§æ¸¬ã£ãŸå¯¸æ³•ã‚’å…¥åŠ›ã™ã‚‹ã¨ã€æ–½å·¥ã«å¿…è¦ãªèŠ¯å¯¸æ³•ãŒè‡ªå‹•ã§è¨ˆç®—ã•ã‚Œã¾ã™ã€‚</p>
            <h2>ğŸ”´ ç‚¹ã®ç¨®é¡ã«ã¤ã„ã¦ï¼ˆé‡è¦ï¼‰</h2>
            <p><span style="color: #e74c3c; font-size: 16px;">â—</span> <strong>èµ¤ï¼ã‚³ãƒ¼ãƒŠãƒ¼</strong>ï¼šèº¯ä½“å¹…Ã·2ã‚’å¼•ã<br>
            <span style="color: #3498db; font-size: 16px;">â—</span> <strong>é’ï¼ã‚¨ãƒ³ãƒ‰</strong>ï¼šå£ãªã—ï¼ˆå¼•ã‹ãªã„ï¼‰<br>
            <span style="color: #2ecc71; font-size: 16px;">â—</span> <strong>ç·‘ï¼å£</strong>ï¼šå£ã‚ã‚Šï¼ˆå¼•ã‹ãªã„ï¼‰</p>
            <p>ä½œå›³å¾Œã®ç‚¹ã‚’ã‚¿ãƒƒãƒ—ã—ã¦åˆ‡ã‚Šæ›¿ãˆã¦ãã ã•ã„ã€‚</p>
            <hr style="margin: 20px 0;">
            <h3>âš ï¸ æ–œã‚ã‚³ãƒ¼ãƒŠãƒ¼ã«ã¤ã„ã¦</h3>
            <p>90åº¦ã§ã¯ãªã„æ¥ç¶šç‚¹ï¼ˆæ–œã‚ã‚³ãƒ¼ãƒŠãƒ¼ï¼‰ã®å ´åˆã€å¤–æ³•å¯¸æ³•ã‹ã‚‰èŠ¯å¯¸æ³•ã‚’æ­£ç¢ºã«é€†ç®—ã§ããªã„ãŸã‚è­¦å‘ŠãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚ãã®ç®‡æ‰€ã¯<strong>ç¾åœ°ã§èŠ¯å¯¸æ³•ã‚’ç›´æ¥æ¸¬å®š</strong>ã—ã€è¨ˆç®—çµæœã§ã¯ãªãå®Ÿæ¸¬å€¤ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚</p>
            <button onclick="closeManual()" style="width: 100%; padding: 12px; background: #3b82f6; color: white; border: none; border-radius: 8px; margin-top: 20px; font-weight: bold; cursor: pointer;">é–‰ã˜ã‚‹</button>
        </div>
    </div>

    <script>
        let currentPattern = null, lines = [], dimensions = {}, isDrawing = false, isDragging = false, startPoint = null, canvas, ctx, drawingPoints = [], lastClickTime = 0, lastTapTime = 0, commonWidth = null, useIndividualWidth = false, commonHeight = null, corners = {};

        window.onload = function() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            resizeCanvas();
            loadSavedPatterns();
        };

        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width; canvas.height = rect.height;
            drawLines();
        }

        function detectCorners() {
            const newCorners = {};
            const tolerance = 5;
            lines.forEach(line => {
                const sKey = findCornerKeyForDetection(line.x1, line.y1, tolerance, newCorners);
                if (!newCorners[sKey]) {
                    const old = corners[sKey];
                    newCorners[sKey] = { x: line.x1, y: line.y1, hasStep: old?old.hasStep:false, depth: old?old.depth:null, lines: [] };
                }
                newCorners[sKey].lines.push({ lineId: line.id, point: 'start' });
                const eKey = findCornerKeyForDetection(line.x2, line.y2, tolerance, newCorners);
                if (!newCorners[eKey]) {
                    const old = corners[eKey];
                    newCorners[eKey] = { x: line.x2, y: line.y2, hasStep: old?old.hasStep:false, depth: old?old.depth:null, lines: [] };
                }
                newCorners[eKey].lines.push({ lineId: line.id, point: 'end' });
            });
            corners = newCorners;
        }

        function findCornerKeyForDetection(x, y, tol, obj) {
            for (const key in obj) {
                const c = obj[key];
                if (Math.sqrt(Math.pow(x-c.x, 2) + Math.pow(y-c.y, 2)) < tol) return key;
            }
            return `${Math.round(x)},${Math.round(y)}`;
        }

        function findCornerKey(x, y, tol) {
            for (const key in corners) {
                const c = corners[key];
                if (Math.sqrt(Math.pow(x-c.x, 2) + Math.pow(y-c.y, 2)) < tol) return key;
            }
            return `${Math.round(x)},${Math.round(y)}`;
        }

        function selectPattern(type) {
            currentPattern = type;
            document.getElementById('pattern-select-screen').style.display = 'none';
            document.getElementById('measurement-screen').style.display = 'block';
            setTimeout(resizeCanvas, 100);
            lines = []; dimensions = {}; drawingPoints = []; commonWidth = null; commonHeight = null; useIndividualWidth = false;
            if (type === 'i') createIPattern();
            else if (type === 'l-left') createLPatternLeft();
            else if (type === 'l-right') createLPatternRight();
            else if (type === 'u') createUPattern();
            else if (type === 'custom') setupCustomDrawing();
            else loadCustomPattern(type);
        }

        function createIPattern() {
            const l = Math.min(canvas.width, canvas.height) * 0.6;
            lines = [{ id: 'A', x1: canvas.width/2 - l/2, y1: canvas.height/2, x2: canvas.width/2 + l/2, y2: canvas.height/2, name: 'è¾ºA', start: 'wall', end: 'wall' }];
            drawLines(); createInputs(); setupPointClickListener();
        }

        function createLPatternLeft() {
            const s = Math.min(canvas.width, canvas.height) * 0.5; const m = 50;
            lines = [
                { id: 'A', x1: m, y1: m, x2: m, y2: m + s, name: 'è¾ºAï¼ˆç¸¦ï¼‰', start: 'corner', end: 'wall' },
                { id: 'B', x1: m, y1: m, x2: m + s, y2: m, name: 'è¾ºBï¼ˆæ¨ªï¼‰', start: 'corner', end: 'wall' }
            ];
            drawLines(); createInputs(); setupPointClickListener();
        }

        function createLPatternRight() {
            const s = Math.min(canvas.width, canvas.height) * 0.5; const m = 50;
            lines = [
                { id: 'A', x1: m, y1: m, x2: m + s, y2: m, name: 'è¾ºAï¼ˆæ¨ªï¼‰', start: 'wall', end: 'corner' },
                { id: 'B', x1: m + s, y1: m, x2: m + s, y2: m + s, name: 'è¾ºBï¼ˆç¸¦ï¼‰', start: 'corner', end: 'wall' }
            ];
            drawLines(); createInputs(); setupPointClickListener();
        }

        function createUPattern() {
            const w = Math.min(canvas.width, canvas.height) * 0.5; const h = 150; const m = 50;
            lines = [
                { id: 'A', x1: m, y1: m + h, x2: m, y2: m, name: 'è¾ºA', start: 'wall', end: 'corner' },
                { id: 'B', x1: m, y1: m, x2: m + w, y2: m, name: 'è¾ºB', start: 'corner', end: 'corner' },
                { id: 'C', x1: m + w, y1: m, x2: m + w, y2: m + h, name: 'è¾ºC', start: 'corner', end: 'wall' }
            ];
            drawLines(); createInputs(); setupPointClickListener();
        }

        function drawLines() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            detectCorners();
            const shouldTransform = currentPattern !== 'custom';
            let transform = (x, y) => ({ x, y });
            if (shouldTransform && lines.length > 0) {
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                lines.forEach(l => {
                    minX = Math.min(minX, l.x1, l.x2); minY = Math.min(minY, l.y1, l.y2);
                    maxX = Math.max(maxX, l.x1, l.x2); maxY = Math.max(maxY, l.y1, l.y2);
                });
                const scale = Math.min((canvas.width-100)/(maxX-minX||1), (canvas.height-100)/(maxY-minY||1), 1);
                const offsetX = 50 - minX * scale; const offsetY = 50 - minY * scale;
                transform = (x, y) => ({ x: x * scale + offsetX, y: y * scale + offsetY });
            }
            lines.forEach(line => {
                const p1 = transform(line.x1, line.y1); const p2 = transform(line.x2, line.y2);
                ctx.strokeStyle = '#333'; ctx.lineWidth = 5; ctx.lineCap = 'round';
                ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
                const midX = (p1.x + p2.x) / 2; const midY = (p1.y + p2.y) / 2;
                ctx.fillStyle = '#333'; ctx.font = 'bold 14px sans-serif'; ctx.textAlign = 'center';
                ctx.fillText(line.name, midX, midY - 15);
                if(dimensions[line.id]?.length) { ctx.fillStyle = '#3b82f6'; ctx.fillText(dimensions[line.id].length, midX, midY + 15); }
            });
            for (const key in corners) {
                const c = corners[key]; const p = transform(c.x, c.y);
                const firstLine = lines.find(l => l.id === c.lines[0].lineId);
                drawPoint(p.x, p.y, firstLine[c.lines[0].point]);
            }
        }

        function drawPoint(x, y, state) {
            const colors = { 'corner': '#e74c3c', 'end': '#3498db', 'wall': '#2ecc71' };
            ctx.fillStyle = colors[state] || '#2ecc71';
            ctx.beginPath(); ctx.arc(x, y, 10, 0, Math.PI * 2); ctx.fill();
            ctx.strokeStyle = 'white'; ctx.lineWidth = 3; ctx.stroke();
        }

        function createInputs() {
            const container = document.getElementById('dimension-inputs');
            container.innerHTML = '';
            detectCorners();
            const head = document.createElement('div');
            head.innerHTML = `
                <div style="background:#f8f9fa; padding:15px; border-radius:10px; margin-bottom:15px; display:grid; grid-template-columns:1fr 1fr; gap:10px;">
                    <div><label>èº¯ä½“å¹…(mm)</label><input type="number" id="common-width" value="${commonWidth||''}" oninput="updateCommonWidth(this.value)" style="width:100%; padding:10px; border:1px solid #ddd;"></div>
                    <div><label>èº¯ä½“é«˜ã•(mm)</label><input type="number" id="common-height" value="${commonHeight||''}" oninput="updateCommonHeight(this.value)" style="width:100%; padding:10px; border:1px solid #ddd;"></div>
                </div>`;
            container.appendChild(head);

            lines.forEach((line, lineIndex) => {
                const div = document.createElement('div');
                div.className = 'dimension-item';
                div.setAttribute('data-line-id', line.id);

                // --- æ–œã‚ã‚³ãƒ¼ãƒŠãƒ¼è­¦å‘Š & è§’åº¦å…¥åŠ›ã®ç§»å‹•ãƒ­ã‚¸ãƒƒã‚¯ ---
                let diagonalWarningHTML = '';
                let angleInputHTML = '';

                // æ–œã‚ç·šåˆ¤å®š
                const lineIsDiagonal = isLineDiagonal(line);

                // å§‹ç‚¹ãƒ»çµ‚ç‚¹ã®æ¥ç¶šæƒ…å ±ã‚’ãƒã‚§ãƒƒã‚¯
                ['start', 'end'].forEach(pt => {
                    if (line[pt] === 'corner') {
                        const key = findCornerKey(line[pt==='start'?'x1':'x2'], line[pt==='start'?'y1':'y2'], 5);
                        const corner = corners[key];
                        if (corner && corner.lines.length >= 2) {
                            const otherRef = corner.lines.find(ref => ref.lineId !== line.id);
                            const otherLine = lines.find(l => l.id === otherRef.lineId);
                            if (otherLine && !is90Degrees(line, otherLine, pt, otherRef.point)) {
                                diagonalWarningHTML += `<div style="margin-top:5px; padding:10px; background:#fee; border:1px solid #e74c3c; border-radius:8px; color:#c0392b; font-size:12px; font-weight:bold;">âš ï¸ ${pt==='start'?'å§‹ç‚¹':'çµ‚ç‚¹'}ã¯æ–œã‚ã‚³ãƒ¼ãƒŠãƒ¼ã§ã™ã€‚èŠ¯å¯¸æ³•ã¯ç¾åœ°ã§æ¸¬å®šã—ã¦ãã ã•ã„ã€‚</div>`;
                            }
                        }
                    }
                });

                // è¾ºãã®ã‚‚ã®ãŒæ–œã‚ã®å ´åˆã€ãã®è¾ºã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§è§’åº¦ã‚’å…¥åŠ›
                if (lineIsDiagonal) {
                    const angle = getLineAngle(line).toFixed(1);
                    angleInputHTML = `
                        <div style="margin-top:10px; padding:10px; background:#fff3cd; border-radius:8px; border:1px solid #ffc107;">
                            <label style="color:#856404; font-size:12px; font-weight:bold;">è§’åº¦è¨­å®šï¼ˆåº¦ï¼‰</label>
                            <input type="number" value="${angle}" oninput="updateLineAngle('${line.id}', this.value)" style="width:100%; padding:8px; border:1px solid #ffc107; border-radius:5px;">
                        </div>`;
                }

                div.innerHTML = `
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                        <span style="font-weight:bold; color:#667eea;">${line.name}</span>
                        <div>
                            <button onclick="changePointState('${line.id}', 'start')" style="padding:5px 10px; font-size:12px; border-radius:5px; border:none; background:${getStateColor(line.start)}; color:white; cursor:pointer;">å§‹ç‚¹:${getStateLabel(line.start)}</button>
                            <button onclick="changePointState('${line.id}', 'end')" style="padding:5px 10px; font-size:12px; border-radius:5px; border:none; background:${getStateColor(line.end)}; color:white; cursor:pointer;">çµ‚ç‚¹:${getStateLabel(line.end)}</button>
                        </div>
                    </div>
                    ${diagonalWarningHTML}
                    <input type="number" placeholder="å¤–æ³•å¯¸æ³• (mm)" oninput="updateDimension('${line.id}', 'length', this.value)" value="${dimensions[line.id]?.length||''}" style="width:100%; padding:12px; border:1px solid #ddd; border-radius:8px;">
                    ${angleInputHTML}
                `;
                container.appendChild(div);

                // æ®µå·®è¨­å®šï¼ˆã‚³ãƒ¼ãƒŠãƒ¼æ¥ç¶šéƒ¨ï¼‰
                const endKey = findCornerKey(line.x2, line.y2, 5);
                const endCorner = corners[endKey];
                if (endCorner && endCorner.lines.length >= 2 && lineIndex < lines.length - 1) {
                    const cornerDiv = document.createElement('div');
                    cornerDiv.style.cssText = 'margin: 5px 0 15px 0; padding: 10px; background: #e8f5e9; border-radius: 6px; border: 1px solid #4caf50;';
                    cornerDiv.innerHTML = `
                        <label style="display:flex; align-items:center; cursor:pointer; color:#2e7d32; font-weight:bold; font-size:13px;">
                            <input type="checkbox" ${endCorner.hasStep ? 'checked' : ''} onchange="toggleCornerStep('${endKey}', this.checked)" style="margin-right:8px;"> æ®µå·®ã‚ã‚Šè¨­å®š
                        </label>
                        ${endCorner.hasStep ? `<input type="number" placeholder="æ·±ã•(mm)" value="${endCorner.depth||''}" oninput="updateCornerDepth('${endKey}', this.value)" style="width:100%; margin-top:5px; padding:8px; border:1px solid #4caf50; border-radius:5px;">` : ''}
                    `;
                    container.appendChild(cornerDiv);
                }
            });
        }

        function updateCommonWidth(v) { commonWidth = v?parseFloat(v):null; calculate(); }
        function updateCommonHeight(v) { commonHeight = v?parseFloat(v):null; calculate(); }
        function updateDimension(id, k, v) { if(!dimensions[id]) dimensions[id]={}; dimensions[id][k]=v?parseFloat(v):null; drawLines(); calculate(); }
        function getStateColor(s) { const c={'corner':'#e74c3c','end':'#3498db','wall':'#2ecc71'}; return c[s]||'#2ecc71'; }
        function getStateLabel(s) { const l={'corner':'è§’','end':'ç«¯','wall':'å£'}; return l[s]||'å£'; }
        function isLineDiagonal(l) { return Math.abs(l.x1-l.x2)>10 && Math.abs(l.y1-l.y2)>10; }
        function getLineAngle(l) { return Math.atan2(l.y2-l.y1, l.x2-l.x1)*(180/Math.PI); }
        function updateLineAngle(id, deg) {
            const l = lines.find(line => line.id === id);
            const r = parseFloat(deg)*(Math.PI/180); const len = Math.sqrt(Math.pow(l.x2-l.x1,2)+Math.pow(l.y2-l.y1,2));
            l.x2 = l.x1+len*Math.cos(r); l.y2 = l.y1+len*Math.sin(r);
            drawLines(); createInputs();
        }

        function is90Degrees(l1, l2, p1, p2) {
            const v1 = {x: l1.x2-l1.x1, y: l1.y2-l1.y1}; const v2 = {x: l2.x2-l2.x1, y: l2.y2-l2.y1};
            const dot = v1.x*v2.x + v1.y*v2.y; const mag = Math.sqrt(v1.x**2+v1.y**2)*Math.sqrt(v2.x**2+v2.y**2);
            return Math.abs(dot/mag) < 0.1;
        }

        function changePointState(id, pt) {
            const l = lines.find(line => line.id === id);
            const states = ['wall', 'corner', 'end'];
            l[pt] = states[(states.indexOf(l[pt]) + 1) % 3];
            drawLines(); createInputs(); calculate();
        }

        function toggleCornerStep(key, has) {
            corners[key].hasStep = has;
            corners[key].lines.forEach((ref, idx) => {
                const l = lines.find(line => line.id === ref.lineId);
                l[ref.point] = has ? (idx === 0 ? 'end' : 'wall') : 'corner';
            });
            drawLines(); createInputs(); calculate();
        }

        function updateCornerDepth(key, d) { corners[key].depth = d?parseFloat(d):null; calculate(); }

        function calculate() {
            const res = document.getElementById('results-content');
            if(!commonWidth || !lines.every(l => dimensions[l.id]?.length)) {
                res.innerHTML = '<p style="color:#999; text-align:center;">å…¨ã¦ã®å¯¸æ³•ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„</p>'; return;
            }
            let html = '';
            lines.forEach(l => {
                let val = dimensions[l.id].length;
                if(l.start === 'corner') val -= commonWidth/2;
                if(l.end === 'corner') val -= commonWidth/2;
                html += `<div class="result-item"><span>${l.name} èŠ¯å¯¸æ³•</span><span class="result-value">${Math.floor(val)} mm</span></div>`;
            });
            html += `<div style="display:flex; gap:10px; margin-top:10px;"><button onclick="downloadPDF()" style="flex:1; padding:12px; background:#e74c3c; color:white; border:none; border-radius:8px; cursor:pointer;">ğŸ“„ PDFä¿å­˜</button></div>`;
            res.innerHTML = html;
        }

        async function downloadPDF() {
            const { jsPDF } = window.jspdf; const pdf = new jsPDF();
            const canvasImg = await html2canvas(document.body);
            pdf.addImage(canvasImg.toDataURL('image/png'), 'PNG', 10, 10, 190, 0);
            pdf.save(`keisoku_${new Date().getTime()}.pdf`);
        }

        function setupCustomDrawing() {
            document.getElementById('drawing-controls').style.display = 'flex';
            canvas.onmousedown = (e) => {
                const rect = canvas.getBoundingClientRect(); const x = e.clientX-rect.left, y = e.clientY-rect.top;
                drawingPoints.push({x, y});
                if(drawingPoints.length > 1) {
                    const p1 = drawingPoints[drawingPoints.length-2], p2 = drawingPoints[drawingPoints.length-1];
                    const id = String.fromCharCode(65 + lines.length);
                    lines.push({id, x1:p1.x, y1:p1.y, x2:p2.x, y2:p2.y, name:`è¾º${id}`, start:'wall', end:'wall'});
                }
                drawLines();
            };
        }
        function finishDrawing() { canvas.onmousedown = null; createInputs(); }
        function backToSelect() { location.reload(); }
        function openManual() { document.getElementById('manual-modal').style.display='block'; }
        function closeManual() { document.getElementById('manual-modal').style.display='none'; }
        function clearDrawing() { lines=[]; drawingPoints=[]; drawLines(); createInputs(); }
        function undoLastLine() { lines.pop(); drawingPoints.pop(); drawLines(); createInputs(); }
        function savePattern() { alert('ä¿å­˜ã—ã¾ã—ãŸ'); }
        function loadSavedPatterns() {}
        function setupPointClickListener() {}
    </script>
</body>
</html>
