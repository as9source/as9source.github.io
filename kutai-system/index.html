<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- „Ç≠„É£„ÉÉ„Ç∑„É•ÂØæÁ≠ñ -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
    <title>Ë∫Ø‰ΩìÊé°ÂØ∏„Ç∑„Çπ„ÉÜ„É†</title>
    <!--
    ========================================
    Ë∫Ø‰ΩìÊé°ÂØ∏„Ç∑„Çπ„ÉÜ„É†
    ========================================
    „Éê„Éº„Ç∏„Éß„É≥: 1.11.1
    ÊúÄÁµÇÊõ¥Êñ∞: 2024-12-27
    
    [Êõ¥Êñ∞Â±•Ê≠¥]
    v1.11.1 (2024-12-27)
    - ‰Ωø„ÅÑÊñπ„Éû„Éã„É•„Ç¢„É´„ÇíËøΩÂä†ÔºàmodalË°®Á§∫Ôºâ
    - „Éë„Çø„Éº„É≥ÈÅ∏ÊäûÁîªÈù¢„Å´„Äå‚ùì ‰Ωø„ÅÑÊñπ„Äç„Éú„Çø„É≥„ÇíËøΩÂä†
    - Êé°ÂØ∏ÁîªÈù¢„Å´„ÇÇ„Äå‚ùì ‰Ωø„ÅÑÊñπ„Äç„Éú„Çø„É≥„ÇíËøΩÂä†
    - „Éû„Éã„É•„Ç¢„É´ÂÜÖÂÆπÔºöÂ§ñÊ≥ï‚ÜíË∫Ø‰ΩìËäØ„ÅÆË™¨Êòé„ÄÅËá™Áî±‰ΩúÂõ≥„ÅÆË©≥„Åó„ÅÑ‰Ωø„ÅÑÊñπ„ÄÅÁÇπ„ÅÆÁ®ÆÈ°û„ÄÅÊÆµÂ∑ÆË®≠ÂÆö„ÄÅË®àÁÆóÁµêÊûú„ÄÅ‰øùÂ≠ò„ÉªÂÖ±Êúâ„ÄÅ„Çà„Åè„ÅÇ„ÇãË≥™Âïè
    - „Ç∑„Çπ„ÉÜ„É†ÂÜÖ„ÅßÂÆåÁµêÔºàGitHub„Å´È£õ„Å∞„Å™„ÅÑÔºâ
    
    v1.11.0 (2024-12-27)
    - Áõ¥Á∑ö„Åå‰∏¶„Çì„Å†Â†¥Âêà„Å´Ë®àÁÆóÁµêÊûú„ÅÆÂõ≥„ÅåË°®Á§∫„Åï„Çå„Å™„ÅÑÂïèÈ°å„Çí‰øÆÊ≠£
    - „Éï„Ç°„Ç§„É´ÂêçÂÖ•ÂäõÊ¨Ñ„ÇíÂâäÈô§
    - ‰øùÂ≠òÁØÑÂõ≤„Éà„Ç∞„É´„ÇíÂâäÈô§
    - Â∏∏„Å´„Éö„Éº„Ç∏ÂÖ®‰Ωì„Çí‰øùÂ≠òÔºà„Éá„Éï„Ç©„É´„ÉàÔºâ
    - „Éï„Ç°„Ç§„É´Âêç„ÅØÂõ∫ÂÆöÔºökutai-keisoku_YYYY-MM-DD
    - ÂÖ±ÊúâÊ©üËÉΩ„ÅåÊ≠£Â∏∏„Å´Âãï‰Ωú„Åô„Çã„Çà„ÅÜ„Å´ÊîπÂñÑ
    
    v1.10.6 (2024-12-27)
    - ÊÆµÂ∑Æ„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅÆÁÇπ„ÅÆÈÖçÁΩÆ„ÇíÊîπÂñÑ
    - Á∑ö„Åã„ÇâÂûÇÁõ¥ÊñπÂêë„Å´„Åö„Çâ„Åô ‚Üí Á∑ö„ÅÆÊñπÂêë„Å´Ê≤ø„Å£„Å¶Ëßí„Åã„Çâ„Åö„Çâ„Åô
    - „Å©„Å°„Çâ„ÅÆËæ∫„ÅÆÁÇπ„Å™„ÅÆ„ÅãÊòéÁ¢∫„Å´Âà§Âà•„Åß„Åç„Çã„Çà„ÅÜ„Å´
    - ‰ΩúÂõ≥ÁîªÈù¢„Å®Ë®àÁÆóÁµêÊûú„ÅÆ‰∏°Êñπ„Å´ÈÅ©Áî®
    
    v1.10.5 (2024-12-27)
    - ÊÆµÂ∑Æ„ÅÇ„Çä„ÉÅ„Çß„ÉÉ„ÇØÊôÇ„ÅÆÁÇπ„ÅÆÁ®ÆÈ°û„ÇíÊîπÂñÑ
    - „ÉÅ„Çß„ÉÉ„ÇØÊôÇÔºö1„Å§ÁõÆ„Çí„Ç®„É≥„ÉâÔºàÈùíÔºâ„ÄÅÊÆã„Çä„ÇíÂ£ÅÔºàÁ∑ëÔºâ„Å´Â§âÊõ¥
    - „ÉÅ„Çß„ÉÉ„ÇØÂ§ñ„ÅôÊôÇÔºö„Ç≥„Éº„Éä„ÉºÔºàËµ§Ôºâ„Å´Êàª„Åô
    - Ë™§Êìç‰ΩúÊôÇ„ÅÆÂæ©ÂÖÉ„ÅåÁ∞°Âçò„Å´
    
    v1.10.4 (2024-12-27)
    - Âè≥LÂ≠ó„ÅÆË®àÁÆóÁµêÊûú„ÅÆÂõ≥„ÅÆÁ†¥Á∂ª„Çí‰øÆÊ≠£
    - Á∑ö„ÅÆÊé•Á∂öÈñ¢‰øÇ„ÇíËÄÉÊÖÆ„Åó„Å¶Â∫ßÊ®ô„ÇíË™øÊï¥
    - ÂÖ±ÊúâÁÇπ„ÇíÊåÅ„Å§Á∑ö„ÅåÊ≠£„Åó„ÅèÁπã„Åå„Çã„Çà„ÅÜ„Å´ÊîπÂñÑ
    - LÂ≠ó„ÇÑ„Ç≥„ÅÆÂ≠ó„Å™„Å©„ÅÆÂΩ¢Áä∂„ÅåÊ≠£„Åó„ÅèË°®Á§∫„Åï„Çå„Çã
    
    v1.10.3 (2024-12-27)
    - Ë®àÁÆóÁµêÊûú„ÅÆÂõ≥„ÅÆÊèèÁîª„É≠„Ç∏„ÉÉ„ÇØ„ÇíÊ†πÊú¨ÁöÑ„Å´‰øÆÊ≠£
    - ÂÖÉ„ÅÆÂ∫ßÊ®ôÈñ¢‰øÇ„Çí‰øùÊåÅ„Åó„Åü„Åæ„ÅæÂÆüÂØ∏Ê≥ï„ÇíÈÅ©Áî®
    - LÂ≠ó„Å™„Å©„ÅÆÂΩ¢Áä∂„ÅåÊ≠£„Åó„ÅèË°®Á§∫„Åï„Çå„Çã„Çà„ÅÜ„Å´
    - Á∑ö„ÇíÈ†ÜÁï™„Å´ÈÄ£Áµê„Åô„ÇãÂïèÈ°å„ÇíËß£Ê∂à
    
    v1.10.2 (2024-12-27)
    - Â∑¶LÂ≠ó„Éë„Çø„Éº„É≥„ÅÆ„Ç≥„Éº„Éä„ÉºÈÉ®„Çí‰øÆÊ≠£ÔºàËæ∫A„ÅÆÂßãÁÇπ„Çícorner„Å´Ôºâ
    - Ë®àÁÆóÁµêÊûú„ÅÆÂõ≥„ÅÆYËª∏ÂèçËª¢ÂïèÈ°å„Çí‰øÆÊ≠£Ôºà‰∏ä‰∏ã„ÅåÊ≠£„Åó„ÅèË°®Á§∫„Åï„Çå„ÇãÔºâ
    - LÂ≠ó„ÅÆËßí„ÅåÊ≠£„Åó„Åè„Ç≥„Éº„Éä„Éº„Å®„Åó„Å¶Ë™çË≠ò„Åï„Çå„Çã„Çà„ÅÜ„Å´‰øÆÊ≠£
    
    v1.10.1 (2024-12-27)
    - ‰∏äÈÉ®„ÅÆÂ§ß„Åç„ÅÑ„ÇØ„É™„Ç¢„Éú„Çø„É≥„ÇíÂâäÈô§Ôºà‰ΩúÂõ≥„Ç≥„É≥„Éà„É≠„Éº„É´„ÅÆ„ÇØ„É™„Ç¢„Éú„Çø„É≥„ÅÆ„ÅøÔºâ
    - ÊÆµÂ∑Æ„Åå„ÅÇ„ÇãÂ†¥Âêà„ÄÅ„Ç®„É≥„ÉâÔºàÈùíÔºâ„Çí‰∏ä„Å´„ÄÅÂ£ÅÔºàÁ∑ëÔºâ„Çí‰∏ã„Å´ÈÖçÁΩÆ
    - ÁÇπ„ÅÆÈñìÈöî„ÇíÂ∫É„Åí„Å¶Èáç„Å™„Çâ„Å™„ÅÑ„Çà„ÅÜ„Å´ÊîπÂñÑÔºàoffset: 12 ‚Üí 20Ôºâ
    - Ëá™Áî±‰ΩúÂõ≥„ÅÆÂ∫ßÊ®ôÂ§âÊèõÂïèÈ°å„Çí‰øÆÊ≠£
    
    v1.10.0 (2024-12-27)
    - Âü∫Êú¨„Éë„Çø„Éº„É≥ÔºàIÂ≠ó„ÄÅLÂ≠ó„ÄÅ„Ç≥„ÅÆÂ≠óÔºâ„ÅåÁîªÈù¢„Åã„Çâ„ÅØ„ÅøÂá∫„ÇãÂïèÈ°å„Çí‰øÆÊ≠£
    - „Ç≠„É£„É≥„Éê„Çπ„Çµ„Ç§„Ç∫„Å´Âøú„Åò„Å¶Ëá™ÂãïÁöÑ„Å´Âõ≥ÂΩ¢„ÇíÈÖçÁΩÆ
    - „ÇØ„É™„Ç¢„Éú„Çø„É≥„ÇíÂÆüË£ÖÔºà‰ΩúÂõ≥„Å®ÂÖ•Âäõ„Çí„É™„Çª„ÉÉ„ÉàÔºâ
    - Á¢∫Ë™ç„ÉÄ„Ç§„Ç¢„É≠„Ç∞‰ªò„Åç„ÅßË™§Êìç‰Ωú„ÇíÈò≤Ê≠¢
    
    v1.9.0 (2024-12-27)
    - „Éï„Ç°„Ç§„É´Âêç„ÇíËá™Áî±„Å´Ë®≠ÂÆö„Åß„Åç„ÇãÊ©üËÉΩ„ÇíËøΩÂä†
    - ‰øùÂ≠òÁØÑÂõ≤„Éà„Ç∞„É´„ÅÆ‰∏ä„Å´ÂÖ•ÂäõÊ¨Ñ„ÇíËøΩÂä†
    - ÂÖ•Âäõ„Åó„ÅüÂêçÂâç„ÅØ‰øùÂ≠ò„Åï„Çå„ÄÅÊ¨°Âõû„ÇÇ‰Ωø„Åà„Çã
    - ‰æãÔºö„ÄåÁî∞‰∏≠ÈÇ∏„Äç‚Üí Áî∞‰∏≠ÈÇ∏_2024-12-27.pdf
    - Á©∫Ê¨Ñ„ÅÆÂ†¥Âêà„ÅØ„Äåkutai-keisoku„Äç„Åå‰ΩøÁî®„Åï„Çå„Çã
    
    v1.8.2 (2024-12-27)
    - „Éï„Ç°„Ç§„É´Âêç„ÇíËã±Ë™ûÔºà„É≠„Éº„ÉûÂ≠óÔºâ„Å´Â§âÊõ¥
    - ÊñáÂ≠óÂåñ„Åë„ÇíÈò≤Ê≠¢Ôºökutai-keisoku_2024-12-27.pdf
    - „Åô„Åπ„Å¶„ÅÆ‰øùÂ≠ò„ÉªÂÖ±Êúâ„ÅßÊ≠£„Åó„ÅÑ„Éï„Ç°„Ç§„É´Âêç„ÅåË°®Á§∫„Åï„Çå„Çã
    
    v1.8.1 (2024-12-27)
    - Âá°‰æã„ÅÆ„Éá„Ç∂„Ç§„É≥„ÇíÂΩ±‰ªò„ÅçÊñáÂ≠ó„Å´Â§âÊõ¥ÔºàÁôΩÊäú„ÅçËÉåÊôØ„ÇíÂâäÈô§Ôºâ
    - PDF„ÇíÂøÖ„Åö1„Éö„Éº„Ç∏„Å´Âèé„ÇÅ„Çã„Çà„ÅÜ„Å´ÊîπÂñÑÔºàÁ∏ÆÂ∞è„Åó„Å¶ÂÖ®‰ΩìË°®Á§∫Ôºâ
    - Èï∑„ÅÑ„Éö„Éº„Ç∏„Åß„ÇÇÂàá„Çå„Åö„Å´1„Éö„Éº„Ç∏„Åß‰øùÂ≠òÂèØËÉΩ„Å´
    
    v1.8.0 (2024-12-27)
    - ‰øùÂ≠òÁØÑÂõ≤„ÇíÈÅ∏Êäû„Åß„Åç„Çã„Éà„Ç∞„É´„Çπ„Ç§„ÉÉ„ÉÅ„ÇíËøΩÂä†
    - „ÄåË®àÁÆóÁµêÊûú„ÅÆ„Åø„Äç„Å®„Äå„Éö„Éº„Ç∏ÂÖ®‰Ωì„Äç„ÇíÂàá„ÇäÊõø„ÅàÂèØËÉΩ„Å´
    - Áî®ÈÄî„Å´Âøú„Åò„Å¶‰øùÂ≠òÁØÑÂõ≤„ÇíÈÅ∏„Åπ„Çã„Çà„ÅÜ„Å´
    
    v1.7.0 (2024-12-27)
    - „Éö„Éº„Ç∏ÂÖ®‰Ωì„ÇíÂÖ±Êúâ„Åß„Åç„Çã„Çà„ÅÜ„Å´ÊîπÂñÑÔºà‰ΩúÂõ≥ + ÂÖ•Âäõ + Ë®àÁÆóÁµêÊûúÔºâ
    - PDF/PNG‰øùÂ≠òÊôÇ„ÇÇ„Éö„Éº„Ç∏ÂÖ®‰Ωì„Åå‰øùÂ≠ò„Åï„Çå„Çã
    - Ë®àÁÆóÁµêÊûú„ÅÆÂõ≥„Å´Âá°‰æã„ÇíËøΩÂä†ÔºàÁÇπ„ÅÆËâ≤„ÅÆË™¨ÊòéÔºâ
    - ‰ΩúÂõ≥ÁîªÈù¢„ÅÆÂõ≥„ÅØÂÖÉ„ÅÆÊØîÁéá„ÅÆ„Åæ„ÅæÔºàË®àÁÆóÁµêÊûú„ÅÆÂõ≥„ÅÆ„ÅøÂÆüÂØ∏Ê≥ïÊØîÁéáÔºâ
    - Âæå„ÅßÁ¢∫Ë™ç„Åô„ÇãÈöõ„Å´‰ΩúÂõ≥ÈÉ®ÂàÜ„ÇÇÂê´„Åæ„Çå„Çã„Çà„ÅÜ„Å´ÊîπÂñÑ
    
    v1.6.1 (2024-12-27)
    - Ë®àÁÆóÁµêÊûú„ÅÆÂõ≥„ÇíÂ§ßÂπÖ„Å´Ë¶ã„ÇÑ„Åô„ÅèÊîπÂñÑ
    - Á∑ö„ÅÆÂ§™„Åï„Çí5px„Å´Â¢óÂä†ÔºàÂ∞è„Åï„ÅÑËæ∫„Åß„ÇÇË¶ã„ÇÑ„Åô„ÅèÔºâ
    - ÊñáÂ≠ó„Çµ„Ç§„Ç∫„Çí16px„Å´Á∏ÆÂ∞èÔºà„Ç≥„É≥„Éë„ÇØ„Éà„Å´Ôºâ
    - ËÉåÊôØ„ÇíÂçäÈÄèÊòéÂåñÔºàÁ∑ö„ÅåÈÄè„Åë„Å¶Ë¶ã„Åà„ÇãÔºâ
    - ÊúÄÂ∞èË°®Á§∫Èï∑„Åï„Çí300px„Å´Â¢óÂä†
    - „ÉÜ„Ç≠„Çπ„Éà„Ç™„Éï„Çª„ÉÉ„Éà„Çí30px„Å´Ë™øÊï¥
    - „Çπ„Éû„Éõ„Åß„ÅÆË¶ñË™çÊÄß„ÇíÂ§ßÂπÖÊîπÂñÑ
    
    v1.6.0 (2024-12-27)
    - PDF‰øùÂ≠òÊ©üËÉΩËøΩÂä†ÔºàGoodNotes„ÄÅNotion„ÄÅ„ÇØ„É©„Ç¶„Éâ„Å´‰øùÂ≠òÂèØËÉΩÔºâ
    - PNGÁîªÂÉè‰øùÂ≠òÊ©üËÉΩËøΩÂä†
    - ÂÖ±ÊúâÊ©üËÉΩËøΩÂä†ÔºàiPhone„ÅÆÂÖ±Êúâ„É°„Éã„É•„Éº„Åã„ÇâÁõ¥Êé•ÂÖ±ÊúâÔºâ
    - Ë®àÁÆóÁµêÊûú„ÅÆÂõ≥„ÇíÁ∞°Âçò„Å´‰øùÂ≠ò„ÉªÂÖ±Êúâ„Åß„Åç„Çã„Çà„ÅÜ„Å´ÊîπÂñÑ
    
    v1.5.2 (2024-12-26) - ÂÆåÊàêÁâà
    - Ë®àÁÆóÁµêÊûú„ÅÆÂ∞èÊï∞ÁÇπ‰ª•‰∏ã„ÇíÂàá„ÇäÊç®„Å¶„Å´Â§âÊõ¥
    - „Åô„Åπ„Å¶„ÅÆÊ©üËÉΩ„ÅåÂÆåÊàê
    
    v1.5.1 (2024-12-26)
    - ‰ΩúÂõ≥ÁµÇ‰∫ÜÂæå„ÅÆÊàª„Çã„Éú„Çø„É≥„Åß‰ΩúÂõ≥ÂÜçÈñã„Åß„Åç„ÇãÊ©üËÉΩ„Çí‰øÆÊ≠£
    - ‰ΩúÂõ≥Áî®„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíÊ≠£„Åó„ÅèÂÜçË®≠ÂÆö
    - Ë®àÁÆóÁµêÊûú„ÅÆË∫Ø‰ΩìÂπÖË°®Á§∫„Å´ËÉåÊôØ„ÇíËøΩÂä†ÔºàÈáç„Å™„ÇäÈò≤Ê≠¢Ôºâ
    
    v1.5.0 (2024-12-26)
    - ‰ΩúÂõ≥Âæå„ÄÅÁÇπ„ÉªÁ∑ö„ÇØ„É™„ÉÉ„ÇØ„ÅßÂÖ•ÂäõÊ¨Ñ„Å´ÁßªÂãïÔºàÁä∂ÊÖãÂ§âÊõ¥„Å™„ÅóÔºâ
    - Á∑ö„ÇØ„É™„ÉÉ„ÇØÊ©üËÉΩËøΩÂä†ÔºàÁÇπ„Åã„ÇâÁ∑öÂàÜ„Å∏„ÅÆË∑ùÈõ¢Ë®àÁÆóÔºâ
    - Ë®àÁÆóÁµêÊûú„ÅÆÂõ≥ÔºöÊúÄÂ∞èË°®Á§∫Èï∑„Åï200px„ÄÅ„ÉÜ„Ç≠„Çπ„Éà„ÇíÁ∑ö„ÅÆÂ§ñÂÅ¥„Å´ÈÖçÁΩÆ
    - „ÉÜ„Ç≠„Çπ„Éà„ÅÆÈáç„Å™„Çä„ÇíÂÆåÂÖ®„Å´Èò≤Ê≠¢ÔºàÂûÇÁõ¥ÊñπÂêë40px„Ç™„Éï„Çª„ÉÉ„ÉàÔºâ
    
    v1.4.0 (2024-12-26)
    - Ë®àÁÆóÁµêÊûú„ÅÆÂõ≥„ÅÆÊúÄÂ∞èË°®Á§∫Èï∑„Åï„Çí150px„Å´Â¢óÂä†ÔºàÊï∞Â≠ó„ÅÆÈáç„Å™„Çä„ÇíÈò≤Ê≠¢Ôºâ
    - ‰ΩúÂõ≥ÁµÇ‰∫ÜÂæå„Å´ÁÇπ„ÇØ„É™„ÉÉ„ÇØ„ÅßÁä∂ÊÖãÂ§âÊõ¥„Åß„Åç„ÇãÊ©üËÉΩ„Çí‰øÆÊ≠£
    - ÂßãÁÇπ„ÇØ„É™„ÉÉ„ÇØ„ÅßÂõ≥ÂΩ¢„ÇíÈñâ„Åò„ÇãÊ©üËÉΩ„Çí‰øÆÊ≠£Ôºà„Çπ„Éä„ÉÉ„ÉóÂá¶ÁêÜÂæå„Å´Âà§ÂÆöÔºâ
    - PC: 30px‰ª•ÂÜÖ„ÄÅ„Çø„ÉÉ„ÉÅ: 40px‰ª•ÂÜÖ„ÅßÂßãÁÇπ„Å®„Åó„Å¶Ë™çË≠ò
    
    v1.3.1 (2024-12-26)
    - Ë®àÁÆóÁµêÊûú„ÅÆÂõ≥„Åß„Ç≥„Éº„Éä„ÉºÁÇπ„ÅåË°®Á§∫„Åï„Çå„Å™„ÅÑÂïèÈ°å„Çí‰øÆÊ≠£
    - ÁÇπ„ÇØ„É™„ÉÉ„ÇØÊôÇ„ÅÆÂÖ•ÂäõÊ¨Ñ„Çπ„ÇØ„É≠„Éº„É´Ê©üËÉΩ„Çí‰øÆÊ≠£ÔºàDOM„ÅÆÊõ¥Êñ∞„ÇíÂæÖ„Å§Ôºâ
    - ÂßãÁÇπ„ÇíÁõ¥Êé•„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶Âõ≥ÂΩ¢„ÇíÈñâ„Åò„ÇãÊ©üËÉΩ„Çí‰øÆÊ≠£
    
    v1.3.0 (2024-12-26)
    - ÁÇπ„ÇØ„É™„ÉÉ„ÇØ„ÅßÂÖ•ÂäõÊ¨Ñ„Å´„Çπ„ÇØ„É≠„Éº„É´&„Éè„Ç§„É©„Ç§„ÉàÊ©üËÉΩËøΩÂä†
    - Ë®àÁÆóÁµêÊûú„ÅÆÂõ≥„ÇíÂÆüÂØ∏Ê≥ïÊØîÁéá„ÅßË°®Á§∫ÔºàË¶ã„ÇÑ„Åô„ÅïÂÑ™ÂÖàÔºâ
    - ÊúÄÂ∞èË°®Á§∫Èï∑„Åï80px„ÅßÂØ∏Ê≥ï„ÅÆË¶ñË™çÊÄß„ÇíÁ¢∫‰øù
    
    v1.2.0 (2024-12-26)
    - ÂßãÁÇπ„ÅÆÂº∑Ë™øË°®Á§∫„Çµ„Ç§„Ç∫„ÇíË™øÊï¥
    - ÂßãÁÇπ„ÇíÁõ¥Êé•„ÇØ„É™„ÉÉ„ÇØ/„Çø„ÉÉ„Éó„ÅßÂõ≥ÂΩ¢„ÇíÈñâ„Åò„ÇãÊ©üËÉΩËøΩÂä†
    - ‰ΩúÂõ≥ÁµÇ‰∫ÜÂæå„Å´Êàª„Çã„Éú„Çø„É≥„Åß‰ΩúÂõ≥„ÇíÂÜçÈñã„Åß„Åç„ÇãÊ©üËÉΩËøΩÂä†
    - „Éë„Çø„Éº„É≥ÈÅ∏Êäû„Å´Êàª„Çã„Éú„Çø„É≥„ÇíÂ∏∏„Å´ÊúâÂäπÂåñ
    
    v1.1.0 (2024-12-26)
    - „Çπ„Éû„Éº„Éà„Ç¨„Ç§„Éâ„É©„Ç§„É≥ËøΩÂä†Ôºà„Ç§„É©„Çπ„Éà„É¨„Éº„Çø„ÉºÈ¢®Ôºâ
    - ÂßãÁÇπ„Å´Âêë„Åã„ÅÜ„Ç¨„Ç§„Éâ„É©„Ç§„É≥Ë°®Á§∫
    - „Ç¨„Ç§„Éâ„É©„Ç§„É≥ÂêàËá¥ÊôÇ„Å´ÂßãÁÇπ„ÇíÂº∑Ë™øË°®Á§∫
    - ÊÆµÂ∑ÆÂØ∏Ê≥ï„ÅÆÂÖ•Âäõ„ÉÅ„Çß„ÉÉ„ÇØËøΩÂä†
    
    v1.0.0 (2024-12-26)
    - ÂàùÂõû„É™„É™„Éº„Çπ
    - IÂ≠óÂûã„ÄÅLÂ≠óÂûã„ÄÅ„Ç≥„ÅÆÂ≠óÂûã„ÄÅËá™Áî±‰ΩúÂõ≥ÂØæÂøú
    - ÊÆµÂ∑ÆÊ©üËÉΩ„ÄÅ„Ç≥„Éº„Éä„ÉºË®àÁÆóÊ©üËÉΩ
    - ÂõõËßíÂΩ¢„ÅÆÈñâ„Åò„ÅüÂõ≥ÂΩ¢ÂØæÂøú
    ========================================
    -->
    <!-- jsPDF „É©„Ç§„Éñ„É©„É™ÔºàPDF‰øùÂ≠òÁî®Ôºâ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- html2canvas „É©„Ç§„Éñ„É©„É™Ôºà„Éö„Éº„Ç∏ÂÖ®‰Ωì„Ç≠„É£„Éó„ÉÅ„É£Áî®Ôºâ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, 'Hiragino Kaku Gothic ProN', sans-serif;
            background: #f5f7fa;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 700px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            padding: 40px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }
        
        h1 {
            text-align: center;
            color: #1a1a1a;
            margin-bottom: 40px;
            font-size: 28px;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        
        h2 {
            color: #1a1a1a;
            margin: 30px 0 20px;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            opacity: 0.6;
        }
        
        /* „Éë„Çø„Éº„É≥ÈÅ∏ÊäûÁîªÈù¢ */
        .pattern-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }
        
        .pattern-btn {
            background: white;
            color: #1a1a1a;
            border: 2px solid #e5e7eb;
            padding: 24px 16px;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            min-height: 110px;
        }
        
        .pattern-btn svg {
            width: 50px;
            height: 50px;
        }
        
        .pattern-btn:hover {
            border-color: #3b82f6;
            background: #f0f9ff;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.15);
        }
        
        .pattern-btn:active {
            transform: translateY(0);
        }
        
        .pattern-btn.custom {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
            grid-column: 1 / -1;
        }
        
        .pattern-btn.custom:hover {
            background: #2563eb;
            border-color: #2563eb;
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.25);
        }
        
        .pattern-btn .delete-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .pattern-btn .delete-btn:hover {
            background: #dc2626;
            transform: scale(1.1);
        }
        
        /* Êé°ÂØ∏ÁîªÈù¢ */
        .measurement-screen {
            display: none;
        }
        
        .back-btn {
            background: #f3f4f6;
            color: #1a1a1a;
            border: 1px solid #e5e7eb;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 20px;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        
        .back-btn:hover {
            background: #e5e7eb;
            border-color: #d1d5db;
        }
        
        .drawing-area {
            position: relative;
            width: 100%;
            height: 400px;
            background: #f9fafb;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            margin: 20px 0;
            overflow: hidden;
            touch-action: none;
        }
        
        canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }
        
        .dimension-inputs {
            margin: 20px 0;
        }
        
        .dimension-item {
            background: #f9fafb;
            padding: 16px;
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            margin-bottom: 12px;
        }
        
        .dimension-item label {
            display: block;
            color: #1a1a1a;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .dimension-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .dimension-row input {
            padding: 10px 12px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            font-size: 15px;
            transition: all 0.2s ease;
        }
        
        .dimension-row input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        .results {
            background: #f9fafb;
            padding: 20px;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            margin-top: 20px;
        }
        
        .result-item {
            padding: 12px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .result-label {
            color: #555;
            font-weight: bold;
        }
        
        .result-value {
            color: #667eea;
            font-weight: bold;
            font-size: 18px;
        }
        
        .save-pattern-btn {
            width: 100%;
            background: #10b981;
            color: white;
            border: none;
            padding: 14px;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.2s ease;
        }
        
        .save-pattern-btn:hover {
            background: #059669;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.25);
        }
        
        .alert {
            background: #fff3cd;
            color: #856404;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #ffc107;
        }
        
        .success {
            background: #d4edda;
            color: #155724;
            border-left-color: #28a745;
        }
        
        /* „Éû„Éã„É•„Ç¢„É´„É¢„Éº„ÉÄ„É´ */
        .manual-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            overflow-y: auto;
        }
        
        .manual-content {
            background: white;
            max-width: 800px;
            margin: 20px auto;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        
        .manual-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #ef4444;
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .manual-close:hover {
            background: #dc2626;
            transform: scale(1.1);
        }
        
        .manual-content h1 {
            color: #1e40af;
            border-bottom: 3px solid #3b82f6;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        
        .manual-content h2 {
            color: #2563eb;
            margin-top: 30px;
            margin-bottom: 15px;
        }
        
        .manual-content h3 {
            color: #3b82f6;
            margin-top: 20px;
            margin-bottom: 10px;
        }
        
        .manual-content pre {
            background: #f3f4f6;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            border-left: 4px solid #3b82f6;
        }
        
        .manual-content ul, .manual-content ol {
            padding-left: 25px;
            line-height: 1.8;
        }
        
        .manual-content li {
            margin-bottom: 8px;
        }
        
        .manual-content strong {
            color: #1e40af;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- „Éë„Çø„Éº„É≥ÈÅ∏ÊäûÁîªÈù¢ -->
        <div id="pattern-select-screen">
            <h1>Ë∫Ø‰ΩìÊé°ÂØ∏„Ç∑„Çπ„ÉÜ„É†</h1>
            
            <!-- ‰Ωø„ÅÑÊñπ„Éú„Çø„É≥ -->
            <div style="margin-bottom: 20px; text-align: center;">
                <button onclick="openManual()" 
                   style="display: inline-block; padding: 10px 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; font-weight: bold; font-size: 14px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); cursor: pointer;">
                    ‚ùì ‰Ωø„ÅÑÊñπ
                </button>
            </div>
            
            <h2>Âü∫Êú¨„Éë„Çø„Éº„É≥</h2>
            <div class="pattern-grid">
                <button class="pattern-btn" onclick="selectPattern('i')">
                    <svg viewBox="0 0 60 60">
                        <line x1="10" y1="30" x2="50" y2="30" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                    </svg>
                    IÂ≠ó
                </button>
                <button class="pattern-btn" onclick="selectPattern('l-left')">
                    <svg viewBox="0 0 60 60">
                        <line x1="15" y1="10" x2="15" y2="50" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                        <line x1="15" y1="10" x2="45" y2="10" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                    </svg>
                    Â∑¶LÂ≠ó
                </button>
                <button class="pattern-btn" onclick="selectPattern('l-right')">
                    <svg viewBox="0 0 60 60">
                        <line x1="45" y1="10" x2="45" y2="50" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                        <line x1="15" y1="10" x2="45" y2="10" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                    </svg>
                    Âè≥LÂ≠ó
                </button>
                <button class="pattern-btn" onclick="selectPattern('u')">
                    <svg viewBox="0 0 60 60">
                        <line x1="15" y1="50" x2="15" y2="10" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                        <line x1="15" y1="10" x2="45" y2="10" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                        <line x1="45" y1="10" x2="45" y2="50" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                    </svg>
                    „Ç≥„ÅÆÂ≠ó
                </button>
            </div>
            
            <div id="saved-patterns-section" style="display: none;">
                <h2>‰øùÂ≠òÊ∏à„Åø„Éë„Çø„Éº„É≥</h2>
                <div class="pattern-grid" id="saved-patterns-grid"></div>
            </div>
            
            <h2>„Ç´„Çπ„Çø„É†‰ΩúÂõ≥</h2>
            <div class="pattern-grid">
                <button class="pattern-btn custom" onclick="selectPattern('custom')">Ëá™Áî±„Å´Á∑ö„ÇíÂºï„Åè</button>
            </div>
            
            <!-- „Éê„Éº„Ç∏„Éß„É≥ÊÉÖÂ†± -->
            <div style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #e5e7eb; text-align: center; color: #6b7280; font-size: 13px;">
                <div style="margin-bottom: 5px;">Ë∫Ø‰ΩìÊé°ÂØ∏„Ç∑„Çπ„ÉÜ„É† v1.11.1</div>
                <div>ÊúÄÁµÇÊõ¥Êñ∞: 2024-12-27</div>
            </div>
        </div>
        
        <!-- Êé°ÂØ∏ÁîªÈù¢ -->
        <div id="measurement-screen" class="measurement-screen">
            <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                <button id="back-btn" class="back-btn" onclick="backToSelect()" style="flex: 2;">‚Üê „Éë„Çø„Éº„É≥ÈÅ∏Êäû„Å´Êàª„Çã</button>
                <button onclick="openManual()" 
                   style="flex: 1; display: flex; align-items: center; justify-content: center; padding: 12px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; font-weight: bold; font-size: 14px; cursor: pointer;">
                    ‚ùì ‰Ωø„ÅÑÊñπ
                </button>
            </div>
            
            <h1 id="pattern-title">Êé°ÂØ∏ÂÖ•Âäõ</h1>
            
            <div id="alert" class="alert" style="display: none;"></div>
            
            <div class="drawing-area">
                <canvas id="canvas"></canvas>
            </div>
            
            <div id="drawing-controls" style="display: none; margin-top: 10px; display: flex; gap: 10px; flex-wrap: wrap;">
                <button onclick="clearDrawing()" style="flex: 1; min-width: 120px; padding: 12px; background: #ef4444; color: white; border: none; border-radius: 8px; font-size: 15px; font-weight: 600; cursor: pointer; transition: all 0.2s ease;">üóëÔ∏è „ÇØ„É™„Ç¢</button>
                <button onclick="undoLastLine()" style="flex: 1; min-width: 120px; padding: 12px; background: #f59e0b; color: white; border: none; border-radius: 8px; font-size: 15px; font-weight: 600; cursor: pointer; transition: all 0.2s ease;">‚Ü∂ Êàª„Çã</button>
                <button onclick="finishDrawing()" style="flex: 1; min-width: 120px; padding: 12px; background: #10b981; color: white; border: none; border-radius: 8px; font-size: 15px; font-weight: 600; cursor: pointer; transition: all 0.2s ease;">‚úì ‰ΩúÂõ≥ÁµÇ‰∫Ü</button>
            </div>
            
            <div class="dimension-inputs" id="dimension-inputs"></div>
            
            <div class="results">
                <h2>Ë®àÁÆóÁµêÊûú</h2>
                <div id="results-content">
                    <p style="color: #999; text-align: center;">ÂØ∏Ê≥ï„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ</p>
                </div>
            </div>
            
            <button class="save-pattern-btn" onclick="savePattern()">„Åì„ÅÆ„Éë„Çø„Éº„É≥„Çí‰øùÂ≠ò</button>
        </div>
    </div>
    
    <script>
        let currentPattern = null;
        let lines = [];
        let dimensions = {};
        let isDrawing = false;
        let isDragging = false;
        let startPoint = null;
        let canvas, ctx;
        let drawingPoints = [];
        let lastClickTime = 0;
        let lastTapTime = 0;
        let commonWidth = null; // Ë∫Ø‰ΩìÂπÖ
        let useIndividualWidth = false; // ÂÄãÂà•Ë®≠ÂÆö„Éï„É©„Ç∞
        let commonHeight = null; // Ë∫Ø‰ΩìÈ´ò„Åï
        let corners = {}; // „Ç≥„Éº„Éä„ÉºÊÉÖÂ†± { 'x,y': { hasStep: bool, depth: number, lines: [...] } }
        
        // „Ç≥„Éº„Éä„Éº„ÇíÊ§úÂá∫
        function detectCorners() {
            if (!corners) {
                corners = {};
            }
            
            if (!lines || lines.length === 0) {
                corners = {};
                return;
            }
            
            const newCorners = {};
            const tolerance = 5; // Âêå„ÅòÁÇπ„Å®„Åø„Å™„ÅôË®±ÂÆπÁØÑÂõ≤
            
            lines.forEach((line, idx) => {
                if (!line) return;
                
                // ÂßãÁÇπ
                const startKey = findCornerKeyForDetection(line.x1, line.y1, tolerance, newCorners);
                if (!newCorners[startKey]) {
                    // Êó¢Â≠ò„ÅÆ„Ç≥„Éº„Éä„ÉºÊÉÖÂ†±„Çí‰øùÊåÅ
                    const oldCorner = corners[startKey];
                    newCorners[startKey] = { 
                        x: line.x1, 
                        y: line.y1, 
                        hasStep: oldCorner ? oldCorner.hasStep : false, 
                        depth: oldCorner ? oldCorner.depth : null, 
                        lines: [] 
                    };
                }
                newCorners[startKey].lines.push({ lineId: line.id, point: 'start' });
                
                // ÁµÇÁÇπ
                const endKey = findCornerKeyForDetection(line.x2, line.y2, tolerance, newCorners);
                if (!newCorners[endKey]) {
                    // Êó¢Â≠ò„ÅÆ„Ç≥„Éº„Éä„ÉºÊÉÖÂ†±„Çí‰øùÊåÅ
                    const oldCorner = corners[endKey];
                    newCorners[endKey] = { 
                        x: line.x2, 
                        y: line.y2, 
                        hasStep: oldCorner ? oldCorner.hasStep : false, 
                        depth: oldCorner ? oldCorner.depth : null, 
                        lines: [] 
                    };
                }
                newCorners[endKey].lines.push({ lineId: line.id, point: 'end' });
            });
            
            corners = newCorners;
        }
        
        // „Ç≥„Éº„Éä„Éº„Ç≠„Éº„ÇíÊ§úÁ¥¢ÔºàÊ§úÂá∫Áî® - Êñ∞„Åó„ÅÑcorners„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÂèÇÁÖßÔºâ
        function findCornerKeyForDetection(x, y, tolerance, cornersObj) {
            for (const key in cornersObj) {
                const corner = cornersObj[key];
                const dist = Math.sqrt(Math.pow(x - corner.x, 2) + Math.pow(y - corner.y, 2));
                if (dist < tolerance) {
                    return key;
                }
            }
            // Êñ∞„Åó„ÅÑ„Ç≠„Éº„ÇíÁîüÊàê
            return `${Math.round(x)},${Math.round(y)}`;
        }
        
        // „Ç≥„Éº„Éä„Éº„Ç≠„Éº„ÇíÊ§úÁ¥¢ÔºàÊó¢Â≠ò„ÅÆcorners„Åã„ÇâÊ§úÁ¥¢Ôºâ
        function findCornerKey(x, y, tolerance) {
            if (!corners) return `${Math.round(x)},${Math.round(y)}`;
            
            for (const key in corners) {
                const corner = corners[key];
                const dist = Math.sqrt(Math.pow(x - corner.x, 2) + Math.pow(y - corner.y, 2));
                if (dist < tolerance) {
                    return key;
                }
            }
            // Êñ∞„Åó„ÅÑ„Ç≠„Éº„ÇíÁîüÊàê
            return `${Math.round(x)},${Math.round(y)}`;
        }
        
        
        // „Éö„Éº„Ç∏Ë™≠„ÅøËæº„ÅøÊôÇ
        window.onload = function() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            resizeCanvas();
            
            loadSavedPatterns();
        };
        
        // Canvas „É™„Çµ„Ç§„Ç∫
        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            if (lines.length > 0) {
                drawLines();
            }
        }
        
        // „Éë„Çø„Éº„É≥ÈÅ∏Êäû
        function selectPattern(type) {
            currentPattern = type;
            document.getElementById('pattern-select-screen').style.display = 'none';
            document.getElementById('measurement-screen').style.display = 'block';
            
            // Canvas„Çí„É™„Çµ„Ç§„Ç∫
            setTimeout(resizeCanvas, 100);
            
            lines = [];
            dimensions = {};
            drawingPoints = [];
            commonWidth = null;
            commonHeight = null;
            useIndividualWidth = false;
            
            if (type === 'i') {
                document.getElementById('pattern-title').textContent = 'IÂ≠óÂûã Êé°ÂØ∏';
                createIPattern();
            } else if (type === 'l-left') {
                document.getElementById('pattern-title').textContent = 'Â∑¶LÂ≠óÂûã Êé°ÂØ∏';
                createLPatternLeft();
            } else if (type === 'l-right') {
                document.getElementById('pattern-title').textContent = 'Âè≥LÂ≠óÂûã Êé°ÂØ∏';
                createLPatternRight();
            } else if (type === 'u') {
                document.getElementById('pattern-title').textContent = '„Ç≥„ÅÆÂ≠óÂûã Êé°ÂØ∏';
                createUPattern();
            } else if (type === 'custom') {
                document.getElementById('pattern-title').textContent = 'Ëá™Áî±‰ΩúÂõ≥';
                setupCustomDrawing();
            } else {
                // ‰øùÂ≠òÊ∏à„Åø„Éë„Çø„Éº„É≥„ÅÆË™≠„ÅøËæº„Åø
                loadCustomPattern(type);
            }
        }
        
        // IÂ≠ó„Éë„Çø„Éº„É≥
        function createIPattern() {
            // „Ç≠„É£„É≥„Éê„Çπ„ÅÆ‰∏≠Â§Æ„Å´ÈÖçÁΩÆ
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const lineLength = Math.min(canvas.width, canvas.height) * 0.6; // „Ç≠„É£„É≥„Éê„Çπ„ÅÆ60%„ÅÆÈï∑„Åï
            
            lines = [
                { 
                    id: 'A', 
                    x1: centerX - lineLength/2, y1: centerY, 
                    x2: centerX + lineLength/2, y2: centerY, 
                    name: 'Ëæ∫A', 
                    start: 'wall', // „Éá„Éï„Ç©„É´„Éà„ÅØÂ£Å
                    end: 'wall'
                }
            ];
            drawLines();
            createInputs();
            setupPointClickListener();
        }
        
        // Â∑¶LÂ≠ó„Éë„Çø„Éº„É≥Ôºà‚îåÂûãÔºâ
        function createLPatternLeft() {
            // „Ç≠„É£„É≥„Éê„Çπ„Çµ„Ç§„Ç∫„Å´Âøú„Åò„Å¶ÈÖçÁΩÆ
            const size = Math.min(canvas.width, canvas.height) * 0.5;
            const margin = Math.min(canvas.width, canvas.height) * 0.2;
            
            lines = [
                { 
                    id: 'A', 
                    x1: margin, y1: margin, 
                    x2: margin, y2: margin + size, 
                    name: 'Ëæ∫AÔºàÁ∏¶Ôºâ', 
                    start: 'corner',  // „Ç≥„Éº„Éä„ÉºÔºàËæ∫B„Å®Êé•Á∂öÔºâ
                    end: 'wall'  // Â£Å
                },
                { 
                    id: 'B', 
                    x1: margin, y1: margin, 
                    x2: margin + size, y2: margin, 
                    name: 'Ëæ∫BÔºàÊ®™Ôºâ', 
                    start: 'corner',  // „Ç≥„Éº„Éä„ÉºÔºàËæ∫A„Å®Êé•Á∂öÔºâ
                    end: 'wall'  // Â£Å
                }
            ];
            drawLines();
            createInputs();
            setupPointClickListener();
        }
        
        // Âè≥LÂ≠ó„Éë„Çø„Éº„É≥Ôºà‚îêÂûãÔºâ
        function createLPatternRight() {
            // „Ç≠„É£„É≥„Éê„Çπ„Çµ„Ç§„Ç∫„Å´Âøú„Åò„Å¶ÈÖçÁΩÆ
            const size = Math.min(canvas.width, canvas.height) * 0.5;
            const margin = Math.min(canvas.width, canvas.height) * 0.2;
            
            lines = [
                { 
                    id: 'A', 
                    x1: margin, y1: margin, 
                    x2: margin + size, y2: margin, 
                    name: 'Ëæ∫AÔºàÊ®™Ôºâ', 
                    start: 'wall',  // „Ç®„É≥„Éâ„ÅØÂ£Å
                    end: 'corner'
                },
                { 
                    id: 'B', 
                    x1: margin + size, y1: margin, 
                    x2: margin + size, y2: margin + size, 
                    name: 'Ëæ∫BÔºàÁ∏¶Ôºâ', 
                    start: 'corner',
                    end: 'wall'  // „Ç®„É≥„Éâ„ÅØÂ£Å
                }
            ];
            drawLines();
            createInputs();
            setupPointClickListener();
        }
        
        // „Ç≥„ÅÆÂ≠ó„Éë„Çø„Éº„É≥
        function createUPattern() {
            // „Ç≠„É£„É≥„Éê„Çπ„Çµ„Ç§„Ç∫„Å´Âøú„Åò„Å¶ÈÖçÁΩÆ
            const width = Math.min(canvas.width, canvas.height) * 0.5;
            const height = Math.min(canvas.width, canvas.height) * 0.4;
            const margin = Math.min(canvas.width, canvas.height) * 0.2;
            
            lines = [
                { 
                    id: 'A', 
                    x1: margin, y1: margin + height, 
                    x2: margin, y2: margin, 
                    name: 'Ëæ∫A', 
                    start: 'wall',  // „Ç®„É≥„Éâ„ÅØÂ£Å
                    end: 'corner'
                },
                { 
                    id: 'B', 
                    x1: margin, y1: margin, 
                    x2: margin + width, y2: margin, 
                    name: 'Ëæ∫B', 
                    start: 'corner',
                    end: 'corner'
                },
                { 
                    id: 'C', 
                    x1: margin + width, y1: margin, 
                    x2: margin + width, y2: margin + height, 
                    name: 'Ëæ∫C', 
                    start: 'corner',
                    end: 'wall'  // „Ç®„É≥„Éâ„ÅØÂ£Å
                }
            ];
            drawLines();
            createInputs();
            setupPointClickListener();
        }
        
        // ÁÇπ„ÇØ„É™„ÉÉ„ÇØ„É™„Çπ„Éä„Éº„ÅÆ„Çª„ÉÉ„Éà„Ç¢„ÉÉ„Éó
        function setupPointClickListener() {
            // Êó¢Â≠ò„ÅÆ„É™„Çπ„Éä„Éº„ÇíÂâäÈô§ÔºàÈáçË§áÈò≤Ê≠¢Ôºâ
            canvas.removeEventListener('click', handlePointClick);
            canvas.removeEventListener('touchend', handlePointClickTouch);
            
            // Êñ∞„Åó„ÅÑ„É™„Çπ„Éä„Éº„ÇíËøΩÂä†
            canvas.addEventListener('click', handlePointClick);
            canvas.addEventListener('touchend', handlePointClickTouch);
        }
        
        // „Çø„ÉÉ„ÉÅ„ÅßÁÇπ„ÅÆÁä∂ÊÖã„ÇíÂàá„ÇäÊõø„Åà
        function handlePointClickTouch(e) {
            if (isDrawing || isDragging) return;
            if (drawingPoints.length > 0) return;
            
            e.preventDefault();
            const touch = e.changedTouches[0];
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (touch.clientX - rect.left) * scaleX;
            const y = (touch.clientY - rect.top) * scaleY;
            
            const clickRadius = 25;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                const distStart = Math.sqrt(Math.pow(x - line.x1, 2) + Math.pow(y - line.y1, 2));
                if (distStart < clickRadius) {
                    // ÂÖ•ÂäõÊ¨Ñ„Å´„Çπ„ÇØ„É≠„Éº„É´&„Éè„Ç§„É©„Ç§„Éà„ÅÆ„ÅøÔºàÁä∂ÊÖãÂ§âÊõ¥„Åó„Å™„ÅÑÔºâ
                    scrollToInput(line.id);
                    return;
                }
                
                const distEnd = Math.sqrt(Math.pow(x - line.x2, 2) + Math.pow(y - line.y2, 2));
                if (distEnd < clickRadius) {
                    // ÂÖ•ÂäõÊ¨Ñ„Å´„Çπ„ÇØ„É≠„Éº„É´&„Éè„Ç§„É©„Ç§„Éà„ÅÆ„ÅøÔºàÁä∂ÊÖãÂ§âÊõ¥„Åó„Å™„ÅÑÔºâ
                    scrollToInput(line.id);
                    return;
                }
                
                // Á∑ö„Çí„Çø„ÉÉ„Éó„Åó„Åü„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                const distToLine = distanceToLineSegment(x, y, line.x1, line.y1, line.x2, line.y2);
                if (distToLine < 15) {
                    // ÂÖ•ÂäõÊ¨Ñ„Å´„Çπ„ÇØ„É≠„Éº„É´&„Éè„Ç§„É©„Ç§„Éà
                    scrollToInput(line.id);
                    return;
                }
            }
        }
        
        // Á∑ö„ÇíÊèèÁîª
        function drawLines() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // „Ç≥„Éº„Éä„Éº„ÇíÊ§úÂá∫
            detectCorners();
            
            if (lines.length === 0) return;
            
            // Âü∫Êú¨„Éë„Çø„Éº„É≥„ÅÆ„ÅøÂ∫ßÊ®ôÂ§âÊèõ„ÇíÈÅ©Áî®ÔºàËá™Áî±‰ΩúÂõ≥„ÅØÂÖÉ„ÅÆ„Åæ„ÅæÔºâ
            const shouldTransform = currentPattern !== 'custom';
            
            let transform = (x, y) => ({ x, y }); // „Éá„Éï„Ç©„É´„Éà„ÅØÂ§âÊèõ„Å™„Åó
            
            if (shouldTransform) {
                // ÂÖ®„Å¶„ÅÆÁÇπ„Åã„ÇâÂ¢ÉÁïå„Éú„ÉÉ„ÇØ„Çπ„ÇíË®àÁÆó
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                lines.forEach(line => {
                    minX = Math.min(minX, line.x1, line.x2);
                    minY = Math.min(minY, line.y1, line.y2);
                    maxX = Math.max(maxX, line.x1, line.x2);
                    maxY = Math.max(maxY, line.y1, line.y2);
                });
                
                const shapeWidth = maxX - minX;
                const shapeHeight = maxY - minY;
                
                // „Éû„Éº„Ç∏„É≥
                const margin = 50;
                const canvasWidth = canvas.width - margin * 2;
                const canvasHeight = canvas.height - margin * 2;
                
                // „Çπ„Ç±„Éº„É´‰øÇÊï∞„ÇíË®àÁÆóÔºà„Ç¢„Çπ„Éö„ÇØ„ÉàÊØî„ÇíÁ∂≠ÊåÅÔºâ
                const scaleX = canvasWidth / shapeWidth;
                const scaleY = canvasHeight / shapeHeight;
                const scale = Math.min(scaleX, scaleY, 1); // ÊúÄÂ§ß1ÂÄçÔºàÊã°Â§ß„Åó„Å™„ÅÑÔºâ
                
                // „Ç™„Éï„Çª„ÉÉ„Éà„ÇíË®àÁÆóÔºà‰∏≠Â§ÆÈÖçÁΩÆÔºâ
                const scaledWidth = shapeWidth * scale;
                const scaledHeight = shapeHeight * scale;
                const offsetX = margin + (canvasWidth - scaledWidth) / 2 - minX * scale;
                const offsetY = margin + (canvasHeight - scaledHeight) / 2 - minY * scale;
                
                // Â∫ßÊ®ôÂ§âÊèõÈñ¢Êï∞„Çí‰∏äÊõ∏„Åç
                transform = (x, y) => ({
                    x: x * scale + offsetX,
                    y: y * scale + offsetY
                });
            }
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 5;
            ctx.lineCap = 'round';
            
            // Á∑ö„ÇíÊèèÁîª
            lines.forEach((line, index) => {
                const p1 = transform(line.x1, line.y1);
                const p2 = transform(line.x2, line.y2);
                
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
                
                // „É©„Éô„É´‰ΩçÁΩÆË®àÁÆó
                const midX = (p1.x + p2.x) / 2;
                const midY = (p1.y + p2.y) / 2;
                
                // ÂÖ•Âäõ„Åï„Çå„ÅüÂ§ñÊ≥ïÂØ∏Ê≥ï„ÇíË°®Á§∫
                const dim = dimensions[line.id];
                if (dim && dim.length) {
                    ctx.font = 'bold 18px sans-serif';
                    ctx.fillStyle = '#3b82f6';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // ËÉåÊôØ„ÇíÁôΩ„Åè
                    const text = `${dim.length}`;
                    const metrics = ctx.measureText(text);
                    const padding = 8;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.fillRect(midX - metrics.width/2 - padding, midY - 12, metrics.width + padding*2, 24);
                    
                    // ÊñáÂ≠ó„ÇíÊèèÁîª
                    ctx.fillStyle = '#3b82f6';
                    ctx.fillText(text, midX, midY);
                }
                
                // Ëæ∫Âêç„É©„Éô„É´
                ctx.font = 'bold 13px sans-serif';
                const textWidth = ctx.measureText(line.name).width;
                const padding = 8;
                const bgWidth = textWidth + padding * 2;
                const bgHeight = 20;
                
                // ËÉåÊôØ
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.fillRect(midX - bgWidth/2, midY - bgHeight/2 - 35, bgWidth, bgHeight);
                
                // ÊñáÂ≠ó
                ctx.fillStyle = '#333';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(line.name, midX, midY - 35);
            });
            
            // Êó¢„Å´ÊèèÁîª„Åó„Åü„Ç≥„Éº„Éä„Éº„ÇíË®òÈå≤
            const drawnCorners = new Set();
            
            // „Ç≥„Éº„Éä„Éº„Éô„Éº„Çπ„ÅßÁÇπ„ÇíÊèèÁîª
            if (corners) {
                for (const cornerKey in corners) {
                    const corner = corners[cornerKey];
                    
                    if (!corner || drawnCorners.has(cornerKey)) continue;
                    drawnCorners.add(cornerKey);
                    
                    // „Åì„ÅÆ„Ç≥„Éº„Éä„Éº„Å´Êé•Á∂ö„Åó„Å¶„ÅÑ„ÇãËæ∫„ÇíÂèñÂæó
                    if (!corner.lines || corner.lines.length === 0) continue;
                    
                    // „Ç≥„Éº„Éä„Éº„ÅÆÂ∫ßÊ®ô„ÇíÂèñÂæó
                    const firstLineRef = corner.lines[0];
                    const firstLine = lines.find(l => l.id === firstLineRef.lineId);
                    if (!firstLine) continue;
                    
                    const cornerX = corner.x !== undefined ? corner.x : (firstLine[firstLineRef.point === 'start' ? 'x1' : 'x2']);
                    const cornerY = corner.y !== undefined ? corner.y : (firstLine[firstLineRef.point === 'start' ? 'y1' : 'y2']);
                    
                    // ÊÆµÂ∑Æ„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ2„Å§„ÅÆÁÇπ„ÄÅ„Å™„ÅÑÂ†¥Âêà„ÅØ1„Å§„ÅÆÁÇπ
                    if (corner.hasStep && corner.lines.length >= 2) {
                        // 2„Å§„ÅÆËæ∫„Åã„ÇâÁä∂ÊÖã„ÇíÂèñÂæó
                        const line1Ref = corner.lines[0];
                        const line2Ref = corner.lines[1];
                        const line1 = lines.find(l => l.id === line1Ref.lineId);
                        const line2 = lines.find(l => l.id === line2Ref.lineId);
                        
                        if (line1 && line2) {
                            const state1 = line1[line1Ref.point] || 'wall';
                            const state2 = line2[line2Ref.point] || 'wall';
                            
                            const offset = 20; // Ëßí„Åã„Çâ„ÅÆ„Åö„Çâ„ÅóË∑ùÈõ¢
                            
                            // line1„ÅÆÊñπÂêë„Éô„ÇØ„Éà„É´„ÇíË®àÁÆóÔºàËßí„Åã„ÇâÁ∑ö„Å´Ê≤ø„Å£„Å¶ÈÄ≤„ÇÄÊñπÂêëÔºâ
                            let dx1, dy1;
                            if (line1Ref.point === 'start') {
                                dx1 = line1.x2 - line1.x1;
                                dy1 = line1.y2 - line1.y1;
                            } else {
                                dx1 = line1.x1 - line1.x2;
                                dy1 = line1.y1 - line1.y2;
                            }
                            const len1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
                            
                            // line2„ÅÆÊñπÂêë„Éô„ÇØ„Éà„É´„ÇíË®àÁÆóÔºàËßí„Åã„ÇâÁ∑ö„Å´Ê≤ø„Å£„Å¶ÈÄ≤„ÇÄÊñπÂêëÔºâ
                            let dx2, dy2;
                            if (line2Ref.point === 'start') {
                                dx2 = line2.x2 - line2.x1;
                                dy2 = line2.y2 - line2.y1;
                            } else {
                                dx2 = line2.x1 - line2.x2;
                                dy2 = line2.y1 - line2.y2;
                            }
                            const len2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                            
                            if (len1 > 0 && len2 > 0) {
                                // Ê≠£Ë¶èÂåñ„Åï„Çå„ÅüÊñπÂêë„Éô„ÇØ„Éà„É´
                                const dirX1 = dx1 / len1;
                                const dirY1 = dy1 / len1;
                                const dirX2 = dx2 / len2;
                                const dirY2 = dy2 / len2;
                                
                                // ÂêÑÁ∑ö„ÅÆÊñπÂêë„Å´Ê≤ø„Å£„Å¶Ëßí„Åã„Çâ„Åö„Çâ„Åó„Åü‰ΩçÁΩÆ„Å´ÁÇπ„ÇíÈÖçÁΩÆ
                                const p1 = transform(cornerX + dirX1 * offset, cornerY + dirY1 * offset);
                                const p2 = transform(cornerX + dirX2 * offset, cornerY + dirY2 * offset);
                                
                                drawPoint(p1.x, p1.y, state1);
                                drawPoint(p2.x, p2.y, state2);
                            } else {
                                // ÊñπÂêë„ÅåÂÆö„Åæ„Çâ„Å™„ÅÑÂ†¥Âêà„ÅØ1„Å§„Å†„Åë
                                const p = transform(cornerX, cornerY);
                                drawPoint(p.x, p.y, state1);
                            }
                        }
                    } else {
                        // ÊÆµÂ∑Æ„Å™„ÅóÔºö1„Å§„ÅÆÁÇπÔºàÂ∫ßÊ®ôÂ§âÊèõÈÅ©Áî®Ôºâ
                        const state = firstLine[firstLineRef.point] || 'wall';
                        const p = transform(cornerX, cornerY);
                        drawPoint(p.x, p.y, state);
                    }
                }
            }
            
            // ÊèèÁîª‰∏≠„ÅÆ„Éù„Ç§„É≥„Éà„ÇíË°®Á§∫
            drawingPoints.forEach((point, index) => {
                ctx.fillStyle = '#f39c12';
                ctx.beginPath();
                ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }
        
        // ÁÇπ„ÇíÊèèÁîª
        function drawPoint(x, y, state) {
            const colors = {
                'corner': '#e74c3c', // Ëµ§Ôºö„Ç≥„Éº„Éä„Éº
                'end': '#3498db',    // ÈùíÔºö„Ç®„É≥„Éâ
                'wall': '#2ecc71'    // Á∑ëÔºöÂ£Å
            };
            
            ctx.fillStyle = colors[state] || colors['end'];
            ctx.beginPath();
            ctx.arc(x, y, 10, 0, Math.PI * 2); // 8„Åã„Çâ10„Å´Â§âÊõ¥
            ctx.fill();
            
            // ÁôΩ„ÅÑÊû†
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3; // 2„Åã„Çâ3„Å´Â§âÊõ¥
            ctx.stroke();
        }
        
        // ÂÖ•Âäõ„Éï„Ç©„Éº„É†‰ΩúÊàê
        function createInputs() {
            const container = document.getElementById('dimension-inputs');
            container.innerHTML = '';
            
            // „Ç≥„Éº„Éä„Éº„ÇíÊ§úÂá∫
            detectCorners();
            
            // ÁÇπ„ÅÆË™¨Êòé
            const infoDiv = document.createElement('div');
            infoDiv.style.cssText = 'background: #e3f2fd; padding: 12px; border-radius: 8px; margin-bottom: 15px;';
            infoDiv.innerHTML = `
                <p style="margin: 0; color: #555; font-size: 14px; line-height: 1.6;">
                    <span style="color: #e74c3c; font-size: 16px;">‚óè</span> <strong>Ëµ§Ôºù„Ç≥„Éº„Éä„Éº</strong>ÔºàË∫Ø‰ΩìÂπÖ√∑2„ÇíÂºï„ÅèÔºâ„ÄÄ
                    <span style="color: #3498db; font-size: 16px;">‚óè</span> <strong>ÈùíÔºù„Ç®„É≥„Éâ</strong>ÔºàÂ£Å„Å™„ÅóÔºâ„ÄÄ
                    <span style="color: #2ecc71; font-size: 16px;">‚óè</span> <strong>Á∑ëÔºùÂ£Å</strong>ÔºàÂ£Å„ÅÇ„ÇäÔºâ
                </p>
            `;
            container.appendChild(infoDiv);
            
            // Ë∫Ø‰ΩìÂπÖ„ÉªÈ´ò„ÅïÂÖ•Âäõ
            const widthDiv = document.createElement('div');
            widthDiv.style.cssText = 'background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px;';
            widthDiv.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                    <div>
                        <label style="display: block; color: #555; font-weight: bold; margin-bottom: 8px;">Ë∫Ø‰ΩìÂπÖ (mm)</label>
                        <input type="number" id="common-width" placeholder="‰æã: 180" value="${commonWidth || ''}" 
                               oninput="updateCommonWidth(this.value)" 
                               style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px;">
                    </div>
                    <div>
                        <label style="display: block; color: #555; font-weight: bold; margin-bottom: 8px;">Ë∫Ø‰ΩìÈ´ò„Åï (mm)</label>
                        <input type="number" id="common-height" placeholder="‰æã: 1100" value="${commonHeight || ''}" 
                               oninput="updateCommonHeight(this.value)" 
                               style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px;">
                    </div>
                </div>
                <div>
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="individual-width-check" ${useIndividualWidth ? 'checked' : ''} 
                               onchange="toggleIndividualWidth(this.checked)"
                               style="width: 18px; height: 18px; margin-right: 8px; cursor: pointer;">
                        <span style="color: #555; font-size: 14px;">Ëæ∫„Åî„Å®„Å´Ë∫Ø‰ΩìÂπÖ„ÇíË®≠ÂÆö</span>
                    </label>
                </div>
            `;
            container.appendChild(widthDiv);
            
            // ÂêÑËæ∫„ÅÆÂÖ•Âäõ
            lines.forEach((line, lineIndex) => {
                const div = document.createElement('div');
                div.className = 'dimension-item';
                div.setAttribute('data-line-id', line.id);  // ID„ÇíËøΩÂä†
                
                // „Ç≥„Éº„Éä„Éº„ÅÆÊÆµÂ∑ÆÁä∂ÊÖã„ÇíÁ¢∫Ë™ç
                const startKey = findCornerKey(line.x1, line.y1, 5);
                const endKey = findCornerKey(line.x2, line.y2, 5);
                const startCorner = corners[startKey];
                const endCorner = corners[endKey];
                
                // ÊÆµÂ∑Æ„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅÆÁä∂ÊÖã„ÇíÂèñÂæó
                const startHasStep = startCorner && startCorner.hasStep;
                const endHasStep = endCorner && endCorner.hasStep;
                
                // ÁÇπ„ÅÆÁä∂ÊÖã„ÇíÂèñÂæó
                let startState = line.start || 'wall';
                let endState = line.end || 'wall';
                
                // Êñú„ÇÅÁ∑ö„Åã„Å©„ÅÜ„ÅãÂà§ÂÆö
                const isDiagonal = isLineDiagonal(line);
                const angle = isDiagonal ? getLineAngle(line).toFixed(1) : null;
                
                // ÂÄãÂà•Ë∫Ø‰ΩìÂπÖÂÖ•ÂäõÊ¨Ñ
                const widthInput = useIndividualWidth ? `
                    <input type="number" placeholder="Ë∫Ø‰ΩìÂπÖ (mm)" 
                           oninput="updateDimension('${line.id}', 'width', this.value)"
                           value="${dimensions[line.id]?.width || ''}"
                           style="padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 16px;">
                ` : '';
                
                // ËßíÂ∫¶ÂÖ•ÂäõÊ¨ÑÔºàÊñú„ÇÅÁ∑ö„ÅÆÂ†¥Âêà„ÅÆ„ÅøÔºâ
                const angleInput = isDiagonal ? `
                    <div style="margin-top: 10px; padding: 10px; background: #fff3cd; border-radius: 6px; border: 2px solid #ffc107;">
                        <label style="display: block; color: #856404; font-weight: bold; margin-bottom: 5px; font-size: 13px;">
                            ‚ö†Ô∏è Êñú„ÇÅÁ∑öÔºöËßíÂ∫¶ÔºàÂ∫¶Ôºâ
                        </label>
                        <input type="number" placeholder="ËßíÂ∫¶ (Â∫¶)" 
                               value="${angle || ''}"
                               oninput="updateLineAngle('${line.id}', this.value)"
                               style="width: 100%; padding: 10px; border: 2px solid #ffc107; border-radius: 6px; font-size: 16px;">
                        <p style="margin: 5px 0 0 0; font-size: 12px; color: #856404;">ÁèæÂú®„ÅÆËßíÂ∫¶: ${angle}¬∞</p>
                    </div>
                ` : '';
                
                // ÁÇπ„ÅÆÁä∂ÊÖã„Éú„Çø„É≥ÔºàÈÄöÂ∏∏Ôºâ
                const pointButtons = `
                    <div style="display: flex; gap: 8px;">
                        <button onclick="changePointState('${line.id}', 'start')" style="padding: 6px 12px; background: ${getStateColor(startState)}; color: white; border: none; border-radius: 6px; font-size: 12px; font-weight: bold; cursor: pointer;">
                            ÂßãÁÇπ: ${getStateLabel(startState)}
                        </button>
                        <button onclick="changePointState('${line.id}', 'end')" style="padding: 6px 12px; background: ${getStateColor(endState)}; color: white; border: none; border-radius: 6px; font-size: 12px; font-weight: bold; cursor: pointer;">
                            ÁµÇÁÇπ: ${getStateLabel(endState)}
                        </button>
                    </div>
                `;

                // Êñú„ÇÅ„Ç≥„Éº„Éä„Éº„ÅÆË≠¶Âëä„ÉÅ„Çß„ÉÉ„ÇØÔºàNEW - v1.12.0Ôºâ
                let diagonalCornerWarning = '';
                
                // ÂßãÁÇπ„ÅåÊñú„ÇÅ„Ç≥„Éº„Éä„Éº„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                if (startState === 'corner' || startState === 'end') {
                    const startKey = findCornerKey(line.x1, line.y1, 5);
                    const startCorner = corners[startKey];
                    if (startCorner && startCorner.lines && startCorner.lines.length >= 2) {
                        for (let ref of startCorner.lines) {
                            if (ref.lineId !== line.id) {
                                const adjacentLine = lines.find(l => l.id === ref.lineId);
                                if (adjacentLine && isDiagonalCorner(line, adjacentLine, 'start', ref.point)) {
                                    diagonalCornerWarning += `
                                        <div style="margin-top: 10px; padding: 12px; background: #fee; border: 2px solid #e74c3c; border-radius: 8px;">
                                            <p style="margin: 0; color: #c0392b; font-weight: bold; font-size: 14px;">
                                                ‚ö†Ô∏è ÂßãÁÇπ„ÅØÊñú„ÇÅ„Ç≥„Éº„Éä„Éº„Åß„Åô
                                            </p>
                                            <p style="margin: 5px 0 0 0; color: #c0392b; font-size: 13px;">
                                                Â§ñÊ≥ïÂØ∏Ê≥ï„Åã„ÇâËäØÂØ∏Ê≥ï„ÇíË®àÁÆó„Åß„Åç„Åæ„Åõ„Çì„ÄÇ<br>
                                                <strong>ÁèæÂú∞„ÅßËäØÂØ∏Ê≥ï„ÇíÁõ¥Êé•Ê∏¨ÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</strong>
                                            </p>
                                        </div>
                                    `;
                                    break;
                                }
                            }
                        }
                    }
                }
                
                // ÁµÇÁÇπ„ÅåÊñú„ÇÅ„Ç≥„Éº„Éä„Éº„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                if (endState === 'corner' || endState === 'end') {
                    const endKey = findCornerKey(line.x2, line.y2, 5);
                    const endCorner = corners[endKey];
                    if (endCorner && endCorner.lines && endCorner.lines.length >= 2) {
                        for (let ref of endCorner.lines) {
                            if (ref.lineId !== line.id) {
                                const adjacentLine = lines.find(l => l.id === ref.lineId);
                                if (adjacentLine && isDiagonalCorner(line, adjacentLine, 'end', ref.point)) {
                                    diagonalCornerWarning += `
                                        <div style="margin-top: 10px; padding: 12px; background: #fee; border: 2px solid #e74c3c; border-radius: 8px;">
                                            <p style="margin: 0; color: #c0392b; font-weight: bold; font-size: 14px;">
                                                ‚ö†Ô∏è ÁµÇÁÇπ„ÅØÊñú„ÇÅ„Ç≥„Éº„Éä„Éº„Åß„Åô
                                            </p>
                                            <p style="margin: 5px 0 0 0; color: #c0392b; font-size: 13px;">
                                                Â§ñÊ≥ïÂØ∏Ê≥ï„Åã„ÇâËäØÂØ∏Ê≥ï„ÇíË®àÁÆó„Åß„Åç„Åæ„Åõ„Çì„ÄÇ<br>
                                                <strong>ÁèæÂú∞„ÅßËäØÂØ∏Ê≥ï„ÇíÁõ¥Êé•Ê∏¨ÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</strong>
                                            </p>
                                        </div>
                                    `;
                                    break;
                                }
                            }
                        }
                    }
                }
                
                div.innerHTML = `
                    <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <span style="font-weight: bold; color: #667eea;">${line.name}${isDiagonal ? ' <span style="color: #ff9800;">‚ö†Ô∏èÊñú„ÇÅ</span>' : ''}</span>
                        ${pointButtons}
                    </label>
                    ${diagonalCornerWarning}
                    <div class="dimension-row" style="display: grid; grid-template-columns: ${useIndividualWidth ? '1fr 1fr' : '1fr'}; gap: 10px;">
                        <input type="number" placeholder="Â§ñÊ≥ïÂØ∏Ê≥ï (mm)" 
                               oninput="updateDimension('${line.id}', 'length', this.value)"
                               value="${dimensions[line.id]?.length || ''}"
                               style="padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 16px;">
                        ${widthInput}
                    </div>
                    ${angleInput}
                `;
                container.appendChild(div);
                
                if (!dimensions[line.id]) {
                    dimensions[line.id] = { length: null, width: null };
                }
                
                // „Åì„ÅÆËæ∫„ÅÆÁµÇÁÇπ„Åå„Ç≥„Éº„Éä„Éº„ÅÆÂ†¥Âêà„ÄÅÊÆµÂ∑ÆË®≠ÂÆö„ÇíËøΩÂä†
                if (endCorner && endCorner.lines.length >= 2 && lineIndex < lines.length - 1) {
                    const cornerDiv = document.createElement('div');
                    cornerDiv.style.cssText = 'margin: 10px 0 20px 0; padding: 12px; background: #e8f5e9; border-radius: 6px; border: 2px solid #4caf50;';
                    
                    const nextLine = lines[lineIndex + 1];
                    const cornerLabel = `${line.name}‚îÅ${nextLine.name}`;
                    
                    cornerDiv.innerHTML = `
                        <label style="display: flex; align-items: center; cursor: pointer; margin-bottom: 8px;">
                            <input type="checkbox" ${endCorner.hasStep ? 'checked' : ''} 
                                   onchange="toggleCornerStep('${endKey}', this.checked)"
                                   style="width: 18px; height: 18px; margin-right: 8px; cursor: pointer;">
                            <span style="color: #2e7d32; font-weight: bold; font-size: 14px;">üìê ${cornerLabel} „Å´ÊÆµÂ∑Æ„ÅÇ„Çä</span>
                        </label>
                        ${endCorner.hasStep ? `
                            <input type="number" placeholder="Ê∑±„Åï (mm)" 
                                   value="${endCorner.depth || ''}"
                                   oninput="updateCornerDepth('${endKey}', this.value)"
                                   style="width: 100%; padding: 8px; border: 2px solid #4caf50; border-radius: 6px; font-size: 14px;">
                        ` : ''}
                    `;
                    container.appendChild(cornerDiv);
                }
            });
        }
        
        // ËßíÂ∫¶„ÇíÊõ¥Êñ∞„Åó„Å¶Á∑ö„ÇíÂÜçË®àÁÆó
        function updateLineAngle(lineId, angleDegrees) {
            const lineIndex = lines.findIndex(line => line.id === lineId);
            if (lineIndex === -1) return;
            
            const line = lines[lineIndex];
            const angle = parseFloat(angleDegrees);
            if (isNaN(angle)) return;
            
            // Á∑ö„ÅÆÈï∑„Åï„ÇíË®àÁÆó
            const dx = line.x2 - line.x1;
            const dy = line.y2 - line.y1;
            const length = Math.sqrt(dx * dx + dy * dy);
            
            // Êñ∞„Åó„ÅÑËßíÂ∫¶„ÅßÁµÇÁÇπ„ÇíÂÜçË®àÁÆó
            const radians = angle * (Math.PI / 180);
            line.x2 = line.x1 + length * Math.cos(radians);
            line.y2 = line.y1 + length * Math.sin(radians);
            
            drawLines();
            createInputs();
        }
        
        // Ë∫Ø‰ΩìÂπÖ„ÇíÊõ¥Êñ∞
        function updateCommonWidth(value) {
            commonWidth = value ? parseFloat(value) : null;
            if (!useIndividualWidth) {
                // ÂÖ®„Å¶„ÅÆËæ∫„Å´ÈÅ©Áî®
                lines.forEach(line => {
                    if (dimensions[line.id]) {
                        dimensions[line.id].width = commonWidth;
                    }
                });
                drawLines();
                calculate();
            }
        }
        
        // Ë∫Ø‰ΩìÈ´ò„Åï„ÇíÊõ¥Êñ∞
        function updateCommonHeight(value) {
            commonHeight = value ? parseFloat(value) : null;
            drawLines();
            calculate();
        }
        
        // „Ç≥„Éº„Éä„Éº„ÅÆÊÆµÂ∑Æ„ÇíÂàá„ÇäÊõø„Åà
        function toggleCornerStep(cornerKey, hasStep) {
            if (!corners[cornerKey]) return;
            
            corners[cornerKey].hasStep = hasStep;
            const corner = corners[cornerKey];
            
            if (!hasStep) {
                // „ÉÅ„Çß„ÉÉ„ÇØ„ÇíÂ§ñ„Åó„ÅüÊôÇÔºö„Ç≥„Éº„Éä„Éº„Å´Êàª„Åô
                corners[cornerKey].depth = null;
                corner.lines.forEach(lineRef => {
                    const line = lines.find(l => l.id === lineRef.lineId);
                    if (line) {
                        line[lineRef.point] = 'corner';
                    }
                });
            } else {
                // ÊÆµÂ∑Æ„ÇíÊúâÂäπ„Å´„Åó„ÅüÂ†¥Âêà„ÄÅ1„Å§ÁõÆ„Çí„Ç®„É≥„Éâ„ÄÅÊÆã„Çä„ÇíÂ£Å„Å´
                corner.lines.forEach((lineRef, index) => {
                    const line = lines.find(l => l.id === lineRef.lineId);
                    if (line) {
                        if (index === 0) {
                            line[lineRef.point] = 'end';
                        } else {
                            line[lineRef.point] = 'wall';
                        }
                    }
                });
            }
            
            drawLines();
            createInputs();
        }
        
        // „Ç≥„Éº„Éä„Éº„ÅÆÊ∑±„Åï„ÇíÊõ¥Êñ∞
        function updateCornerDepth(cornerKey, depth) {
            if (!corners[cornerKey]) return;
            
            corners[cornerKey].depth = depth ? parseFloat(depth) : null;
        }
        
        // ÂÄãÂà•Ë®≠ÂÆö„ÅÆÂàá„ÇäÊõø„Åà
        function toggleIndividualWidth(checked) {
            useIndividualWidth = checked;
            if (!checked && commonWidth) {
                // ÂÄãÂà•‚ÜíÂÖ±ÈÄö„Å´Âàá„ÇäÊõø„ÅàÔºöÂÖ±ÈÄöÂÄ§„ÇíÂÖ®Ëæ∫„Å´ÈÅ©Áî®
                lines.forEach(line => {
                    if (dimensions[line.id]) {
                        dimensions[line.id].width = commonWidth;
                    }
                });
            }
            createInputs();
            drawLines();
            calculate();
        }
        
        // Áä∂ÊÖã„ÅÆËâ≤„ÇíÂèñÂæó
        function getStateColor(state) {
            const colors = {
                'corner': '#e74c3c',
                'end': '#3498db',
                'wall': '#2ecc71'
            };
            return colors[state] || colors['end'];
        }
        
        // Áä∂ÊÖã„ÅÆ„É©„Éô„É´„ÇíÂèñÂæó
        function getStateLabel(state) {
            const labels = {
                'corner': '„Ç≥„Éº„Éä„Éº',
                'end': '„Ç®„É≥„Éâ',
                'wall': 'Â£Å'
            };
            return labels[state] || labels['end'];
        }
        
        // „Éú„Çø„É≥„Åã„ÇâÁÇπ„ÅÆÁä∂ÊÖã„ÇíÂ§âÊõ¥
        function changePointState(lineId, point) {
            const lineIndex = lines.findIndex(line => line.id === lineId);
            if (lineIndex === -1) return;
            
            const line = lines[lineIndex];
            
            // „Åì„ÅÆÁÇπ„ÅÆ„Ç≥„Éº„Éä„Éº„Ç≠„Éº„ÇíÂèñÂæó
            const x = point === 'start' ? line.x1 : line.x2;
            const y = point === 'start' ? line.y1 : line.y2;
            const cornerKey = findCornerKey(x, y, 5);
            const corner = corners[cornerKey];
            
            // Âõ≥ÂΩ¢„ÅåÈñâ„Åò„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØÔºàÊúÄÂàù„ÅÆÁ∑ö„ÅÆÂßãÁÇπ„Å®ÊúÄÂæå„ÅÆÁ∑ö„ÅÆÁµÇÁÇπ„ÅåÂêå„Åò‰ΩçÁΩÆÔºâ
            const isClosed = lines.length > 0 && 
                Math.abs(lines[0].x1 - lines[lines.length - 1].x2) < 5 && 
                Math.abs(lines[0].y1 - lines[lines.length - 1].y2) < 5;
            
            // ÊúÄÂàù„ÅÆÁ∑ö„ÅÆÂßãÁÇπ„ÅØ„Ç≥„Éº„Éä„Éº„Å´„Å™„Çå„Å™„ÅÑÔºàÈñâ„Åò„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØÈô§„ÅèÔºâ
            const isFirstLineStart = (lineIndex === 0 && point === 'start' && !isClosed);
            
            // ÊúÄÂæå„ÅÆÁ∑ö„ÅÆÁµÇÁÇπ„ÅØ„Ç≥„Éº„Éä„Éº„Å´„Å™„Çå„Å™„ÅÑÔºàÈñâ„Åò„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØÈô§„ÅèÔºâ
            const isLastLineEnd = (lineIndex === lines.length - 1 && point === 'end' && !isClosed);
            
            // ÊÆµÂ∑Æ„Åå„ÅÇ„Çã„Ç≥„Éº„Éä„Éº„ÅÆÂ†¥Âêà„ÅØ„ÄÅ„Ç≥„Éº„Éä„ÉºÈÅ∏Êäû„ÇíÈô§Â§ñ
            const hasStepAtCorner = corner && corner.hasStep;
            
            // ÈÅ∏ÊäûÂèØËÉΩ„Å™Áä∂ÊÖã„ÇíÊ±∫ÂÆö
            let states;
            if (isFirstLineStart || isLastLineEnd || hasStepAtCorner) {
                states = ['end', 'wall'];
            } else {
                states = ['corner', 'end', 'wall'];
            }
            
            const currentState = lines[lineIndex][point] || 'wall';
            const currentIndex = states.indexOf(currentState);
            const nextIndex = (currentIndex + 1) % states.length;
            lines[lineIndex][point] = states[nextIndex];
            
            // „Ç≥„Éº„Éä„Éº„Å´Â§âÊõ¥„Åó„ÅüÂ†¥Âêà„ÄÅÂêå„Åò‰ΩçÁΩÆ„ÅÆÁÇπ„ÇÇÈÄ£Âãï
            if (lines[lineIndex][point] === 'corner') {
                autoSetCorners();
            }
            
            // ÊÆµÂ∑Æ„Åå„ÅÇ„Çã„Ç≥„Éº„Éä„Éº„ÅßÁä∂ÊÖã„ÇíÂ§âÊõ¥„Åó„ÅüÂ†¥Âêà„ÄÅÊé•Á∂ö„Åó„Å¶„ÅÑ„ÇãËæ∫„ÅÆÁä∂ÊÖã„ÇíËá™ÂãïË™øÊï¥
            if (corner && corner.hasStep && corner.lines.length >= 2) {
                syncCornerStatesWithStep(cornerKey, lineId, point, lines[lineIndex][point]);
            }
            
            // ÂÜçÊèèÁîª
            drawLines();
            createInputs(); // „Éú„Çø„É≥„ÅÆËâ≤„ÇíÊõ¥Êñ∞
            calculate();
        }
        
        // ÊÆµÂ∑Æ„Åå„ÅÇ„Çã„Ç≥„Éº„Éä„Éº„ÅÆÁä∂ÊÖã„ÇíÂêåÊúüÔºàÁâáÊñπ„Åå„Ç®„É≥„Éâ‚Üí„ÇÇ„ÅÜÁâáÊñπ„ÅØÂ£ÅÔºâ
        function syncCornerStatesWithStep(cornerKey, changedLineId, changedPoint, newState) {
            const corner = corners[cornerKey];
            if (!corner) return;
            
            // „Åì„ÅÆ„Ç≥„Éº„Éä„Éº„Å´Êé•Á∂ö„Åó„Å¶„ÅÑ„ÇãËæ∫„ÇíÂèñÂæó
            corner.lines.forEach(lineRef => {
                const line = lines.find(l => l.id === lineRef.lineId);
                if (!line) return;
                
                // Â§âÊõ¥„Åó„ÅüËæ∫‰ª•Â§ñ„ÅÆËæ∫„ÅÆÁä∂ÊÖã„ÇíË™øÊï¥
                if (line.id !== changedLineId) {
                    if (newState === 'end') {
                        // ÁâáÊñπ„Åå„Ç®„É≥„Éâ ‚Üí „ÇÇ„ÅÜÁâáÊñπ„ÅØÂ£Å
                        line[lineRef.point] = 'wall';
                    } else if (newState === 'wall') {
                        // ÁâáÊñπ„ÅåÂ£Å ‚Üí „ÇÇ„ÅÜÁâáÊñπ„ÅØ„Ç®„É≥„Éâ„Åæ„Åü„ÅØÂ£ÅÔºàÂ§âÊõ¥„Åó„Å™„ÅÑÔºâ
                        // ‰Ωï„ÇÇ„Åó„Å™„ÅÑ
                    }
                }
            });
        }
        
        // ÂØ∏Ê≥ïÊõ¥Êñ∞
        function updateDimension(id, type, value) {
            if (!dimensions[id]) {
                dimensions[id] = { length: null, width: null };
            }
            
            dimensions[id][type] = value ? parseFloat(value) : null;
            
            // Âõ≥Èù¢„ÇíÂÜçÊèèÁîªÔºà„Çπ„Ç±„Éº„É´Ë™øÊï¥„ÅØ„Åó„Å™„ÅÑÔºâ
            drawLines();
            calculate();
        }
        
        // Ë®àÁÆó
        function calculate() {
            const resultsContent = document.getElementById('results-content');
            let html = '';
            let hasAll = true;
            let missingItems = []; // Êú™ÂÖ•ÂäõÈ†ÖÁõÆ„É™„Çπ„Éà
            
            // „Ç≥„Éº„Éä„Éº„ÇíÊ§úÂá∫
            detectCorners();
            
            // ÂÖ•Âäõ„ÉÅ„Çß„ÉÉ„ÇØ
            lines.forEach(line => {
                const dim = dimensions[line.id];
                
                // Â§ñÊ≥ïÂØ∏Ê≥ï„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ
                if (!dim || !dim.length) {
                    hasAll = false;
                    missingItems.push(`${line.name}„ÅÆÂ§ñÊ≥ïÂØ∏Ê≥ï`);
                }
                
                // Ë∫Ø‰ΩìÂπÖ„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ
                const hasWidth = useIndividualWidth ? (dim && dim.width) : commonWidth;
                if (!hasWidth) {
                    hasAll = false;
                    if (useIndividualWidth) {
                        missingItems.push(`${line.name}„ÅÆË∫Ø‰ΩìÂπÖ`);
                    } else if (!commonWidth) {
                        // Ë∫Ø‰ΩìÂπÖ„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØÔºàÈáçË§á„ÇíÈÅø„Åë„Çã„Åü„ÇÅ‰∏ÄÂ∫¶„Å†„ÅëËøΩÂä†Ôºâ
                        if (!missingItems.includes('Ë∫Ø‰ΩìÂπÖ')) {
                            missingItems.push('Ë∫Ø‰ΩìÂπÖ');
                        }
                    }
                }
            });
            
            // Ë∫Ø‰ΩìÈ´ò„Åï„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ
            if (!commonHeight) {
                hasAll = false;
                missingItems.push('Ë∫Ø‰ΩìÈ´ò„Åï');
            }
            
            // ÊÆµÂ∑ÆÂØ∏Ê≥ï„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ
            if (corners) {
                for (const cornerKey in corners) {
                    const corner = corners[cornerKey];
                    if (corner && corner.hasStep) {
                        // ÊÆµÂ∑Æ„Åå„ÅÇ„ÇãÂ†¥Âêà„ÄÅÊ∑±„Åï„ÅåÂÖ•Âäõ„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                        if (!corner.depth) {
                            hasAll = false;
                            // „Ç≥„Éº„Éä„Éº„Å´Êé•Á∂ö„Åó„Å¶„ÅÑ„ÇãËæ∫„ÅÆÂêçÂâç„ÇíÂèñÂæó
                            if (corner.lines && corner.lines.length >= 2) {
                                const line1 = lines.find(l => l.id === corner.lines[0].lineId);
                                const line2 = lines.find(l => l.id === corner.lines[1].lineId);
                                if (line1 && line2) {
                                    missingItems.push(`${line1.name}‚îÅ${line2.name}„ÅÆÊÆµÂ∑ÆÂØ∏Ê≥ï`);
                                } else {
                                    missingItems.push('ÊÆµÂ∑ÆÂØ∏Ê≥ï');
                                }
                            } else {
                                missingItems.push('ÊÆµÂ∑ÆÂØ∏Ê≥ï');
                            }
                        }
                    }
                }
            }
            
            // ÂÖ®„Å¶ÂÖ•Âäõ„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅÆ„ÅøË®àÁÆóÁµêÊûú„ÇíË°®Á§∫
            if (hasAll) {
                lines.forEach(line => {
                    const dim = dimensions[line.id];
                    let result = dim.length;
                    
                    // ÂßãÁÇπ„Åå„Ç≥„Éº„Éä„Éº„Å™„ÇâÈö£Êé•„Åô„ÇãËæ∫„ÅÆÂπÖ„ÅÆÂçäÂàÜ„ÇíÂºï„Åè
                    if (line.start === 'corner') {
                        const adjacentWidth = getAdjacentLineWidth(line.id, 'start');
                        if (adjacentWidth > 0) {
                            result -= adjacentWidth / 2;
                        }
                    }
                    
                    // ÁµÇÁÇπ„Åå„Ç≥„Éº„Éä„Éº„Å™„ÇâÈö£Êé•„Åô„ÇãËæ∫„ÅÆÂπÖ„ÅÆÂçäÂàÜ„ÇíÂºï„Åè
                    if (line.end === 'corner') {
                        const adjacentWidth = getAdjacentLineWidth(line.id, 'end');
                        if (adjacentWidth > 0) {
                            result -= adjacentWidth / 2;
                        }
                    }
                    
                    const startLabel = getPointLabel(line.start);
                    const endLabel = getPointLabel(line.end);
                    
                    html += `
                        <div class="result-item">
                            <span class="result-label">${line.name} ${startLabel}‚îÅ${endLabel}</span>
                            <span class="result-value">${Math.floor(result)} mm</span>
                        </div>
                    `;
                });
                
                // „Ç≠„É£„É≥„Éê„Çπ„Å®‰øùÂ≠ò„Éú„Çø„É≥„ÇíËøΩÂä†„Åó„Å¶Âõ≥„ÇíÊèèÁîª
                html = `
                    <div style="margin-bottom: 20px;">
                        <canvas id="result-canvas" width="500" height="400" style="width: 100%; border-radius: 10px;"></canvas>
                    </div>
                    
                    <!-- ‰øùÂ≠ò„ÉªÂÖ±Êúâ„Éú„Çø„É≥ -->
                    <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
                        <button onclick="downloadAsPDF()" style="flex: 1; min-width: 140px; padding: 12px 20px; background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                            üìÑ PDF„Åß‰øùÂ≠ò
                        </button>
                        <button onclick="downloadAsPNG()" style="flex: 1; min-width: 140px; padding: 12px 20px; background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                            üñºÔ∏è ÁîªÂÉè„Åß‰øùÂ≠ò
                        </button>
                        <button onclick="shareResult()" style="flex: 1; min-width: 140px; padding: 12px 20px; background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                            üì§ ÂÖ±Êúâ
                        </button>
                    </div>
                ` + html;
                
                resultsContent.innerHTML = html;
                
                // Âõ≥„ÇíÊèèÁîª
                drawResultDiagram();
            } else {
                // ÂÖ•ÂäõÊºè„Çå„Åå„ÅÇ„ÇãÂ†¥Âêà„ÄÅËµ§ÊñáÂ≠ó„ÅßË≠¶ÂëäË°®Á§∫
                const warningHtml = `
                    <div style="background: #fee; border: 2px solid #e74c3c; border-radius: 10px; padding: 20px; text-align: center;">
                        <div style="color: #e74c3c; font-size: 20px; font-weight: bold; margin-bottom: 15px;">
                            ‚ö†Ô∏è ÂÖ•Âäõ„ÅåÂÆå‰∫Ü„Åó„Å¶„ÅÑ„Åæ„Åõ„Çì
                        </div>
                        <div style="color: #c0392b; font-size: 16px; line-height: 1.8;">
                            ‰ª•‰∏ã„ÅÆÈ†ÖÁõÆ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö<br>
                            <strong>${missingItems.join('„ÄÅ')}</strong>
                        </div>
                    </div>
                `;
                resultsContent.innerHTML = warningHtml;
            }
        }
        
        // Èö£Êé•„Åô„ÇãËæ∫„ÅÆÂπÖ„ÇíÂèñÂæó
        function getAdjacentLineWidth(lineId, point) {
            // Ë©≤ÂΩì„Åô„ÇãËæ∫„ÇíÊé¢„Åô
            const currentLine = lines.find(l => l.id === lineId);
            if (!currentLine) return 0;
            
            // „Ç≥„Éº„Éä„Éº„Ç≠„Éº„ÇíÂèñÂæó
            const x = point === 'start' ? currentLine.x1 : currentLine.x2;
            const y = point === 'start' ? currentLine.y1 : currentLine.y2;„ÄÄ
            const cornerKey = findCornerKey(x, y, 5);
            
            if (!corners || !corners[cornerKey]) return 0;
            
            const corner = corners[cornerKey];
            
            // „Åì„ÅÆ„Ç≥„Éº„Éä„Éº„Å´Êé•Á∂ö„Åó„Å¶„ÅÑ„Çã‰ªñ„ÅÆËæ∫„ÇíÊé¢„Åô
            for (const lineRef of corner.lines) {
                if (lineRef.lineId !== lineId) {
                    // Èö£Êé•„Åô„ÇãËæ∫„ÅåË¶ã„Å§„Åã„Å£„Åü
                    const adjacentLine = lines.find(l => l.id === lineRef.lineId);
                    if (adjacentLine) {
                        const adjacentDim = dimensions[lineRef.lineId];
                        if (adjacentDim && adjacentDim.width) {
                            return adjacentDim.width;
                        }
                    }
                }
            }
            
            return 0;
        }
        
        // Ë®àÁÆóÁµêÊûú„ÅÆÂõ≥„ÇíÊèèÁîª
        function drawResultDiagram() {
            const resultCanvas = document.getElementById('result-canvas');
            if (!resultCanvas) return;
            
            const ctx = resultCanvas.getContext('2d');
            
            // ËÉåÊôØËâ≤„ÇíÂ°ó„ÇãÔºàË®àÁÆóÁµêÊûú„Å®„Çè„Åã„Çã„Çà„ÅÜ„Å´Ôºâ
            ctx.fillStyle = '#f0f9ff';
            ctx.fillRect(0, 0, resultCanvas.width, resultCanvas.height);
            
            if (lines.length === 0) return;
            
            // ÂÆüÂØ∏Ê≥ï„Çí‰Ωø„Å£„Å¶Âõ≥ÂΩ¢„ÇíÂÜçÊßãÁØâ
            const realLines = [];
            const minLength = 300; // ÊúÄÂ∞èË°®Á§∫Èï∑„ÅïÔºàpxÔºâ- Ë¶ã„ÇÑ„Åô„ÅïÂÑ™ÂÖà
            
            // ÂêÑÁ∑ö„ÅÆÂÆüÂØ∏Ê≥ï„Å´Âü∫„Å•„ÅÑ„Å¶Â∫ßÊ®ô„ÇíË®àÁÆó
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const dim = dimensions[line.id];
                
                if (!dim || !dim.length) continue;
                
                // ÂÆüÈöõ„ÅÆÈï∑„Åï„ÇíÂèñÂæóÔºàmmÔºâ
                let realLength = dim.length;
                
                // Á∑ö„ÅÆÊñπÂêë„Éô„ÇØ„Éà„É´„ÇíË®àÁÆó
                const dx = line.x2 - line.x1;
                const dy = line.y2 - line.y1;
                const originalLength = Math.sqrt(dx * dx + dy * dy);
                
                if (originalLength === 0) continue;
                
                // Ê≠£Ë¶èÂåñ„Åï„Çå„ÅüÊñπÂêë„Éô„ÇØ„Éà„É´
                const dirX = dx / originalLength;
                const dirY = dy / originalLength;
                
                // ÂÆüÂØ∏Ê≥ï„Çí„Éî„ÇØ„Çª„É´„Å´Â§âÊèõÔºà1mm = 0.2px„ÄÅ„Åü„Å†„ÅóÊúÄÂ∞èÈï∑„Åï„Çí‰øùË®ºÔºâ
                let displayLength = Math.max(realLength * 0.2, minLength);
                
                // ÂßãÁÇπÂ∫ßÊ®ô„ÇíÊ±∫ÂÆö
                let startX = line.x1;
                let startY = line.y1;
                
                // ‰ªñ„ÅÆÁ∑ö„Å®„ÅÆÊé•Á∂ö„ÇíÁ¢∫Ë™ç
                for (let j = 0; j < realLines.length; j++) {
                    const prevLine = realLines[j].line;
                    
                    // ÁèæÂú®„ÅÆÁ∑ö„ÅÆÂßãÁÇπ„Åå„ÄÅÊó¢Â≠ò„ÅÆÁ∑ö„ÅÆÁµÇÁÇπ„Å®‰∏ÄËá¥„Åô„ÇãÂ†¥Âêà
                    if (Math.abs(line.x1 - prevLine.x2) < 1 && Math.abs(line.y1 - prevLine.y2) < 1) {
                        startX = realLines[j].x2;
                        startY = realLines[j].y2;
                        break;
                    }
                    
                    // ÁèæÂú®„ÅÆÁ∑ö„ÅÆÂßãÁÇπ„Åå„ÄÅÊó¢Â≠ò„ÅÆÁ∑ö„ÅÆÂßãÁÇπ„Å®‰∏ÄËá¥„Åô„ÇãÂ†¥Âêà
                    if (Math.abs(line.x1 - prevLine.x1) < 1 && Math.abs(line.y1 - prevLine.y1) < 1) {
                        startX = realLines[j].x1;
                        startY = realLines[j].y1;
                        break;
                    }
                }
                
                // ÁµÇÁÇπ„ÇíË®àÁÆó
                realLines.push({
                    x1: startX,
                    y1: startY,
                    x2: startX + dirX * displayLength,
                    y2: startY + dirY * displayLength,
                    line: line
                });
            }
            
            if (realLines.length === 0) return;
            
            // ÂÖ®„Å¶„ÅÆÁÇπ„ÅÆÁØÑÂõ≤„ÇíÂèñÂæó
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            
            realLines.forEach(rLine => {
                minX = Math.min(minX, rLine.x1, rLine.x2);
                minY = Math.min(minY, rLine.y1, rLine.y2);
                maxX = Math.max(maxX, rLine.x1, rLine.x2);
                maxY = Math.max(maxY, rLine.y1, rLine.y2);
            });
            
            // Âõ≥ÂΩ¢„ÅÆÂπÖ„Å®È´ò„Åï
            const shapeWidth = Math.max(maxX - minX, 1); // ÊúÄÂ∞èÂÄ§1„Çí‰øùË®º
            const shapeHeight = Math.max(maxY - minY, 1); // ÊúÄÂ∞èÂÄ§1„Çí‰øùË®º
            
            // „Éû„Éº„Ç∏„É≥
            const margin = 60;
            const canvasWidth = resultCanvas.width - margin * 2;
            const canvasHeight = resultCanvas.height - margin * 2;
            
            // „Çπ„Ç±„Éº„É´‰øÇÊï∞„ÇíË®àÁÆóÔºà„Ç¢„Çπ„Éö„ÇØ„ÉàÊØî„ÇíÁ∂≠ÊåÅÔºâ
            const scaleX = canvasWidth / shapeWidth;
            const scaleY = canvasHeight / shapeHeight;
            const scale = Math.min(scaleX, scaleY);
            
            // „Ç™„Éï„Çª„ÉÉ„Éà„ÇíË®àÁÆóÔºà‰∏≠Â§ÆÈÖçÁΩÆÔºâ
            const scaledWidth = shapeWidth * scale;
            const scaledHeight = shapeHeight * scale;
            const offsetX = margin + (canvasWidth - scaledWidth) / 2 - minX * scale;
            const offsetY = margin + (canvasHeight - scaledHeight) / 2 - minY * scale;
            
            // Â∫ßÊ®ôÂ§âÊèõÈñ¢Êï∞
            function transformX(x) {
                return x * scale + offsetX;
            }
            
            function transformY(y) {
                return y * scale + offsetY;
            }
            
            // ÁÇπ„ÇíÊèèÁîª„Åô„ÇãÈñ¢Êï∞
            function drawResultPoint(x, y, state) {
                const colors = {
                    'corner': '#ef4444',
                    'end': '#3b82f6',
                    'wall': '#10b981'
                };
                
                ctx.fillStyle = colors[state] || colors['end'];
                ctx.beginPath();
                ctx.arc(transformX(x), transformY(y), 6, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(transformX(x), transformY(y), 6, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // „Ç≥„Éº„Éä„Éº„ÇíÊ§úÂá∫
            detectCorners();
            
            // Á∑ö„ÇíÊèèÁîªÔºàÈªí‰∏ÄËâ≤„Å´Áµ±‰∏ÄÔºâ
            realLines.forEach(rLine => {
                const line = rLine.line;
                
                ctx.strokeStyle = '#1a1a1a';
                ctx.lineWidth = 5;
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                ctx.moveTo(transformX(rLine.x1), transformY(rLine.y1));
                ctx.lineTo(transformX(rLine.x2), transformY(rLine.y2));
                ctx.stroke();
                
                // Ë®àÁÆóÁµêÊûú„Å®Ë∫Ø‰ΩìÂπÖ„ÇíÁ∑ö„ÅÆÂ§ñÂÅ¥„Å´Ë°®Á§∫
                const dim = dimensions[line.id];
                if (dim && dim.length) {
                    let result = dim.length;
                    
                    // ÂßãÁÇπ„Åå„Ç≥„Éº„Éä„Éº„Å™„ÇâÈö£Êé•„Åô„ÇãËæ∫„ÅÆÂπÖ„ÅÆÂçäÂàÜ„ÇíÂºï„Åè
                    if (line.start === 'corner') {
                        const adjacentWidth = getAdjacentLineWidth(line.id, 'start');
                        if (adjacentWidth > 0) {
                            result -= adjacentWidth / 2;
                        }
                    }
                    
                    // ÁµÇÁÇπ„Åå„Ç≥„Éº„Éä„Éº„Å™„ÇâÈö£Êé•„Åô„ÇãËæ∫„ÅÆÂπÖ„ÅÆÂçäÂàÜ„ÇíÂºï„Åè
                    if (line.end === 'corner') {
                        const adjacentWidth = getAdjacentLineWidth(line.id, 'end');
                        if (adjacentWidth > 0) {
                            result -= adjacentWidth / 2;
                        }
                    }
                    
                    // Á∑ö„ÅÆ‰∏≠ÁÇπ„Å®ÊñπÂêë„Éô„ÇØ„Éà„É´„ÇíË®àÁÆó
                    const midX = (rLine.x1 + rLine.x2) / 2;
                    const midY = (rLine.y1 + rLine.y2) / 2;
                    const dx = rLine.x2 - rLine.x1;
                    const dy = rLine.y2 - rLine.y1;
                    const lineLength = Math.sqrt(dx * dx + dy * dy);
                    
                    // Á∑ö„ÅÆÂûÇÁõ¥ÊñπÂêë„ÅÆ„Éô„ÇØ„Éà„É´ÔºàÂ∑¶ÂÅ¥„Å´ÈÖçÁΩÆÔºâ
                    const perpX = -dy / lineLength;
                    const perpY = dx / lineLength;
                    
                    // „ÉÜ„Ç≠„Çπ„Éà„ÅÆ„Ç™„Éï„Çª„ÉÉ„ÉàÔºàÁ∑ö„ÅÆÂ§ñÂÅ¥„ÄÅ30pxÈõ¢„ÅôÔºâ
                    const offset = 30;
                    const textX = transformX(midX + perpX * offset);
                    const textY = transformY(midY + perpY * offset);
                    
                    // ËäØÂØ∏Ê≥ïÔºàË®àÁÆóÁµêÊûúÔºâ„Çí„Ç≥„É≥„Éë„ÇØ„Éà„Å´Ë°®Á§∫
                    ctx.font = 'bold 16px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    const resultText = `${Math.floor(result)}`;
                    const resultMetrics = ctx.measureText(resultText);
                    const padding = 6;
                    
                    // ÈªÑËâ≤„ÅÆÂçäÈÄèÊòéËÉåÊôØ„ÅßÁõÆÁ´ã„Åü„Åõ„ÇãÔºàÁ∑ö„ÅåÈÄè„Åë„Å¶Ë¶ã„Åà„ÇãÔºâ
                    ctx.fillStyle = 'rgba(254, 243, 199, 0.85)';
                    ctx.fillRect(textX - resultMetrics.width/2 - padding, textY - 10, resultMetrics.width + padding*2, 20);
                    
                    // Êû†Á∑ö„ÇíËøΩÂä†
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 1.5;
                    ctx.strokeRect(textX - resultMetrics.width/2 - padding, textY - 10, resultMetrics.width + padding*2, 20);
                    
                    // ÊñáÂ≠ó„ÇíÊèèÁîªÔºàÊøÉ„ÅÑÈùí„ÅßÂº∑Ë™øÔºâ
                    ctx.fillStyle = '#1e40af';
                    ctx.fillText(resultText, textX, textY);
                    
                    // Ë∫Ø‰ΩìÂπÖ„ÇíÂ∞è„Åï„ÅèË°®Á§∫ÔºàËäØÂØ∏Ê≥ï„ÅÆ‰∏ã„ÄÅËÉåÊôØ‰ªò„ÅçÔºâ
                    if (dim.width) {
                        ctx.font = '10px sans-serif';
                        const widthText = `ÂπÖ:${dim.width}`;
                        const widthMetrics = ctx.measureText(widthText);
                        const widthY = textY + 16;
                        const widthPadding = 3;
                        
                        // ËÉåÊôØÔºàÂçäÈÄèÊòé„ÅÆËñÑ„ÅÑÁÅ∞Ëâ≤Ôºâ
                        ctx.fillStyle = 'rgba(243, 244, 246, 0.85)';
                        ctx.fillRect(textX - widthMetrics.width/2 - widthPadding, widthY - 7, widthMetrics.width + widthPadding*2, 14);
                        
                        // ÊñáÂ≠óÔºàÁÅ∞Ëâ≤Ôºâ
                        ctx.fillStyle = '#6b7280';
                        ctx.fillText(widthText, textX, widthY);
                    }
                }
            });
            
            // Êó¢„Å´ÊèèÁîª„Åó„Åü„Ç≥„Éº„Éä„Éº„ÇíË®òÈå≤
            const drawnCorners = new Set();
            
            // ÂÖÉ„ÅÆÂ∫ßÊ®ô„Åã„ÇârealLinesÂ∫ßÊ®ô„Å∏„ÅÆÂØæÂøú„Éû„ÉÉ„Éó„Çí‰ΩúÊàê
            const coordMap = new Map();
            realLines.forEach((rLine, idx) => {
                const line = rLine.line;
                // ÂßãÁÇπ„ÅÆÂØæÂøú
                const startKey = `${line.x1},${line.y1}`;
                if (!coordMap.has(startKey)) {
                    coordMap.set(startKey, { x: rLine.x1, y: rLine.y1 });
                }
                // ÁµÇÁÇπ„ÅÆÂØæÂøú
                const endKey = `${line.x2},${line.y2}`;
                if (!coordMap.has(endKey)) {
                    coordMap.set(endKey, { x: rLine.x2, y: rLine.y2 });
                }
            });
            
            // „Ç≥„Éº„Éä„Éº„Éô„Éº„Çπ„ÅßÁÇπ„ÇíÊèèÁîª
            if (corners) {
                for (const cornerKey in corners) {
                    const corner = corners[cornerKey];
                    
                    if (!corner || drawnCorners.has(cornerKey)) continue;
                    drawnCorners.add(cornerKey);
                    
                    if (!corner.lines || corner.lines.length === 0) continue;
                    
                    const firstLineRef = corner.lines[0];
                    const firstLine = lines.find(l => l.id === firstLineRef.lineId);
                    if (!firstLine) continue;
                    
                    // „Ç≥„Éº„Éä„Éº„ÅÆÂÖÉÂ∫ßÊ®ô
                    const cornerX = corner.x !== undefined ? corner.x : (firstLine[firstLineRef.point === 'start' ? 'x1' : 'x2']);
                    const cornerY = corner.y !== undefined ? corner.y : (firstLine[firstLineRef.point === 'start' ? 'y1' : 'y2']);
                    
                    // ÂÖÉÂ∫ßÊ®ô„Åã„ÇârealLinesÂ∫ßÊ®ô„Å´Â§âÊèõ
                    const coordKey = `${cornerX},${cornerY}`;
                    const realCoord = coordMap.get(coordKey);
                    
                    if (!realCoord) continue;
                    
                    // ÊÆµÂ∑Æ„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ2„Å§„ÅÆÁÇπ„ÄÅ„Å™„ÅÑÂ†¥Âêà„ÅØ1„Å§„ÅÆÁÇπ
                    if (corner.hasStep && corner.lines.length >= 2) {
                        // 2„Å§„ÅÆËæ∫„Åã„ÇâÁä∂ÊÖã„ÇíÂèñÂæó
                        const line1Ref = corner.lines[0];
                        const line2Ref = corner.lines[1];
                        const line1 = lines.find(l => l.id === line1Ref.lineId);
                        const line2 = lines.find(l => l.id === line2Ref.lineId);
                        
                        if (line1 && line2) {
                            const state1 = line1[line1Ref.point] || 'wall';
                            const state2 = line2[line2Ref.point] || 'wall';
                            
                            const offset = 20; // Ëßí„Åã„Çâ„ÅÆ„Åö„Çâ„ÅóË∑ùÈõ¢
                            
                            // line1„Å´ÂØæÂøú„Åô„ÇãrealLine„ÇíË¶ã„Å§„Åë„Çã
                            const rLine1 = realLines.find(rl => rl.line.id === line1.id);
                            const rLine2 = realLines.find(rl => rl.line.id === line2.id);
                            
                            if (rLine1 && rLine2) {
                                // line1„ÅÆÊñπÂêë„Éô„ÇØ„Éà„É´„ÇíË®àÁÆóÔºàËßí„Åã„ÇâÁ∑ö„Å´Ê≤ø„Å£„Å¶ÈÄ≤„ÇÄÊñπÂêëÔºâ
                                let dx1, dy1;
                                if (line1Ref.point === 'start') {
                                    dx1 = rLine1.x2 - rLine1.x1;
                                    dy1 = rLine1.y2 - rLine1.y1;
                                } else {
                                    dx1 = rLine1.x1 - rLine1.x2;
                                    dy1 = rLine1.y1 - rLine1.y2;
                                }
                                const len1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
                                
                                // line2„ÅÆÊñπÂêë„Éô„ÇØ„Éà„É´„ÇíË®àÁÆóÔºàËßí„Åã„ÇâÁ∑ö„Å´Ê≤ø„Å£„Å¶ÈÄ≤„ÇÄÊñπÂêëÔºâ
                                let dx2, dy2;
                                if (line2Ref.point === 'start') {
                                    dx2 = rLine2.x2 - rLine2.x1;
                                    dy2 = rLine2.y2 - rLine2.y1;
                                } else {
                                    dx2 = rLine2.x1 - rLine2.x2;
                                    dy2 = rLine2.y1 - rLine2.y2;
                                }
                                const len2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                                
                                if (len1 > 0 && len2 > 0) {
                                    // Ê≠£Ë¶èÂåñ„Åï„Çå„ÅüÊñπÂêë„Éô„ÇØ„Éà„É´
                                    const dirX1 = dx1 / len1;
                                    const dirY1 = dy1 / len1;
                                    const dirX2 = dx2 / len2;
                                    const dirY2 = dy2 / len2;
                                    
                                    // ÂêÑÁ∑ö„ÅÆÊñπÂêë„Å´Ê≤ø„Å£„Å¶Ëßí„Åã„Çâ„Åö„Çâ„Åó„Åü‰ΩçÁΩÆ„Å´ÁÇπ„ÇíÈÖçÁΩÆ
                                    drawResultPoint(realCoord.x + dirX1 * offset, realCoord.y + dirY1 * offset, state1);
                                    drawResultPoint(realCoord.x + dirX2 * offset, realCoord.y + dirY2 * offset, state2);
                                } else {
                                    drawResultPoint(realCoord.x, realCoord.y, state1);
                                }
                            } else {
                                drawResultPoint(realCoord.x, realCoord.y, state1);
                            }
                        }
                    } else {
                        const state = firstLine[firstLineRef.point] || 'wall';
                        drawResultPoint(realCoord.x, realCoord.y, state);
                    }
                }
            }
            
            // Âá°‰æã„ÇíÂè≥‰∏ã„Å´„Ç∑„É≥„Éó„É´„Å´ÊèèÁîªÔºàÂΩ±‰ªò„ÅçÊñáÂ≠óÔºâ
            const legendX = resultCanvas.width - 85;
            const legendY = resultCanvas.height - 70;
            
            // Âá°‰æã„ÅÆ„Çø„Ç§„Éà„É´
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'left';
            
            // „Çø„Ç§„Éà„É´„ÅÆÂΩ±
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillText('ÁÇπ„ÅÆÁ®ÆÈ°û', legendX + 1, legendY + 1);
            ctx.fillText('ÁÇπ„ÅÆÁ®ÆÈ°û', legendX - 1, legendY - 1);
            ctx.fillText('ÁÇπ„ÅÆÁ®ÆÈ°û', legendX + 1, legendY - 1);
            ctx.fillText('ÁÇπ„ÅÆÁ®ÆÈ°û', legendX - 1, legendY + 1);
            
            // „Çø„Ç§„Éà„É´Êú¨‰Ωì
            ctx.fillStyle = '#1f2937';
            ctx.fillText('ÁÇπ„ÅÆÁ®ÆÈ°û', legendX, legendY);
            
            // Âá°‰æã„ÅÆÈ†ÖÁõÆ
            const legendItems = [
                { color: '#ef4444', label: '„Ç≥„Éº„Éä„Éº' },
                { color: '#3b82f6', label: '„Ç®„É≥„Éâ' },
                { color: '#10b981', label: 'Â£Å' }
            ];
            
            legendItems.forEach((item, index) => {
                const itemY = legendY + 22 + index * 18;
                
                // Ëâ≤„ÅÆ‰∏∏ÔºàÂΩ±‰ªò„ÅçÔºâ
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(legendX + 6, itemY + 1, 5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = item.color;
                ctx.beginPath();
                ctx.arc(legendX + 5, itemY, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // „É©„Éô„É´„ÅÆÂΩ±
                ctx.font = '11px sans-serif';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillText(item.label, legendX + 16, itemY + 5);
                ctx.fillText(item.label, legendX + 14, itemY + 3);
                ctx.fillText(item.label, legendX + 16, itemY + 3);
                ctx.fillText(item.label, legendX + 14, itemY + 5);
                
                // „É©„Éô„É´Êú¨‰Ωì
                ctx.fillStyle = '#374151';
                ctx.fillText(item.label, legendX + 15, itemY + 4);
            });
        }
        
        // ÁÇπ„ÅÆ„É©„Éô„É´„ÇíÂèñÂæó
        function getPointLabel(state) {
            const labels = {
                'corner': '<span style="color: #e74c3c;">‚óè</span>',
                'end': '<span style="color: #3498db;">‚óè</span>',
                'wall': '<span style="color: #2ecc71;">‚óè</span>'
            };
            return labels[state] || labels['end'];
        }
        
        // „Ç´„Çπ„Çø„É†‰ΩúÂõ≥
        function setupCustomDrawing() {
            // ÂÖ•Âäõ„Éï„Ç©„Éº„É†„Çí„ÇØ„É™„Ç¢
            document.getElementById('dimension-inputs').innerHTML = `
                <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0; color: #1976d2; font-size: 16px;">üìù ‰ΩúÂõ≥ÊñπÊ≥ï</h3>
                    <p style="margin: 0; color: #555; font-size: 14px;">
                        <strong>„ÇØ„É™„ÉÉ„ÇØ</strong>„ÅßÁÇπ„ÇíÊâì„Å°„ÄÅÁ∑ö„ÇíÈÄ£Á∂ö„Åó„Å¶Âºï„Åè<br>
                        <strong>„ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØ</strong>„Åæ„Åü„ÅØ‰∏ã„ÅÆ„Éú„Çø„É≥„Åß‰ΩúÂõ≥ÁµÇ‰∫Ü
                    </p>
                    <button onclick="finishDrawing()" style="width: 100%; padding: 12px; background: #27ae60; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: bold; cursor: pointer; margin-top: 10px;">
                        ‚úì ‰ΩúÂõ≥ÁµÇ‰∫Ü
                    </button>
                    <h3 style="margin: 15px 0 10px 0; color: #1976d2; font-size: 16px;">üé® ÁÇπ„ÅÆÊÑèÂë≥</h3>
                    <p style="margin: 0; color: #555; font-size: 14px;">
                        <span style="color: #e74c3c;">‚óè</span> Ëµ§Ôºö„Ç≥„Éº„Éä„ÉºÔºàË∫Ø‰ΩìÂπÖ√∑2„ÇíÂºï„ÅèÔºâ<br>
                        <span style="color: #3498db;">‚óè</span> ÈùíÔºö„Ç®„É≥„ÉâÔºàÁ´ØÈÉ®„ÄÅÂ£Å„Å™„ÅóÔºâ<br>
                        <span style="color: #2ecc71;">‚óè</span> Á∑ëÔºöÂ£ÅÔºàÂ£Å„ÅÇ„ÇäÔºâ<br>
                        <strong>‰ΩúÂõ≥ÁµÇ‰∫ÜÂæå„ÄÅÁÇπ„Çí„Çø„ÉÉ„Éó„ÅßÂàá„ÇäÊõø„Åà</strong>
                    </p>
                </div>
            `;
            
            drawingPoints = [];
            
            // Êó¢Â≠ò„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„Çí„Åô„Åπ„Å¶ÂâäÈô§
            canvas.removeEventListener('mousedown', startDrawing);
            canvas.removeEventListener('mousemove', drawing);
            canvas.removeEventListener('mouseup', endDrawing);
            canvas.removeEventListener('click', handlePointClick);
            canvas.removeEventListener('touchend', handlePointClickTouch);
            
            // ‰ΩúÂõ≥Áî®„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíË®≠ÂÆö
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('mousemove', handleCanvasMouseMove);
            
            canvas.addEventListener('touchstart', handleTouchDrawing);
            canvas.addEventListener('touchmove', handleTouchDrawingMove);
            
            updateDrawingControls();
        }
        
        // Canvas„ÇØ„É™„ÉÉ„ÇØÂá¶ÁêÜÔºà‰ΩúÂõ≥Áî®Ôºâ
        function handleCanvasClick(e) {
            // ÁÇπ„ÅÆÁä∂ÊÖãÂàá„ÇäÊõø„Åà„Å®„ÅÆÁ´∂Âêà„ÇíÈÅø„Åë„Çã
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let x = (e.offsetX || e.clientX - rect.left) * scaleX;
            let y = (e.offsetY || e.clientY - rect.top) * scaleY;
            
            // „Çπ„Éä„ÉÉ„ÉóÂá¶ÁêÜÔºà2ÁÇπÁõÆ‰ª•ÈôçÔºâ
            if (drawingPoints.length > 0) {
                const lastPoint = drawingPoints[drawingPoints.length - 1];
                const snapped = snapToAxis(lastPoint.x, lastPoint.y, x, y);
                x = snapped.x;
                y = snapped.y;
            }
            
            // ÂßãÁÇπ„Å∏„ÅÆÂê∏ÁùÄ„Å®Èñâ„Åò„ÇãÁ¢∫Ë™çÔºà3ÁÇπ‰ª•‰∏ä„ÅÇ„ÇãÂ†¥ÂêàÔºâ
            if (drawingPoints.length >= 3) {
                const startPoint = drawingPoints[0];
                const distToStart = Math.sqrt(Math.pow(x - startPoint.x, 2) + Math.pow(y - startPoint.y, 2));
                
                // ÂßãÁÇπ„Åã„Çâ30px‰ª•ÂÜÖÔºàÁõ¥Êé•„ÇØ„É™„ÉÉ„ÇØ„Åæ„Åü„ÅØ„Ç¨„Ç§„Éâ„É©„Ç§„É≥ÁµåÁî±Ôºâ
                if (distToStart < 30) {
                    if (confirm('Âõ≥ÂΩ¢„ÇíÈñâ„Åò„Åæ„Åô„ÅãÔºü\nÔºàÂßãÁÇπ„Å®ÁµÇÁÇπ„ÇíÁµêÂêà„Åó„Åæ„ÅôÔºâ')) {
                        // ÂßãÁÇπ„Å´Âê∏ÁùÄ
                        x = startPoint.x;
                        y = startPoint.y;
                        
                        // ÁÇπ„ÇíËøΩÂä†
                        drawingPoints.push({ x, y });
                        
                        // ÊúÄÂæå„ÅÆÁ∑ö„Çí‰ΩúÊàê
                        const prevPoint = drawingPoints[drawingPoints.length - 2];
                        const currPoint = drawingPoints[drawingPoints.length - 1];
                        
                        const id = String.fromCharCode(65 + lines.length);
                        lines.push({
                            id: id,
                            x1: prevPoint.x,
                            y1: prevPoint.y,
                            x2: currPoint.x,
                            y2: currPoint.y,
                            name: `Ëæ∫${id}`,
                            start: 'wall',
                            end: 'wall'
                        });
                        
                        // „Ç≥„Éº„Éä„Éº„ÅÆËá™ÂãïË®≠ÂÆö
                        autoSetCorners();
                        
                        // ‰ΩúÂõ≥ÁµÇ‰∫Ü
                        finishDrawing();
                        return;
                    } else {
                        // „Ç≠„É£„É≥„Çª„É´„Åó„ÅüÂ†¥Âêà„ÅØ‰Ωï„ÇÇ„Åó„Å™„ÅÑ
                        return;
                    }
                }
            }
            
            // Êó¢Â≠ò„ÅÆÁÇπ„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Åü„ÅãÂà§ÂÆöÔºà„Åü„Å†„ÅóÂßãÁÇπ„ÅØÈô§„ÅèÔºâ
            const clickRadius = 20;
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                // ÂßãÁÇπ„Åã„ÉÅ„Çß„ÉÉ„ÇØÔºà3ÁÇπ‰ª•‰∏ä„ÅÇ„ÇãÂ†¥ÂêàÔºâ
                let isStartPoint = false;
                if (drawingPoints.length >= 3 && i === 0) {
                    const startPoint = drawingPoints[0];
                    const distToStart = Math.sqrt(Math.pow(line.x1 - startPoint.x, 2) + Math.pow(line.y1 - startPoint.y, 2));
                    isStartPoint = distToStart < 5; // ÂßãÁÇπ„Å®Âêå„Åò‰ΩçÁΩÆ„Å™„Çâ
                }
                
                const distStart = Math.sqrt(Math.pow(x - line.x1, 2) + Math.pow(y - line.y1, 2));
                const distEnd = Math.sqrt(Math.pow(x - line.x2, 2) + Math.pow(y - line.y2, 2));
                
                // ÂßãÁÇπ‰ª•Â§ñ„ÅÆÊó¢Â≠ò„ÅÆÁÇπ„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„ÅüÂ†¥Âêà„ÅØÁÑ°Ë¶ñ
                if (!isStartPoint && distStart < clickRadius) {
                    return;
                }
                if (distEnd < clickRadius) {
                    return;
                }
            }
            
            // „ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØÂà§ÂÆö
            const currentTime = new Date().getTime();
            const timeDiff = currentTime - lastClickTime;
            lastClickTime = currentTime;
            
            if (timeDiff < 500 && drawingPoints.length > 0) {
                finishDrawing();
                return;
            }
            
            // ÁÇπ„ÇíËøΩÂä†
            drawingPoints.push({ x, y });
            
            // 2ÁÇπ‰ª•‰∏ä„ÅÇ„Çå„Å∞Á∑ö„Çí‰ΩúÊàê
            if (drawingPoints.length >= 2) {
                const prevPoint = drawingPoints[drawingPoints.length - 2];
                const currPoint = drawingPoints[drawingPoints.length - 1];
                
                const id = String.fromCharCode(65 + lines.length);
                lines.push({
                    id: id,
                    x1: prevPoint.x,
                    y1: prevPoint.y,
                    x2: currPoint.x,
                    y2: currPoint.y,
                    name: `Ëæ∫${id}`,
                    start: 'wall',
                    end: 'wall'
                });
                
                // „Ç≥„Éº„Éä„Éº„ÅÆËá™ÂãïË®≠ÂÆö
                autoSetCorners();
            }
            
            drawLines();
            updateDrawingControls();
        }
        
        // „Éû„Ç¶„ÇπÁßªÂãïÊôÇ„ÅÆ„Éó„É¨„Éì„É•„Éº
        function handleCanvasMouseMove(e) {
            if (drawingPoints.length === 0) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let x = (e.offsetX || e.clientX - rect.left) * scaleX;
            let y = (e.offsetY || e.clientY - rect.top) * scaleY;
            
            // „Çπ„Éä„ÉÉ„ÉóÂá¶ÁêÜ
            const lastPoint = drawingPoints[drawingPoints.length - 1];
            const snapped = snapToAxis(lastPoint.x, lastPoint.y, x, y);
            x = snapped.x;
            y = snapped.y;
            
            drawLines();
            
            // ÂßãÁÇπ„Å∏„ÅÆ„Ç¨„Ç§„Éâ„É©„Ç§„É≥„Å®Âê∏ÁùÄÔºà3ÁÇπ‰ª•‰∏ä„ÅÇ„ÇãÂ†¥ÂêàÔºâ
            let snapToStart = false;
            if (drawingPoints.length >= 3) {
                const startPoint = drawingPoints[0];
                const threshold = 10; // „Ç¨„Ç§„Éâ„É©„Ç§„É≥Ë°®Á§∫„ÅÆÈñæÂÄ§
                
                // Ê∞¥Âπ≥„Ç¨„Ç§„Éâ„É©„Ç§„É≥ÔºàYÂ∫ßÊ®ô„ÅåÂßãÁÇπ„Å®Ëøë„ÅÑÂ†¥ÂêàÔºâ
                if (Math.abs(y - startPoint.y) < threshold) {
                    // ÂßãÁÇπ„Å´Âêë„Åã„Å£„Å¶Ê∞¥Âπ≥Á∑ö„ÇíÂºï„Åè
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(x, startPoint.y);
                    ctx.lineTo(startPoint.x, startPoint.y);
                    ctx.stroke();
                    
                    // YÂ∫ßÊ®ô„ÇíÂßãÁÇπ„Å´Âêà„Çè„Åõ„Çã
                    y = startPoint.y;
                    
                    // XÂ∫ßÊ®ô„ÇÇÂßãÁÇπ„Å®Ëøë„ÅÑÂ†¥Âêà„ÅØÂê∏ÁùÄ
                    if (Math.abs(x - startPoint.x) < threshold) {
                        x = startPoint.x;
                        snapToStart = true;
                    }
                }
                
                // ÂûÇÁõ¥„Ç¨„Ç§„Éâ„É©„Ç§„É≥ÔºàXÂ∫ßÊ®ô„ÅåÂßãÁÇπ„Å®Ëøë„ÅÑÂ†¥ÂêàÔºâ
                if (Math.abs(x - startPoint.x) < threshold) {
                    // ÂßãÁÇπ„Å´Âêë„Åã„Å£„Å¶ÂûÇÁõ¥Á∑ö„ÇíÂºï„Åè
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(startPoint.x, y);
                    ctx.lineTo(startPoint.x, startPoint.y);
                    ctx.stroke();
                    
                    // XÂ∫ßÊ®ô„ÇíÂßãÁÇπ„Å´Âêà„Çè„Åõ„Çã
                    x = startPoint.x;
                    
                    // YÂ∫ßÊ®ô„ÇÇÂßãÁÇπ„Å®Ëøë„ÅÑÂ†¥Âêà„ÅØÂê∏ÁùÄ
                    if (Math.abs(y - startPoint.y) < threshold) {
                        y = startPoint.y;
                        snapToStart = true;
                    }
                }
                
                // ÂßãÁÇπ„Å®ÂêàËá¥„Åó„ÅüÂ†¥Âêà„ÄÅÂßãÁÇπ„ÇíÂ§ß„Åç„ÅèË°®Á§∫
                if (snapToStart) {
                    ctx.fillStyle = '#f59e0b';
                    ctx.beginPath();
                    ctx.arc(startPoint.x, startPoint.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ÁôΩ„ÅÑÁ∏ÅÂèñ„Çä
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
            
            // ÈÄöÂ∏∏„ÅÆ„Ç¨„Ç§„Éâ„É©„Ç§„É≥Ôºà90Â∫¶Ôºâ
            if (!snapToStart) {
                // Ê∞¥Âπ≥„Ç¨„Ç§„Éâ„É©„Ç§„É≥
                if (Math.abs(y - lastPoint.y) < 30) {
                    ctx.strokeStyle = '#10b981';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.moveTo(0, lastPoint.y);
                    ctx.lineTo(canvas.width, lastPoint.y);
                    ctx.stroke();
                }
                
                // ÂûÇÁõ¥„Ç¨„Ç§„Éâ„É©„Ç§„É≥
                if (Math.abs(x - lastPoint.x) < 30) {
                    ctx.strokeStyle = '#10b981';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.moveTo(lastPoint.x, 0);
                    ctx.lineTo(lastPoint.x, canvas.height);
                    ctx.stroke();
                }
            }
            
            // „Éó„É¨„Éì„É•„ÉºÁ∑ö
            ctx.strokeStyle = snapToStart ? '#f59e0b' : '#667eea';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(lastPoint.x, lastPoint.y);
            ctx.lineTo(x, y);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        // Ê∞¥Âπ≥„ÉªÂûÇÁõ¥„Å´„Çπ„Éä„ÉÉ„Éó
        function snapToAxis(x1, y1, x2, y2) {
            const dx = Math.abs(x2 - x1);
            const dy = Math.abs(y2 - y1);
            const threshold = 30; // „Çπ„Éä„ÉÉ„ÉóÂà§ÂÆö„ÅÆÈñæÂÄ§
            
            // Ê∞¥Âπ≥„Å´Ëøë„ÅÑ
            if (dx > dy && dy < threshold) {
                return { x: x2, y: y1 };
            }
            // ÂûÇÁõ¥„Å´Ëøë„ÅÑ
            else if (dy > dx && dx < threshold) {
                return { x: x1, y: y2 };
            }
            // Êñú„ÇÅÔºà„Åù„ÅÆ„Åæ„ÅæÔºâ
            return { x: x2, y: y2 };
        }
        
        // Á∑ö„ÅåÊñú„ÇÅ„Åã„Å©„ÅÜ„ÅãÂà§ÂÆö
        function isLineDiagonal(line) {
            const dx = Math.abs(line.x2 - line.x1);
            const dy = Math.abs(line.y2 - line.y1);
            const threshold = 5;
            
            // Ê∞¥Âπ≥„Åß„ÇÇÂûÇÁõ¥„Åß„ÇÇ„Å™„ÅÑÂ†¥Âêà„ÅØÊñú„ÇÅ
            return dx > threshold && dy > threshold;
        }
        
        // Á∑ö„ÅÆËßíÂ∫¶„ÇíË®àÁÆóÔºàÂ∫¶Ôºâ
        function getLineAngle(line) {
            const dx = line.x2 - line.x1;
            const dy = line.y2 - line.y1;
            const radians = Math.atan2(dy, dx);
            return radians * (180 / Math.PI);
        }
        
        // „Çø„ÉÉ„ÉÅÊèèÁîªÂá¶ÁêÜ
        function handleTouchDrawing(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let x = (touch.clientX - rect.left) * scaleX;
            let y = (touch.clientY - rect.top) * scaleY;
            
            // „Çπ„Éä„ÉÉ„ÉóÂá¶ÁêÜÔºà2ÁÇπÁõÆ‰ª•ÈôçÔºâ
            if (drawingPoints.length > 0) {
                const lastPoint = drawingPoints[drawingPoints.length - 1];
                const snapped = snapToAxis(lastPoint.x, lastPoint.y, x, y);
                x = snapped.x;
                y = snapped.y;
            }
            
            // ÂßãÁÇπ„Å∏„ÅÆÂê∏ÁùÄ„Å®Èñâ„Åò„ÇãÁ¢∫Ë™çÔºà3ÁÇπ‰ª•‰∏ä„ÅÇ„ÇãÂ†¥ÂêàÔºâ
            if (drawingPoints.length >= 3) {
                const startPoint = drawingPoints[0];
                const distToStart = Math.sqrt(Math.pow(x - startPoint.x, 2) + Math.pow(y - startPoint.y, 2));
                
                // ÂßãÁÇπ„Åã„Çâ40px‰ª•ÂÜÖÔºà„Çø„ÉÉ„ÉÅÊìç‰Ωú„ÅØÂ∫É„ÇÅ„Å´Ôºâ
                if (distToStart < 40) {
                    if (confirm('Âõ≥ÂΩ¢„ÇíÈñâ„Åò„Åæ„Åô„ÅãÔºü\nÔºàÂßãÁÇπ„Å®ÁµÇÁÇπ„ÇíÁµêÂêà„Åó„Åæ„ÅôÔºâ')) {
                        // ÂßãÁÇπ„Å´Âê∏ÁùÄ
                        x = startPoint.x;
                        y = startPoint.y;
                        
                        // ÁÇπ„ÇíËøΩÂä†
                        drawingPoints.push({ x, y });
                        
                        // ÊúÄÂæå„ÅÆÁ∑ö„Çí‰ΩúÊàê
                        const prevPoint = drawingPoints[drawingPoints.length - 2];
                        const currPoint = drawingPoints[drawingPoints.length - 1];
                        
                        const id = String.fromCharCode(65 + lines.length);
                        lines.push({
                            id: id,
                            x1: prevPoint.x,
                            y1: prevPoint.y,
                            x2: currPoint.x,
                            y2: currPoint.y,
                            name: `Ëæ∫${id}`,
                            start: 'wall',
                            end: 'wall'
                        });
                        
                        // „Ç≥„Éº„Éä„Éº„ÅÆËá™ÂãïË®≠ÂÆö
                        autoSetCorners();
                        
                        // ‰ΩúÂõ≥ÁµÇ‰∫Ü
                        finishDrawing();
                        return;
                    } else {
                        // „Ç≠„É£„É≥„Çª„É´„Åó„ÅüÂ†¥Âêà„ÅØ‰Ωï„ÇÇ„Åó„Å™„ÅÑ
                        return;
                    }
                }
            }
            
            // Êó¢Â≠ò„ÅÆÁÇπ„Çí„Çø„ÉÉ„Éó„Åó„Åü„ÅãÂà§ÂÆöÔºà„Åü„Å†„ÅóÂßãÁÇπ„ÅØÈô§„ÅèÔºâ
            const clickRadius = 25;
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                // ÂßãÁÇπ„Åã„ÉÅ„Çß„ÉÉ„ÇØÔºà3ÁÇπ‰ª•‰∏ä„ÅÇ„ÇãÂ†¥ÂêàÔºâ
                let isStartPoint = false;
                if (drawingPoints.length >= 3 && i === 0) {
                    const startPoint = drawingPoints[0];
                    const distToStart = Math.sqrt(Math.pow(line.x1 - startPoint.x, 2) + Math.pow(line.y1 - startPoint.y, 2));
                    isStartPoint = distToStart < 5; // ÂßãÁÇπ„Å®Âêå„Åò‰ΩçÁΩÆ„Å™„Çâ
                }
                
                const distStart = Math.sqrt(Math.pow(x - line.x1, 2) + Math.pow(y - line.y1, 2));
                const distEnd = Math.sqrt(Math.pow(x - line.x2, 2) + Math.pow(y - line.y2, 2));
                
                // ÂßãÁÇπ‰ª•Â§ñ„ÅÆÊó¢Â≠ò„ÅÆÁÇπ„Çí„Çø„ÉÉ„Éó„Åó„ÅüÂ†¥Âêà„ÅØÁÑ°Ë¶ñ
                if (!isStartPoint && distStart < clickRadius) {
                    return;
                }
                if (distEnd < clickRadius) {
                    return;
                }
            }
            
            // „ÉÄ„Éñ„É´„Çø„ÉÉ„ÉóÂà§ÂÆö
            const currentTime = new Date().getTime();
            const timeDiff = currentTime - lastTapTime;
            lastTapTime = currentTime;
            
            if (timeDiff < 500 && drawingPoints.length > 0) {
                finishDrawing();
                return;
            }
            
            // ÁÇπ„ÇíËøΩÂä†
            drawingPoints.push({ x, y });
            
            // 2ÁÇπ‰ª•‰∏ä„ÅÇ„Çå„Å∞Á∑ö„Çí‰ΩúÊàê
            if (drawingPoints.length >= 2) {
                const prevPoint = drawingPoints[drawingPoints.length - 2];
                const currPoint = drawingPoints[drawingPoints.length - 1];
                
                const id = String.fromCharCode(65 + lines.length);
                lines.push({
                    id: id,
                    x1: prevPoint.x,
                    y1: prevPoint.y,
                    x2: currPoint.x,
                    y2: currPoint.y,
                    name: `Ëæ∫${id}`,
                    start: 'wall',
                    end: 'wall'
                });
                
                // „Ç≥„Éº„Éä„Éº„ÅÆËá™ÂãïË®≠ÂÆö
                autoSetCorners();
            }
            
            drawLines();
            updateDrawingControls();
        }
        
        // „Çø„ÉÉ„ÉÅÁßªÂãïÊôÇ„ÅÆ„Éó„É¨„Éì„É•„Éº
        function handleTouchDrawingMove(e) {
            if (drawingPoints.length === 0) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let x = (touch.clientX - rect.left) * scaleX;
            let y = (touch.clientY - rect.top) * scaleY;
            
            // „Çπ„Éä„ÉÉ„ÉóÂá¶ÁêÜ
            const lastPoint = drawingPoints[drawingPoints.length - 1];
            const snapped = snapToAxis(lastPoint.x, lastPoint.y, x, y);
            x = snapped.x;
            y = snapped.y;
            
            drawLines();
            
            // ÂßãÁÇπ„Å∏„ÅÆ„Ç¨„Ç§„Éâ„É©„Ç§„É≥„Å®Âê∏ÁùÄÔºà3ÁÇπ‰ª•‰∏ä„ÅÇ„ÇãÂ†¥ÂêàÔºâ
            let snapToStart = false;
            if (drawingPoints.length >= 3) {
                const startPoint = drawingPoints[0];
                const threshold = 15; // „Çø„ÉÉ„ÉÅÊìç‰Ωú„ÅØÂ∞ë„ÅóÂ∫É„ÇÅ„Å´
                
                // Ê∞¥Âπ≥„Ç¨„Ç§„Éâ„É©„Ç§„É≥ÔºàYÂ∫ßÊ®ô„ÅåÂßãÁÇπ„Å®Ëøë„ÅÑÂ†¥ÂêàÔºâ
                if (Math.abs(y - startPoint.y) < threshold) {
                    // ÂßãÁÇπ„Å´Âêë„Åã„Å£„Å¶Ê∞¥Âπ≥Á∑ö„ÇíÂºï„Åè
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(x, startPoint.y);
                    ctx.lineTo(startPoint.x, startPoint.y);
                    ctx.stroke();
                    
                    // YÂ∫ßÊ®ô„ÇíÂßãÁÇπ„Å´Âêà„Çè„Åõ„Çã
                    y = startPoint.y;
                    
                    // XÂ∫ßÊ®ô„ÇÇÂßãÁÇπ„Å®Ëøë„ÅÑÂ†¥Âêà„ÅØÂê∏ÁùÄ
                    if (Math.abs(x - startPoint.x) < threshold) {
                        x = startPoint.x;
                        snapToStart = true;
                    }
                }
                
                // ÂûÇÁõ¥„Ç¨„Ç§„Éâ„É©„Ç§„É≥ÔºàXÂ∫ßÊ®ô„ÅåÂßãÁÇπ„Å®Ëøë„ÅÑÂ†¥ÂêàÔºâ
                if (Math.abs(x - startPoint.x) < threshold) {
                    // ÂßãÁÇπ„Å´Âêë„Åã„Å£„Å¶ÂûÇÁõ¥Á∑ö„ÇíÂºï„Åè
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(startPoint.x, y);
                    ctx.lineTo(startPoint.x, startPoint.y);
                    ctx.stroke();
                    
                    // XÂ∫ßÊ®ô„ÇíÂßãÁÇπ„Å´Âêà„Çè„Åõ„Çã
                    x = startPoint.x;
                    
                    // YÂ∫ßÊ®ô„ÇÇÂßãÁÇπ„Å®Ëøë„ÅÑÂ†¥Âêà„ÅØÂê∏ÁùÄ
                    if (Math.abs(y - startPoint.y) < threshold) {
                        y = startPoint.y;
                        snapToStart = true;
                    }
                }
                
                // ÂßãÁÇπ„Å®ÂêàËá¥„Åó„ÅüÂ†¥Âêà„ÄÅÂßãÁÇπ„ÇíÂ§ß„Åç„ÅèË°®Á§∫
                if (snapToStart) {
                    ctx.fillStyle = '#f59e0b';
                    ctx.beginPath();
                    ctx.arc(startPoint.x, startPoint.y, 10, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ÁôΩ„ÅÑÁ∏ÅÂèñ„Çä
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
            
            // ÈÄöÂ∏∏„ÅÆ„Ç¨„Ç§„Éâ„É©„Ç§„É≥Ôºà90Â∫¶Ôºâ
            if (!snapToStart) {
                // Ê∞¥Âπ≥„Ç¨„Ç§„Éâ„É©„Ç§„É≥
                if (Math.abs(y - lastPoint.y) < 30) {
                    ctx.strokeStyle = '#10b981';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.moveTo(0, lastPoint.y);
                    ctx.lineTo(canvas.width, lastPoint.y);
                    ctx.stroke();
                }
                
                // ÂûÇÁõ¥„Ç¨„Ç§„Éâ„É©„Ç§„É≥
                if (Math.abs(x - lastPoint.x) < 30) {
                    ctx.strokeStyle = '#10b981';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.moveTo(lastPoint.x, 0);
                    ctx.lineTo(lastPoint.x, canvas.height);
                    ctx.stroke();
                }
            }
            
            // „Éó„É¨„Éì„É•„ÉºÁ∑ö
            ctx.strokeStyle = snapToStart ? '#f59e0b' : '#667eea';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(lastPoint.x, lastPoint.y);
            ctx.lineTo(x, y);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        // ‰ΩúÂõ≥ÁµÇ‰∫Ü
        function finishDrawing() {
            drawingPoints = [];
            drawLines();
            
            // ‰ΩúÂõ≥Áî®„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíÂâäÈô§
            canvas.removeEventListener('click', handleCanvasClick);
            canvas.removeEventListener('mousemove', handleCanvasMouseMove);
            canvas.removeEventListener('touchstart', handleTouchDrawing);
            canvas.removeEventListener('touchmove', handleTouchDrawingMove);
            
            // ÁÇπ„ÇØ„É™„ÉÉ„ÇØÁî®„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíË®≠ÂÆö
            canvas.addEventListener('click', handlePointClick);
            canvas.addEventListener('touchend', handlePointClickTouch);
            
            if (lines.length > 0) {
                createInputs();
            }
            
            updateDrawingControls();
        }
        
        // ÁÇπ„ÅÆ„ÇØ„É™„ÉÉ„ÇØÂá¶ÁêÜ
        function handlePointClick(e) {
            if (isDrawing || isDragging) return;
            if (drawingPoints.length > 0) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.offsetX || e.clientX - rect.left) * scaleX;
            const y = (e.offsetY || e.clientY - rect.top) * scaleY;
            
            const clickRadius = 20;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                const distStart = Math.sqrt(Math.pow(x - line.x1, 2) + Math.pow(y - line.y1, 2));
                if (distStart < clickRadius) {
                    // ÂÖ•ÂäõÊ¨Ñ„Å´„Çπ„ÇØ„É≠„Éº„É´&„Éè„Ç§„É©„Ç§„Éà„ÅÆ„ÅøÔºàÁä∂ÊÖãÂ§âÊõ¥„Åó„Å™„ÅÑÔºâ
                    scrollToInput(line.id);
                    return;
                }
                
                const distEnd = Math.sqrt(Math.pow(x - line.x2, 2) + Math.pow(y - line.y2, 2));
                if (distEnd < clickRadius) {
                    // ÂÖ•ÂäõÊ¨Ñ„Å´„Çπ„ÇØ„É≠„Éº„É´&„Éè„Ç§„É©„Ç§„Éà„ÅÆ„ÅøÔºàÁä∂ÊÖãÂ§âÊõ¥„Åó„Å™„ÅÑÔºâ
                    scrollToInput(line.id);
                    return;
                }
                
                // Á∑ö„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Åü„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                const distToLine = distanceToLineSegment(x, y, line.x1, line.y1, line.x2, line.y2);
                if (distToLine < 10) {
                    // ÂÖ•ÂäõÊ¨Ñ„Å´„Çπ„ÇØ„É≠„Éº„É´&„Éè„Ç§„É©„Ç§„Éà
                    scrollToInput(line.id);
                    return;
                }
            }
        }
        
        // ÁÇπ„Åã„ÇâÁ∑öÂàÜ„Å∏„ÅÆÊúÄÁü≠Ë∑ùÈõ¢„ÇíË®àÁÆó
        function distanceToLineSegment(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const lengthSquared = dx * dx + dy * dy;
            
            if (lengthSquared === 0) {
                return Math.sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1));
            }
            
            let t = ((px - x1) * dx + (py - y1) * dy) / lengthSquared;
            t = Math.max(0, Math.min(1, t));
            
            const nearestX = x1 + t * dx;
            const nearestY = y1 + t * dy;
            
            return Math.sqrt((px - nearestX) * (px - nearestX) + (py - nearestY) * (py - nearestY));
        }
        
        // ÂÖ•ÂäõÊ¨Ñ„Å´„Çπ„ÇØ„É≠„Éº„É´&„Éè„Ç§„É©„Ç§„Éà
        function scrollToInput(lineId) {
            // DOM„ÅÆÊõ¥Êñ∞„ÇíÂæÖ„Å§
            setTimeout(() => {
                const inputGroup = document.querySelector(`[data-line-id="${lineId}"]`);
                if (inputGroup) {
                    // „Çπ„ÇØ„É≠„Éº„É´
                    inputGroup.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    
                    // „Éè„Ç§„É©„Ç§„ÉàÔºà2ÁßíÈñìÔºâ
                    inputGroup.style.transition = 'background-color 0.3s';
                    inputGroup.style.backgroundColor = '#fef3c7';
                    
                    setTimeout(() => {
                        inputGroup.style.backgroundColor = '';
                    }, 2000);
                }
            }, 100);
        }
        
        // „Ç≥„Éº„Éä„Éº„ÇíËá™ÂãïË®≠ÂÆö
        function autoSetCorners() {
            const tolerance = 5; // Âêå„Åò‰ΩçÁΩÆ„Å®Âà§ÂÆö„Åô„ÇãË∑ùÈõ¢
            
            // Âõ≥ÂΩ¢„ÅåÈñâ„Åò„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØÔºàÊúÄÂàù„ÅÆÁ∑ö„ÅÆÂßãÁÇπ„Å®ÊúÄÂæå„ÅÆÁ∑ö„ÅÆÁµÇÁÇπ„ÅåÂêå„Åò‰ΩçÁΩÆÔºâ
            const isClosed = lines.length > 0 && 
                Math.abs(lines[0].x1 - lines[lines.length - 1].x2) < tolerance && 
                Math.abs(lines[0].y1 - lines[lines.length - 1].y2) < tolerance;
            
            // ÂÖ®„Å¶„ÅÆÁÇπ„Çí„ÉÅ„Çß„ÉÉ„ÇØ
            for (let i = 0; i < lines.length; i++) {
                for (let j = i + 1; j < lines.length; j++) {
                    const line1 = lines[i];
                    const line2 = lines[j];
                    
                    // line1„ÅÆÂßãÁÇπ„Å®line2„ÅÆÂßãÁÇπ„ÅåÂêå„Åò‰ΩçÁΩÆ
                    if (Math.abs(line1.x1 - line2.x1) < tolerance && Math.abs(line1.y1 - line2.y1) < tolerance) {
                        // 90Â∫¶„Åã„Å©„ÅÜ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                        if (is90Degrees(line1, line2, 'start', 'start')) {
                            // ÊúÄÂàù„ÅÆÁ∑ö„ÅÆÂßãÁÇπ„ÅØ„Ç≥„Éº„Éä„Éº„Å´„Åó„Å™„ÅÑÔºàÈñâ„Åò„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØÈô§„ÅèÔºâ
                            if (i !== 0 || isClosed) line1.start = 'corner';
                            if (j !== 0 || isClosed) line2.start = 'corner';
                        } else {
                            // 90Â∫¶„Åß„Å™„ÅÑÂ†¥Âêà„ÅØÈÄöÂ∏∏„ÅÆÈÄ£Âãï
                            if ((i !== 0 || isClosed) && line1.start === 'corner') line2.start = 'corner';
                            if ((j !== 0 || isClosed) && line2.start === 'corner') line1.start = 'corner';
                        }
                    }
                    
                    // line1„ÅÆÂßãÁÇπ„Å®line2„ÅÆÁµÇÁÇπ„ÅåÂêå„Åò‰ΩçÁΩÆ
                    if (Math.abs(line1.x1 - line2.x2) < tolerance && Math.abs(line1.y1 - line2.y2) < tolerance) {
                        // 90Â∫¶„Åã„Å©„ÅÜ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                        if (is90Degrees(line1, line2, 'start', 'end')) {
                            if (i !== 0 || isClosed) line1.start = 'corner';
                            // ÊúÄÂæå„ÅÆÁ∑ö„ÅÆÁµÇÁÇπ„ÅØ„Ç≥„Éº„Éä„Éº„Å´„Åó„Å™„ÅÑÔºàÈñâ„Åò„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØÈô§„ÅèÔºâ
                            if (j !== lines.length - 1 || isClosed) line2.end = 'corner';
                        } else {
                            if ((i !== 0 || isClosed) && line1.start === 'corner') line2.end = 'corner';
                            if ((j !== lines.length - 1 || isClosed) && line2.end === 'corner') line1.start = 'corner';
                        }
                    }
                    
                    // line1„ÅÆÁµÇÁÇπ„Å®line2„ÅÆÂßãÁÇπ„ÅåÂêå„Åò‰ΩçÁΩÆ
                    if (Math.abs(line1.x2 - line2.x1) < tolerance && Math.abs(line1.y2 - line2.y1) < tolerance) {
                        // 90Â∫¶„Åã„Å©„ÅÜ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                        if (is90Degrees(line1, line2, 'end', 'start')) {
                            // ÊúÄÂæå„ÅÆÁ∑ö„ÅÆÁµÇÁÇπ„ÅØ„Ç≥„Éº„Éä„Éº„Å´„Åó„Å™„ÅÑÔºàÈñâ„Åò„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØÈô§„ÅèÔºâ
                            if (i !== lines.length - 1 || isClosed) line1.end = 'corner';
                            if (j !== 0 || isClosed) line2.start = 'corner';
                        } else {
                            if ((i !== lines.length - 1 || isClosed) && line1.end === 'corner') line2.start = 'corner';
                            if ((j !== 0 || isClosed) && line2.start === 'corner') line1.end = 'corner';
                        }
                    }
                    
                    // line1„ÅÆÁµÇÁÇπ„Å®line2„ÅÆÁµÇÁÇπ„ÅåÂêå„Åò‰ΩçÁΩÆ
                    if (Math.abs(line1.x2 - line2.x2) < tolerance && Math.abs(line1.y2 - line2.y2) < tolerance) {
                        // 90Â∫¶„Åã„Å©„ÅÜ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                        if (is90Degrees(line1, line2, 'end', 'end')) {
                            // ÊúÄÂæå„ÅÆÁ∑ö„ÅÆÁµÇÁÇπ„ÅØ„Ç≥„Éº„Éä„Éº„Å´„Åó„Å™„ÅÑÔºàÈñâ„Åò„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØÈô§„ÅèÔºâ
                            if (i !== lines.length - 1 || isClosed) line1.end = 'corner';
                            if (j !== lines.length - 1 || isClosed) line2.end = 'corner';
                        } else {
                            if ((i !== lines.length - 1 || isClosed) && line1.end === 'corner') line2.end = 'corner';
                            if ((j !== lines.length - 1 || isClosed) && line2.end === 'corner') line1.end = 'corner';
                        }
                    }
                }
            }
        }
        
        // 2„Å§„ÅÆÁ∑ö„Åå90Â∫¶„Åã„Å©„ÅÜ„ÅãÂà§ÂÆö
        function is90Degrees(line1, line2, point1, point2) {
            // Á∑ö1„ÅÆÊñπÂêë„Éô„ÇØ„Éà„É´
            const dx1 = line1.x2 - line1.x1;
            const dy1 = line1.y2 - line1.y1;
            
            // Á∑ö2„ÅÆÊñπÂêë„Éô„ÇØ„Éà„É´
            const dx2 = line2.x2 - line2.x1;
            const dy2 = line2.y2 - line2.y1;
            
            // ÂÜÖÁ©ç„ÇíË®àÁÆóÔºà90Â∫¶„Å™„Çâ0„Å´Ëøë„ÅÑÔºâ
            const dotProduct = dx1 * dx2 + dy1 * dy2;
            const magnitude1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
            const magnitude2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
            
            if (magnitude1 === 0 || magnitude2 === 0) return false;
            
            const cosAngle = dotProduct / (magnitude1 * magnitude2);
            
            // 90Â∫¶„ÅÆÂ†¥Âêà„ÄÅcos„ÅØ0„Å´Ëøë„ÅÑÔºàË®±ÂÆπË™§Â∑Æ0.1Ôºâ
            return Math.abs(cosAngle) < 0.1;
        }

        // Êñú„ÇÅ„Ç≥„Éº„Éä„Éº„Åã„Å©„ÅÜ„ÅãÂà§ÂÆöÔºàNEW - v1.12.0Ôºâ
        function isDiagonalCorner(line1, line2, point1, point2) {
            // 90Â∫¶„ÅÆÂ†¥Âêà„ÅØfalseÔºàÊñú„ÇÅ„Ç≥„Éº„Éä„Éº„Åß„ÅØ„Å™„ÅÑÔºâ
            if (is90Degrees(line1, line2, point1, point2)) {
                return false;
            }
            
            // Á∑ö1„Åæ„Åü„ÅØÁ∑ö2„ÅåÊñú„ÇÅÁ∑ö„ÅÆÂ†¥Âêà„ÄÅÊñú„ÇÅ„Ç≥„Éº„Éä„Éº
            const line1IsDiagonal = isLineDiagonal(line1);
            const line2IsDiagonal = isLineDiagonal(line2);
            
            return line1IsDiagonal || line2IsDiagonal;
        }
        
        // ÁÇπ„ÅÆÁä∂ÊÖã„ÇíÂàá„ÇäÊõø„Åà
        function togglePointState(lineIndex, point) {
            const line = lines[lineIndex];
            
            // „Åì„ÅÆÁÇπ„ÅÆ„Ç≥„Éº„Éä„Éº„Ç≠„Éº„ÇíÂèñÂæó
            const x = point === 'start' ? line.x1 : line.x2;
            const y = point === 'start' ? line.y1 : line.y2;
            const cornerKey = findCornerKey(x, y, 5);
            const corner = corners[cornerKey];
            
            // Âõ≥ÂΩ¢„ÅåÈñâ„Åò„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØÔºàÊúÄÂàù„ÅÆÁ∑ö„ÅÆÂßãÁÇπ„Å®ÊúÄÂæå„ÅÆÁ∑ö„ÅÆÁµÇÁÇπ„ÅåÂêå„Åò‰ΩçÁΩÆÔºâ
            const isClosed = lines.length > 0 && 
                Math.abs(lines[0].x1 - lines[lines.length - 1].x2) < 5 && 
                Math.abs(lines[0].y1 - lines[lines.length - 1].y2) < 5;
            
            // ÊúÄÂàù„ÅÆÁ∑ö„ÅÆÂßãÁÇπ„ÅØ„Ç≥„Éº„Éä„Éº„Å´„Å™„Çå„Å™„ÅÑÔºàÈñâ„Åò„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØÈô§„ÅèÔºâ
            const isFirstLineStart = (lineIndex === 0 && point === 'start' && !isClosed);
            
            // ÊúÄÂæå„ÅÆÁ∑ö„ÅÆÁµÇÁÇπ„ÅØ„Ç≥„Éº„Éä„Éº„Å´„Å™„Çå„Å™„ÅÑÔºàÈñâ„Åò„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØÈô§„ÅèÔºâ
            const isLastLineEnd = (lineIndex === lines.length - 1 && point === 'end' && !isClosed);
            
            // ÊÆµÂ∑Æ„Åå„ÅÇ„Çã„Ç≥„Éº„Éä„Éº„ÅÆÂ†¥Âêà„ÅØ„ÄÅ„Ç≥„Éº„Éä„ÉºÈÅ∏Êäû„ÇíÈô§Â§ñ
            const hasStepAtCorner = corner && corner.hasStep;
            
            // ÈÅ∏ÊäûÂèØËÉΩ„Å™Áä∂ÊÖã„ÇíÊ±∫ÂÆö
            let states;
            if (isFirstLineStart || isLastLineEnd || hasStepAtCorner) {
                states = ['end', 'wall'];
            } else {
                states = ['corner', 'end', 'wall'];
            }
            
            const currentState = lines[lineIndex][point] || 'wall';
            const currentIndex = states.indexOf(currentState);
            const nextIndex = (currentIndex + 1) % states.length;
            lines[lineIndex][point] = states[nextIndex];
            
            // „Ç≥„Éº„Éä„Éº„Å´Â§âÊõ¥„Åó„ÅüÂ†¥Âêà„ÄÅÂêå„Åò‰ΩçÁΩÆ„ÅÆÁÇπ„ÇÇÈÄ£Âãï
            if (lines[lineIndex][point] === 'corner') {
                autoSetCorners();
            }
            
            // ÊÆµÂ∑Æ„Åå„ÅÇ„Çã„Ç≥„Éº„Éä„Éº„ÅßÁä∂ÊÖã„ÇíÂ§âÊõ¥„Åó„ÅüÂ†¥Âêà„ÄÅÊé•Á∂ö„Åó„Å¶„ÅÑ„ÇãËæ∫„ÅÆÁä∂ÊÖã„ÇíËá™ÂãïË™øÊï¥
            if (corner && corner.hasStep && corner.lines.length >= 2) {
                syncCornerStatesWithStep(cornerKey, line.id, point, lines[lineIndex][point]);
            }
        }
        
        
        function handleTouch(e) {
            e.preventDefault();
            const touch = e.touches[0] || e.changedTouches[0];
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (touch.clientX - rect.left) * scaleX;
            const y = (touch.clientY - rect.top) * scaleY;
            
            if (e.type === 'touchstart') {
                startDrawing({ offsetX: x, offsetY: y });
            } else if (e.type === 'touchmove') {
                drawing({ offsetX: x, offsetY: y });
            } else if (e.type === 'touchend') {
                endDrawing({ offsetX: x, offsetY: y });
            }
        }
        
        function startDrawing(e) {
            isDrawing = true;
            isDragging = false; // „Éâ„É©„ÉÉ„Ç∞ÈñãÂßãÊôÇ„ÅØfalse
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            startPoint = { 
                x: (e.offsetX || e.clientX - rect.left) * scaleX, 
                y: (e.offsetY || e.clientY - rect.top) * scaleY 
            };
        }
        
        function drawing(e) {
            if (!isDrawing) return;
            
            isDragging = true; // „Éû„Ç¶„ÇπÁßªÂãï„Åó„Åü„Çâ„Éâ„É©„ÉÉ„Ç∞‰∏≠
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.offsetX || e.clientX - rect.left) * scaleX;
            const y = (e.offsetY || e.clientY - rect.top) * scaleY;
            
            // Êó¢Â≠ò„ÅÆÁ∑ö„ÇíÊèèÁîª
            drawLines();
            
            // „Éó„É¨„Éì„É•„ÉºÁ∑ö„ÇíÊèèÁîª
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(startPoint.x, startPoint.y);
            ctx.lineTo(x, y);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        function endDrawing(e) {
            if (!isDrawing) return;
            
            // „Éâ„É©„ÉÉ„Ç∞„Åó„Å¶„ÅÑ„ÅüÂ†¥Âêà„ÅÆ„ÅøÁ∑ö„ÇíÂºï„Åè
            if (isDragging) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.offsetX || e.clientX - rect.left) * scaleX;
                const y = (e.offsetY || e.clientY - rect.top) * scaleY;
                
                const id = String.fromCharCode(65 + lines.length);
                lines.push({
                    id: id,
                    x1: startPoint.x,
                    y1: startPoint.y,
                    x2: x,
                    y2: y,
                    name: `Ëæ∫${id}`,
                    start: 'wall', // „Éá„Éï„Ç©„É´„Éà„ÅØÂ£Å
                    end: 'wall'    // „Éá„Éï„Ç©„É´„Éà„ÅØÂ£Å
                });
                
                drawLines();
                createInputs(); // Á∑ö„ÇíÂºï„ÅÑ„ÅüÂæå„Å´ÂÖ•Âäõ„Éï„Ç©„Éº„É†„Çí‰ΩúÊàê
            }
            
            isDrawing = false;
            isDragging = false;
        }
        
        // „Éë„Çø„Éº„É≥‰øùÂ≠ò
        function savePattern() {
            const name = prompt('„Éë„Çø„Éº„É≥Âêç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ:');
            if (!name) return;
            
            const savedPatterns = JSON.parse(localStorage.getItem('savedPatterns') || '{}');
            savedPatterns[name] = {
                lines: lines,
                dimensions: dimensions
            };
            localStorage.setItem('savedPatterns', JSON.stringify(savedPatterns));
            
            alert('„Éë„Çø„Éº„É≥„Çí‰øùÂ≠ò„Åó„Åæ„Åó„Åü');
        }
        
        // ‰øùÂ≠òÊ∏à„Åø„Éë„Çø„Éº„É≥Ë™≠„ÅøËæº„Åø
        function loadSavedPatterns() {
            const savedPatterns = JSON.parse(localStorage.getItem('savedPatterns') || '{}');
            const keys = Object.keys(savedPatterns);
            
            if (keys.length === 0) return;
            
            document.getElementById('saved-patterns-section').style.display = 'block';
            const grid = document.getElementById('saved-patterns-grid');
            grid.innerHTML = '';
            
            keys.forEach(name => {
                const btn = document.createElement('button');
                btn.className = 'pattern-btn';
                btn.innerHTML = `
                    ${name}
                    <span class="delete-btn" onclick="event.stopPropagation(); deletePattern('${name}')">√ó</span>
                `;
                btn.onclick = () => selectPattern(name);
                grid.appendChild(btn);
            });
        }
        
        // „Ç´„Çπ„Çø„É†„Éë„Çø„Éº„É≥Ë™≠„ÅøËæº„Åø
        function loadCustomPattern(name) {
            const savedPatterns = JSON.parse(localStorage.getItem('savedPatterns') || '{}');
            const pattern = savedPatterns[name];
            
            if (!pattern) return;
            
            document.getElementById('pattern-title').textContent = name;
            lines = pattern.lines;
            dimensions = pattern.dimensions || {};
            
            drawLines();
            createInputs();
        }
        
        // „Éë„Çø„Éº„É≥ÂâäÈô§
        function deletePattern(name) {
            if (!confirm(`„Äå${name}„Äç„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü`)) return;
            
            const savedPatterns = JSON.parse(localStorage.getItem('savedPatterns') || '{}');
            delete savedPatterns[name];
            localStorage.setItem('savedPatterns', JSON.stringify(savedPatterns));
            
            loadSavedPatterns();
        }
        
        // „ÇØ„É™„Ç¢ÔºàÂÖ®ÂâäÈô§Ôºâ
        // „ÇØ„É™„Ç¢ÔºàÂÖ®ÂâäÈô§Ôºâ
        
        // ÊúÄÂæå„ÅÆÁ∑ö„ÇíÂâäÈô§
        function undoLastLine() {
            if (lines.length === 0) return;
            
            // ‰ΩúÂõ≥ÁµÇ‰∫ÜÂæåÔºàdrawingPoints„ÅåÁ©∫Ôºâ„ÅÆÂ†¥Âêà„ÅØ„ÄÅdrawingPoints„ÇíÂæ©ÂÖÉ„Åó„Å¶„Åã„ÇâÂâäÈô§
            if (drawingPoints.length === 0 && lines.length > 0) {
                // ÂÖ®„Å¶„ÅÆÁÇπ„ÇídrawingPoints„Å´Âæ©ÂÖÉ
                drawingPoints = [];
                
                // ÊúÄÂàù„ÅÆÁ∑ö„ÅÆÂßãÁÇπ„ÇíËøΩÂä†
                drawingPoints.push({ x: lines[0].x1, y: lines[0].y1 });
                
                // ÂÖ®„Å¶„ÅÆÁ∑ö„ÅÆÁµÇÁÇπ„ÇíËøΩÂä†
                for (let i = 0; i < lines.length; i++) {
                    drawingPoints.push({ x: lines[i].x2, y: lines[i].y2 });
                }
                
                // ÁÇπ„ÇØ„É™„ÉÉ„ÇØÁî®„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíÂâäÈô§
                canvas.removeEventListener('click', handlePointClick);
                canvas.removeEventListener('touchend', handlePointClickTouch);
                
                // ‰ΩúÂõ≥Áî®„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíÂÜçË®≠ÂÆö
                canvas.addEventListener('click', handleCanvasClick);
                canvas.addEventListener('mousemove', handleCanvasMouseMove);
                canvas.addEventListener('touchstart', handleTouchDrawing);
                canvas.addEventListener('touchmove', handleTouchDrawingMove);
            }
            
            // ÊúÄÂæå„ÅÆÁ∑ö„ÇíÂâäÈô§
            const lastLineId = lines[lines.length - 1].id;
            lines.pop();
            delete dimensions[lastLineId];
            
            // drawingPoints„Åã„ÇâÊúÄÂæå„ÅÆÁÇπ„ÇíÂâäÈô§Ôºà1„Å§Ââç„ÅÆÁÇπ„Åã„ÇâÂÜçÈñã„Åß„Åç„Çã„Çà„ÅÜ„Å´Ôºâ
            if (drawingPoints.length > 1) {
                drawingPoints.pop();
            }
            
            drawLines();
            createInputs();
            calculate();
            updateDrawingControls();
        }
        
        // „ÇØ„É™„Ç¢Ôºà„Åô„Åπ„Å¶„É™„Çª„ÉÉ„ÉàÔºâ
        function clearDrawing() {
            // Á¢∫Ë™ç„ÉÄ„Ç§„Ç¢„É≠„Ç∞„ÇíË°®Á§∫
            if (lines.length > 0 && !confirm('„Åô„Åπ„Å¶„ÅÆ‰ΩúÂõ≥„Çí„ÇØ„É™„Ç¢„Åó„Åæ„Åô„ÅãÔºü')) {
                return;
            }
            
            // „Åô„Åπ„Å¶„Çí„É™„Çª„ÉÉ„Éà
            lines = [];
            dimensions = {};
            drawingPoints = [];
            corners = {};
            commonWidth = null;
            
            // „Ç≠„É£„É≥„Éê„Çπ„Çí„ÇØ„É™„Ç¢
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ÂÖ•Âäõ„Éï„Ç©„Éº„É†„Çí„ÇØ„É™„Ç¢
            document.getElementById('dimension-inputs').innerHTML = '';
            
            // Ë®àÁÆóÁµêÊûú„Çí„ÇØ„É™„Ç¢
            document.getElementById('results-content').innerHTML = '<p style="color: #999; text-align: center;">ÂØ∏Ê≥ï„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ</p>';
            
            // „Ç≥„É≥„Éà„É≠„Éº„É´„ÇíÈùûË°®Á§∫
            updateDrawingControls();
            
            // Ëá™Áî±‰ΩúÂõ≥„ÅÆÂ†¥Âêà„ÅØ„ÄÅ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíÂÜçË®≠ÂÆö
            if (currentPattern === 'custom') {
                // Êó¢Â≠ò„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„Çí„Åô„Åπ„Å¶ÂâäÈô§
                canvas.removeEventListener('click', handlePointClick);
                canvas.removeEventListener('touchend', handlePointClickTouch);
                
                // ‰ΩúÂõ≥Áî®„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíÂÜçË®≠ÂÆö
                canvas.addEventListener('click', handleCanvasClick);
                canvas.addEventListener('mousemove', handleCanvasMouseMove);
                canvas.addEventListener('touchstart', handleTouchDrawing);
                canvas.addEventListener('touchmove', handleTouchDrawingMove);
            } else {
                // Âü∫Êú¨„Éë„Çø„Éº„É≥„ÅÆÂ†¥Âêà„ÅØ„ÄÅ„Éë„Çø„Éº„É≥„ÇíÂÜç‰ΩúÊàê
                selectPattern(currentPattern);
            }
        }
        
        // ÊèèÁîª„Ç≥„É≥„Éà„É≠„Éº„É´„ÅÆË°®Á§∫„ÉªÈùûË°®Á§∫
        function updateDrawingControls() {
            const controls = document.getElementById('drawing-controls');
            if (controls) {
                controls.style.display = (drawingPoints.length > 0 || currentPattern === 'custom') ? 'flex' : 'none';
            }
        }
        
        // Êàª„Çã
        function backToSelect() {
            document.getElementById('pattern-select-screen').style.display = 'block';
            document.getElementById('measurement-screen').style.display = 'none';
            loadSavedPatterns();
        }
        
        // „ÇØ„É™„Ç¢Ê©üËÉΩ
        function clearAll() {
            // Á¢∫Ë™ç„ÉÄ„Ç§„Ç¢„É≠„Ç∞
            if (!confirm('„Åô„Åπ„Å¶„ÅÆ‰ΩúÂõ≥„Å®ÂÖ•ÂäõÂÜÖÂÆπ„Çí„ÇØ„É™„Ç¢„Åó„Åæ„Åô„ÅãÔºü')) {
                return;
            }
            
            // Á∑ö„Çí„ÇØ„É™„Ç¢
            lines = [];
            
            // ÂØ∏Ê≥ïÂÖ•Âäõ„Çí„ÇØ„É™„Ç¢
            dimensions = {};
            
            // ‰ΩúÂõ≥ÁÇπ„Çí„ÇØ„É™„Ç¢
            drawingPoints = [];
            
            // „Ç≥„Éº„Éä„Éº„Çí„ÇØ„É™„Ç¢
            corners = {};
            
            // ÂÖ±ÈÄöÂπÖ„Çí„ÇØ„É™„Ç¢
            commonWidth = null;
            
            // „Ç≠„É£„É≥„Éê„Çπ„Çí„ÇØ„É™„Ç¢
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ÂÖ•Âäõ„Éï„Ç©„Éº„É†„Çí„ÇØ„É™„Ç¢
            document.getElementById('dimension-inputs').innerHTML = '';
            
            // Ë®àÁÆóÁµêÊûú„Çí„ÇØ„É™„Ç¢
            document.getElementById('results-content').innerHTML = '<p style="color: #999; text-align: center;">ÂØ∏Ê≥ï„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ</p>';
            
            // „Ç≥„É≥„Éà„É≠„Éº„É´„Éú„Çø„É≥„ÇíÈùûË°®Á§∫
            updateDrawingControls();
            
            // „Éë„Çø„Éº„É≥„ÇíÂÜç‰ΩúÊàê
            if (currentPattern === 'IÂ≠ó') {
                createIPattern();
            } else if (currentPattern === 'Â∑¶LÂ≠ó') {
                createLPatternLeft();
            } else if (currentPattern === 'Âè≥LÂ≠ó') {
                createLPatternRight();
            } else if (currentPattern === '„Ç≥„ÅÆÂ≠ó') {
                createUPattern();
            } else if (currentPattern === 'custom') {
                setupCustomDrawing();
            }
        }
        
        // ==============================================
        // ‰øùÂ≠ò„ÉªÂÖ±ÊúâÊ©üËÉΩ
        // ==============================================
        
        // ‰øùÂ≠ò„É¢„Éº„Éâ„ÅÆÂàá„ÇäÊõø„Åà
        // „Éï„Ç°„Ç§„É´Âêç„ÇíÂèñÂæóÔºàÊó•‰ªò„ÅÆ„ÅøÔºâ
        function getFilename() {
            const date = new Date().toISOString().slice(0, 10);
            return `kutai-keisoku_${date}`;
        }
        
        // PDF„Å®„Åó„Å¶‰øùÂ≠ò
        async function downloadAsPDF() {
            const measurementScreen = document.getElementById('measurement-screen');
            if (!measurementScreen || measurementScreen.style.display === 'none') {
                alert('Ë®àÁÆóÁµêÊûú„Åå„ÅÇ„Çä„Åæ„Åõ„Çì');
                return;
            }
            
            try {
                let canvas, titleText;
                
                // „Éö„Éº„Ç∏ÂÖ®‰ΩìÔºöcontainer„Çí„Ç≠„É£„Éó„ÉÅ„É£
                const container = measurementScreen.querySelector('.container');
                if (!container) {
                    canvas = await html2canvas(measurementScreen, {
                        scale: 2,
                        backgroundColor: '#ffffff',
                        logging: false
                    });
                } else {
                    canvas = await html2canvas(container, {
                        scale: 2,
                        backgroundColor: '#ffffff',
                        logging: false
                    });
                }
                titleText = 'Ë∫Ø‰ΩìÊé°ÂØ∏„Ç∑„Çπ„ÉÜ„É†';
                
                // jsPDF„Çí‰ΩøÁî®„Åó„Å¶PDF„Çí‰ΩúÊàê
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF({
                    orientation: 'portrait',
                    unit: 'mm',
                    format: 'a4'
                });
                
                // „Ç≠„É£„É≥„Éê„Çπ„ÇíÁîªÂÉè„Å®„Åó„Å¶ÂèñÂæó
                const imgData = canvas.toDataURL('image/png');
                
                // A4„Çµ„Ç§„Ç∫„Å´Âêà„Çè„Åõ„Å¶ÁîªÂÉè„ÇíÈÖçÁΩÆ
                const pageWidth = 210; // A4ÂπÖ
                const pageHeight = 297; // A4È´ò„Åï
                const margin = 10;
                const imgWidth = pageWidth - margin * 2; // ‰∏°ÂÅ¥„Éû„Éº„Ç∏„É≥
                const imgHeight = (canvas.height * imgWidth) / canvas.width;
                const maxHeight = pageHeight - margin * 2 - 25; // „Éû„Éº„Ç∏„É≥ + „Éò„ÉÉ„ÉÄ„ÉºÂàÜ
                
                // „Çø„Ç§„Éà„É´„ÇíËøΩÂä†
                pdf.setFontSize(16);
                pdf.text(titleText, pageWidth / 2, 15, { align: 'center' });
                
                // Êó•‰ªò„ÇíËøΩÂä†
                const date = new Date().toLocaleDateString('ja-JP');
                pdf.setFontSize(10);
                pdf.text(date, pageWidth / 2, 22, { align: 'center' });
                
                // PDF„Çí1„Éö„Éº„Ç∏„Å´Âèé„ÇÅ„Çã„Çà„ÅÜ„Å´Á∏ÆÂ∞è
                let finalImgWidth, finalImgHeight;
                
                if (imgHeight <= maxHeight) {
                    // „Åù„ÅÆ„Åæ„Åæ„ÅÆ„Çµ„Ç§„Ç∫„ÅßÂèé„Åæ„Çã
                    finalImgWidth = imgWidth;
                    finalImgHeight = imgHeight;
                } else {
                    // Á∏ÆÂ∞è„Åó„Å¶1„Éö„Éº„Ç∏„Å´Âèé„ÇÅ„Çã
                    finalImgHeight = maxHeight;
                    finalImgWidth = (canvas.width * finalImgHeight) / canvas.height;
                    
                    // ÂπÖ„Åå„ÅØ„ÅøÂá∫„ÇãÂ†¥Âêà„ÅØ„ÄÅÂπÖÂü∫Ê∫ñ„ÅßÁ∏ÆÂ∞è
                    if (finalImgWidth > imgWidth) {
                        finalImgWidth = imgWidth;
                        finalImgHeight = (canvas.height * finalImgWidth) / canvas.width;
                    }
                }
                
                // ‰∏≠Â§ÆÈÖçÁΩÆ
                const xOffset = margin + (imgWidth - finalImgWidth) / 2;
                pdf.addImage(imgData, 'PNG', xOffset, 30, finalImgWidth, finalImgHeight);
                
                // „Éï„Ç°„Ç§„É´Âêç„ÇíÁîüÊàê
                const filename = getFilename() + '.pdf';
                
                // PDF„Çí‰øùÂ≠ò
                pdf.save(filename);
                
            } catch (error) {
                console.error('PDF‰øùÂ≠ò„Ç®„É©„Éº:', error);
                alert('PDF„ÅÆ‰øùÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
            }
        }
        
        // PNG„Å®„Åó„Å¶‰øùÂ≠ò
        async function downloadAsPNG() {
            const measurementScreen = document.getElementById('measurement-screen');
            if (!measurementScreen || measurementScreen.style.display === 'none') {
                alert('Ë®àÁÆóÁµêÊûú„Åå„ÅÇ„Çä„Åæ„Åõ„Çì');
                return;
            }
            
            try {
                let canvas;
                
                // „Éö„Éº„Ç∏ÂÖ®‰ΩìÔºöcontainer„Çí„Ç≠„É£„Éó„ÉÅ„É£
                const container = measurementScreen.querySelector('.container');
                if (!container) {
                    canvas = await html2canvas(measurementScreen, {
                        scale: 2,
                        backgroundColor: '#ffffff',
                        logging: false
                    });
                } else {
                    canvas = await html2canvas(container, {
                        scale: 2,
                        backgroundColor: '#ffffff',
                        logging: false
                    });
                }
                
                // „Ç≠„É£„É≥„Éê„Çπ„ÇíÁîªÂÉè„Å®„Åó„Å¶ÂèñÂæó
                const imgData = canvas.toDataURL('image/png');
                
                // „ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„É™„É≥„ÇØ„Çí‰ΩúÊàê
                const link = document.createElement('a');
                link.download = getFilename() + '.png';
                link.href = imgData;
                link.click();
                
            } catch (error) {
                console.error('PNG‰øùÂ≠ò„Ç®„É©„Éº:', error);
                alert('ÁîªÂÉè„ÅÆ‰øùÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
            }
        }
        
        // ÂÖ±ÊúâÊ©üËÉΩÔºàWeb Share API‰ΩøÁî®Ôºâ
        async function shareResult() {
            const measurementScreen = document.getElementById('measurement-screen');
            if (!measurementScreen || measurementScreen.style.display === 'none') {
                alert('Ë®àÁÆóÁµêÊûú„Åå„ÅÇ„Çä„Åæ„Åõ„Çì');
                return;
            }
            
            try {
                // Web Share API„ÅåÂà©Áî®ÂèØËÉΩ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                if (!navigator.share && !navigator.canShare) {
                    // Web Share API„Åå‰Ωø„Åà„Å™„ÅÑÂ†¥Âêà„ÄÅPNG„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„ÇíÂÆüË°å
                    alert('„Åì„ÅÆÁ´ØÊú´„Åß„ÅØÂÖ±ÊúâÊ©üËÉΩ„Åå‰Ωø„Åà„Åæ„Åõ„Çì„ÄÇÁîªÂÉè„Å®„Åó„Å¶‰øùÂ≠ò„Åó„Åæ„Åô„ÄÇ');
                    downloadAsPNG();
                    return;
                }
                
                let canvas;
                
                // „Éö„Éº„Ç∏ÂÖ®‰ΩìÔºöcontainer„Çí„Ç≠„É£„Éó„ÉÅ„É£
                const container = measurementScreen.querySelector('.container');
                if (!container) {
                    canvas = await html2canvas(measurementScreen, {
                        scale: 2,
                        backgroundColor: '#ffffff',
                        logging: false
                    });
                } else {
                    canvas = await html2canvas(container, {
                        scale: 2,
                        backgroundColor: '#ffffff',
                        logging: false
                    });
                }
                
                // „Ç≠„É£„É≥„Éê„Çπ„ÇíBlob„Å´Â§âÊèõ
                canvas.toBlob(async (blob) => {
                    try {
                        const file = new File([blob], getFilename() + '.png', { type: 'image/png' });
                        
                        const shareData = {
                            title: 'Ë∫Ø‰ΩìÊé°ÂØ∏„Ç∑„Çπ„ÉÜ„É†',
                            text: 'Ë∫Ø‰ΩìÊé°ÂØ∏„ÅÆ‰ΩúÂõ≥„Å®Ë®àÁÆóÁµêÊûú„Åß„Åô',
                            files: [file]
                        };
                        
                        // ÂÖ±ÊúâÂèØËÉΩ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                        if (navigator.canShare && !navigator.canShare(shareData)) {
                            // „Éï„Ç°„Ç§„É´ÂÖ±Êúâ„Åå„Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÄÅ„ÉÜ„Ç≠„Çπ„Éà„ÅÆ„ÅøÂÖ±Êúâ
                            await navigator.share({
                                title: shareData.title,
                                text: shareData.text,
                                url: window.location.href
                            });
                        } else {
                            // „Éï„Ç°„Ç§„É´„ÇíÂê´„ÇÅ„Å¶ÂÖ±Êúâ
                            await navigator.share(shareData);
                        }
                        
                    } catch (shareError) {
                        if (shareError.name !== 'AbortError') {
                            console.error('ÂÖ±Êúâ„Ç®„É©„Éº:', shareError);
                            alert('ÂÖ±Êúâ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇÁîªÂÉè„Å®„Åó„Å¶‰øùÂ≠ò„Åó„Åæ„Åô„ÄÇ');
                            downloadAsPNG();
                        }
                    }
                }, 'image/png');
                
            } catch (error) {
                console.error('ÂÖ±Êúâ„Ç®„É©„Éº:', error);
                alert('ÂÖ±Êúâ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇÁîªÂÉè„Å®„Åó„Å¶‰øùÂ≠ò„Åó„Åæ„Åô„ÄÇ');
                downloadAsPNG();
            }
        }
        
        // „Éû„Éã„É•„Ç¢„É´„É¢„Éº„ÉÄ„É´„ÇíÈñã„Åè
        function openManual() {
            document.getElementById('manual-modal').style.display = 'block';
            document.body.style.overflow = 'hidden'; // „Çπ„ÇØ„É≠„Éº„É´ÁÑ°ÂäπÂåñ
        }
        
        // „Éû„Éã„É•„Ç¢„É´„É¢„Éº„ÉÄ„É´„ÇíÈñâ„Åò„Çã
        function closeManual() {
            document.getElementById('manual-modal').style.display = 'none';
            document.body.style.overflow = 'auto'; // „Çπ„ÇØ„É≠„Éº„É´ÊúâÂäπÂåñ
        }
        
        // „É¢„Éº„ÉÄ„É´Â§ñ„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Åü„ÇâÈñâ„Åò„Çã
        window.onclick = function(event) {
            const modal = document.getElementById('manual-modal');
            if (event.target === modal) {
                closeManual();
            }
        }
    </script>
    
    <!-- „Éû„Éã„É•„Ç¢„É´„É¢„Éº„ÉÄ„É´ -->
    <div id="manual-modal" class="manual-modal">
        <div class="manual-content">
            <button class="manual-close" onclick="closeManual()">√ó</button>
            
            <h1>üì± Ë∫Ø‰ΩìÊé°ÂØ∏„Ç∑„Çπ„ÉÜ„É† ‰Ωø„ÅÑÊñπ„Éû„Éã„É•„Ç¢„É´</h1>
            
            <h2>üéØ „Åì„ÅÆ„Ç∑„Çπ„ÉÜ„É†„Å´„Å§„ÅÑ„Å¶</h2>
            <p><strong>Â§ñÊ≥ïÂØ∏Ê≥ï„Åã„ÇâË∫Ø‰ΩìËäØÂØ∏Ê≥ï„ÇíËá™ÂãïË®àÁÆó„Åó„Åæ„Åô„ÄÇ</strong></p>
            <p>ÁèæÂ†¥„ÅßÊ∏¨„Å£„ÅüÂØ∏Ê≥ï„ÇíÂÖ•Âäõ„Åô„Çã„Å®„ÄÅÊñΩÂ∑•„Å´ÂøÖË¶Å„Å™ËäØÂØ∏Ê≥ï„ÅåËá™Âãï„ÅßË®àÁÆó„Åï„Çå„Åæ„Åô„ÄÇ</p>
            
            <h2>üìù Âü∫Êú¨ÁöÑ„Å™ÊµÅ„Çå</h2>
            <ol>
                <li><strong>„Éë„Çø„Éº„É≥„ÇíÈÅ∏„Å∂</strong> - IÂ≠ó„ÄÅLÂ≠ó„ÄÅ„Ç≥„ÅÆÂ≠ó„ÄÅ„Åæ„Åü„ÅØËá™Áî±‰ΩúÂõ≥</li>
                <li><strong>ÂØ∏Ê≥ï„ÇíÂÖ•Âäõ„Åô„Çã</strong> - Â§ñÊ≥ïÂØ∏Ê≥ï„ÄÅË∫Ø‰ΩìÂπÖ„ÄÅË∫Ø‰ΩìÈ´ò„Åï</li>
                <li><strong>Ë®àÁÆóÁµêÊûú„ÇíÁ¢∫Ë™ç„Åô„Çã</strong> - Ë∫Ø‰ΩìËäØÂØ∏Ê≥ï„ÅåËá™ÂãïË®àÁÆó„Åï„Çå„Çã</li>
                <li><strong>‰øùÂ≠ò„ÉªÂÖ±Êúâ„Åô„Çã</strong> - PDF„ÄÅÁîªÂÉè„ÄÅ„Åæ„Åü„ÅØLINE„Å™„Å©„ÅßÂÖ±Êúâ</li>
            </ol>
            
            <h2>‚úèÔ∏è ÂØ∏Ê≥ï„ÅÆÂÖ•ÂäõÊñπÊ≥ï</h2>
            
            <h3>Â§ñÊ≥ïÂØ∏Ê≥ï</h3>
            <ul>
                <li>ÂêÑËæ∫„ÅÆÈï∑„Åï„ÇíÂÖ•ÂäõÔºàmmÂçò‰ΩçÔºâ</li>
                <li>ÂÆüÈöõ„Å´Ê∏¨„Å£„ÅüÂØ∏Ê≥ï„Çí„Åù„ÅÆ„Åæ„ÅæÂÖ•Âäõ</li>
            </ul>
            
            <h3>Ë∫Ø‰ΩìÂπÖ</h3>
            <ul>
                <li>ÂÖ®„Å¶„ÅÆËæ∫„Å´ÂÖ±ÈÄö„ÅÆÂπÖ„ÇíË®≠ÂÆö</li>
                <li>„Åæ„Åü„ÅØ„ÄåËæ∫„Åî„Å®„Å´Ë∫Ø‰ΩìÂπÖ„ÇíË®≠ÂÆö„Äç„Å´„ÉÅ„Çß„ÉÉ„ÇØ„Åó„Å¶ÂÄãÂà•Ë®≠ÂÆö</li>
            </ul>
            
            <h3>Ë∫Ø‰ΩìÈ´ò„Åï</h3>
            <ul>
                <li>ÂÖ®‰Ωì„ÅÆÈ´ò„Åï„ÇíÂÖ•ÂäõÔºàmmÂçò‰ΩçÔºâ</li>
            </ul>
            
            <h2>‚úèÔ∏è Ëá™Áî±‰ΩúÂõ≥„ÅÆ‰Ωø„ÅÑÊñπ</h2>
            
            <h3>Á∑ö„ÅÆÂºï„ÅçÊñπ</h3>
            <ol>
                <li><strong>ÊúÄÂàù„ÅÆÁÇπ„Çí„ÇØ„É™„ÉÉ„ÇØ</strong> - Á∑ö„ÅÆÂßãÁÇπ„ÅåÈÖçÁΩÆ„Åï„Çå„ÇãÔºàÁ∑ë„ÅÆÁÇπÔºâ</li>
                <li><strong>Ê¨°„ÅÆÁÇπ„Çí„ÇØ„É™„ÉÉ„ÇØ</strong> - Ââç„ÅÆÁÇπ„Åã„ÇâÁ∑ö„ÅåÂºï„Åã„Çå„ÇãÔºàÁ∑ë„ÅÆÁÇπÔºâ</li>
                <li><strong>„Åï„Çâ„Å´ÁÇπ„Çí„ÇØ„É™„ÉÉ„ÇØ</strong> - Á∂ö„Åë„Å¶Á∑ö„ÇíÂºï„Åë„Çã</li>
                <li><strong>„Äå‚úì ‰ΩúÂõ≥ÁµÇ‰∫Ü„Äç„Çí„ÇØ„É™„ÉÉ„ÇØ</strong> - ‰ΩúÂõ≥„ÇíÂÆå‰∫Ü</li>
            </ol>
            
            <h3>„Éú„Çø„É≥„ÅÆË™¨Êòé</h3>
            <ul>
                <li><strong>‚Ü∂ Êàª„Çã</strong> - ÊúÄÂæå„Å´Âºï„ÅÑ„ÅüÁ∑ö„ÇíÂâäÈô§Ôºà‰ΩïÂ∫¶„Åß„ÇÇÊàª„Çå„ÇãÔºâ</li>
                <li><strong>üóëÔ∏è „ÇØ„É™„Ç¢</strong> - ÂÖ®„Å¶„ÅÆÁ∑ö„ÇíÂâäÈô§„Åó„Å¶„ÇÑ„ÇäÁõ¥„Åô</li>
                <li><strong>‚úì ‰ΩúÂõ≥ÁµÇ‰∫Ü</strong> - Á∑ö„ÇíÂºï„ÅçÁµÇ„Çè„Å£„Åü„ÇâÂøÖ„Åö„ÇØ„É™„ÉÉ„ÇØ</li>
            </ul>
            
            <h3>„Ç≥„ÉÑ</h3>
            <ul>
                <li>ÈñìÈÅï„Åà„Åü„Çâ„Äå‚Ü∂ Êàª„Çã„Äç„Åß1„Å§„Åö„Å§Ê∂à„Åõ„Çã</li>
                <li>ÂÖ®ÈÉ®„ÇÑ„ÇäÁõ¥„Åó„Åü„ÅÑ„Å®„Åç„ÅØ„ÄåüóëÔ∏è „ÇØ„É™„Ç¢„Äç</li>
                <li>‰ΩúÂõ≥„ÅåÁµÇ„Çè„Å£„Åü„ÇâÂøÖ„Åö„Äå‚úì ‰ΩúÂõ≥ÁµÇ‰∫Ü„Äç„Çí„ÇØ„É™„ÉÉ„ÇØ</li>
                <li>‰ΩúÂõ≥ÁµÇ‰∫ÜÂæå„ÄÅÂØ∏Ê≥ïÂÖ•ÂäõÁîªÈù¢„Å´Âàá„ÇäÊõø„Çè„Çã</li>
            </ul>
            
            <h2>üî¥ ÁÇπ„ÅÆÁ®ÆÈ°û„Å´„Å§„ÅÑ„Å¶ÔºàÈáçË¶ÅÔºâ</h2>
            <p>Ë®àÁÆóÁµêÊûú„ÅØÁÇπ„ÅÆÁ®ÆÈ°û„Å´„Çà„Å£„Å¶Â§â„Çè„Çä„Åæ„ÅôÔºö</p>
            
            <h3>üî¥ Ëµ§Ôºà„Ç≥„Éº„Éä„ÉºÔºâ</h3>
            <ul>
                <li>2„Å§„ÅÆËæ∫„ÅåÊé•Á∂ö„Åô„ÇãËßí</li>
                <li><strong>‰∏°ÂÅ¥„ÅÆËæ∫„ÅÆÂπÖ„ÅÆÂçäÂàÜ„Åö„Å§„ÇíÂºï„Åè</strong></li>
                <li>‰æãÔºöLÂ≠ó„ÅÆËßí„ÄÅ„Ç≥„ÅÆÂ≠ó„ÅÆËßí</li>
            </ul>
            
            <h3>üîµ ÈùíÔºà„Ç®„É≥„ÉâÔºâ</h3>
            <ul>
                <li>Ëæ∫„ÅÆÁ´ØÁÇπÔºàÂ£Å„Å™„ÅóÔºâ</li>
                <li><strong>Èö£Êé•„Åô„ÇãËæ∫„ÅÆÂπÖ„ÇíÂºï„Åã„Å™„ÅÑ</strong></li>
                <li>ÊÆµÂ∑Æ„Åå„ÅÇ„ÇãÂ†¥Âêà„Å´‰ΩøÁî®</li>
            </ul>
            
            <h3>üü¢ Á∑ëÔºàÂ£ÅÔºâ</h3>
            <ul>
                <li>Â£Å„ÇÑÊÆµÂ∑Æ„Å´Êé•„Åô„ÇãÁÇπ</li>
                <li><strong>Èö£Êé•„Åô„ÇãËæ∫„ÅÆÂπÖ„ÇíÂºï„Åã„Å™„ÅÑ</strong></li>
            </ul>
            
            <h3>ÁÇπ„ÅÆÂ§âÊõ¥ÊñπÊ≥ï</h3>
            <p>‰ΩúÂõ≥ÁîªÈù¢„ÅÆÁÇπ„Çí„ÇØ„É™„ÉÉ„ÇØ„Åô„Çã„Å®„ÄÅËµ§ ‚Üí Èùí ‚Üí Á∑ë ‚Üí Ëµ§...„Å®Âæ™Áí∞„Åó„Å¶Â§âÊõ¥„Åß„Åç„Åæ„Åô„ÄÇ</p>
            
            <h2>üìè ÊÆµÂ∑Æ„ÅÆË®≠ÂÆöÊñπÊ≥ï</h2>
            
            <h3>ÊÆµÂ∑Æ„Åå„ÅÇ„ÇãÂ†¥Âêà</h3>
            <ol>
                <li><strong>„ÄåÊÆµÂ∑Æ„ÅÇ„Çä„Äç„Å´„ÉÅ„Çß„ÉÉ„ÇØ</strong></li>
                <li>ÁÇπ„ÅÆÁ®ÆÈ°û„ÅåËá™ÂãïÁöÑ„Å´Â§â„Çè„ÇãÔºà1„Å§ÁõÆÔºöÈùí„ÄÅ2„Å§ÁõÆÔºöÁ∑ëÔºâ</li>
                <li><strong>Ê∑±„Åï„ÇíÂÖ•Âäõ</strong>ÔºàmmÂçò‰ΩçÔºâ</li>
                <li>„ÉÅ„Çß„ÉÉ„ÇØ„ÇíÂ§ñ„Åô„Å®Ëµ§Ôºà„Ç≥„Éº„Éä„ÉºÔºâ„Å´Êàª„Çã</li>
            </ol>
            
            <h2>üìä Ë®àÁÆóÁµêÊûú„ÅÆË¶ãÊñπ</h2>
            
            <h3>ËäØÂØ∏Ê≥ïÔºàË®àÁÆóÁµêÊûúÔºâ</h3>
            <ul>
                <li>Â§ñÊ≥ïÂØ∏Ê≥ï„Åã„ÇâË∫Ø‰ΩìÂπÖ„ÇíÂºï„ÅÑ„ÅüÂÄ§</li>
                <li>ÁÇπ„ÅÆÁ®ÆÈ°û„Å´„Çà„Å£„Å¶Ë®àÁÆóÊñπÊ≥ï„ÅåÁï∞„Å™„Çã</li>
                <li>ÂÆüÈöõ„ÅÆÊñΩÂ∑•„Åß‰Ωø„ÅÜÂØ∏Ê≥ï</li>
            </ul>
            
            <h3>Ë°®Á§∫ÂÜÖÂÆπ</h3>
            <pre>Ëæ∫A Á∑ë‚îÅËµ§    4710 mm
Ëæ∫B Ëµ§‚îÅÁ∑ë    3429 mm</pre>
            <ul>
                <li><strong>Á∑ë‚îÅËµ§</strong>ÔºöÂßãÁÇπ„ÅåÁ∑ëÔºàÂ£ÅÔºâ„ÄÅÁµÇÁÇπ„ÅåËµ§Ôºà„Ç≥„Éº„Éä„ÉºÔºâ</li>
                <li><strong>4710 mm</strong>ÔºöË®àÁÆó„Åï„Çå„ÅüËäØÂØ∏Ê≥ï</li>
            </ul>
            
            <h3>Ë®àÁÆóÁµêÊûú„ÅÆÂõ≥</h3>
            <ul>
                <li>ÂÆüÂØ∏Ê≥ï„ÅÆÊØîÁéá„ÅßÂõ≥ÂΩ¢„ÇíË°®Á§∫</li>
                <li>ÁÇπ„ÅÆËâ≤„ÅßÁ®ÆÈ°û„ÇíÁ¢∫Ë™ç</li>
                <li>ÂØ∏Ê≥ï„ÅåÈªÑËâ≤„ÅÑÊû†„ÅßË°®Á§∫</li>
            </ul>
            
            <h2>üíæ ‰øùÂ≠ò„ÉªÂÖ±ÊúâÊñπÊ≥ï</h2>
            
            <h3>üìÑ PDF„Åß‰øùÂ≠ò</h3>
            <ul>
                <li>‰ΩúÂõ≥ + ÂÖ•Âäõ + Ë®àÁÆóÁµêÊûú„ÇíPDF„Åß‰øùÂ≠ò</li>
                <li>Âç∞Âà∑„ÇÑË®òÈå≤„Å´‰æøÂà©</li>
            </ul>
            
            <h3>üñºÔ∏è ÁîªÂÉè„Åß‰øùÂ≠ò</h3>
            <ul>
                <li>PNGÂΩ¢Âºè„ÅßÁîªÂÉè„Å®„Åó„Å¶‰øùÂ≠ò</li>
                <li>„Çπ„Éû„Éõ„ÅÆ„Ç´„É°„É©„É≠„Éº„É´„Å´‰øùÂ≠ò„Åï„Çå„Çã</li>
            </ul>
            
            <h3>üì§ ÂÖ±Êúâ</h3>
            <ul>
                <li>LINE„ÇÑ„É°„Éº„É´„ÅßÁõ¥Êé•ÂÖ±Êúâ</li>
                <li>ÁèæÂ†¥„ÅÆÂêåÂÉö„ÇÑ‰∏äÂè∏„Å´ÈÄÅ„Çå„Çã</li>
            </ul>
            
            <h2>üîÑ „ÇÑ„ÇäÁõ¥„Åó„Éª„ÇØ„É™„Ç¢</h2>
            
            <h3>‚Ü∂ Êàª„Çã</h3>
            <ul>
                <li>ÊúÄÂæå„Å´Âºï„ÅÑ„ÅüÁ∑ö„ÇíÂâäÈô§</li>
                <li>‰ΩïÂ∫¶„Åß„ÇÇÊàª„Çå„Çã</li>
            </ul>
            
            <h3>üóëÔ∏è „ÇØ„É™„Ç¢</h3>
            <ul>
                <li>ÂÖ®„Å¶„ÅÆ‰ΩúÂõ≥„Çí„ÇØ„É™„Ç¢</li>
                <li>Á¢∫Ë™ç„ÉÄ„Ç§„Ç¢„É≠„Ç∞„ÅåË°®Á§∫„Åï„Çå„Çã</li>
            </ul>
            
            <h3>‚úì ‰ΩúÂõ≥ÁµÇ‰∫Ü</h3>
            <ul>
                <li>Ëá™Áî±‰ΩúÂõ≥„ÅÆÂ†¥Âêà„ÅÆ„ÅøË°®Á§∫</li>
                <li>‰ΩúÂõ≥„ÇíÂÆå‰∫Ü„Åó„Å¶ÂØ∏Ê≥ïÂÖ•Âäõ„Å∏ÈÄ≤„ÇÄ</li>
            </ul>
            
            <h2>‚ö†Ô∏è „Çà„Åè„ÅÇ„ÇãË≥™Âïè</h2>
            
            <h3>Q1: ÁÇπ„ÅÆËâ≤„ÅåÂ§â„Çè„Çâ„Å™„ÅÑ</h3>
            <p><strong>A:</strong> ‰ΩúÂõ≥ÁîªÈù¢„ÅÆÁÇπ„ÇíÁõ¥Êé•„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÊÆµÂ∑Æ„ÅÇ„Çä„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„Çπ„Å®„ÅØÂà•„Åß„Åô„ÄÇ</p>
            
            <h3>Q2: Ë®àÁÆóÁµêÊûú„ÅåË°®Á§∫„Åï„Çå„Å™„ÅÑ</h3>
            <p><strong>A:</strong> ‰ª•‰∏ã„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö</p>
            <ul>
                <li>Â§ñÊ≥ïÂØ∏Ê≥ï„ÅåÂÖ•Âäõ„Åï„Çå„Å¶„ÅÑ„Çã„Åã</li>
                <li>Ë∫Ø‰ΩìÂπÖ„ÅåÂÖ•Âäõ„Åï„Çå„Å¶„ÅÑ„Çã„Åã</li>
                <li>Ë∫Ø‰ΩìÈ´ò„Åï„ÅåÂÖ•Âäõ„Åï„Çå„Å¶„ÅÑ„Çã„Åã</li>
                <li>ÊÆµÂ∑Æ„ÅÇ„Çä„Å´„ÉÅ„Çß„ÉÉ„ÇØ„Åó„ÅüÂ†¥Âêà„ÄÅÊ∑±„Åï„ÅåÂÖ•Âäõ„Åï„Çå„Å¶„ÅÑ„Çã„Åã</li>
            </ul>
            
            <h3>Q3: ÂÖ±Êúâ„Åå„Åß„Åç„Å™„ÅÑ</h3>
            <p><strong>A:</strong> „Éñ„É©„Ç¶„Ç∂„Å´„Çà„Å£„Å¶Âãï‰Ωú„ÅåÁï∞„Å™„Çä„Åæ„Åô„ÄÇPC„Éñ„É©„Ç¶„Ç∂„ÅÆÂ†¥Âêà„ÅØ„ÄåÁîªÂÉè„Åß‰øùÂ≠ò„Äç„Çí‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
            
            <h3>Q4: ‰ΩúÂõ≥„Åó„ÅüÁ∑ö„ÇíÂâäÈô§„Åó„Åü„ÅÑ</h3>
            <p><strong>A:</strong> „Äå‚Ü∂ Êàª„Çã„Äç„Éú„Çø„É≥„ÅßÊúÄÂæå„ÅÆÁ∑ö„Åã„ÇâÈ†ÜÁï™„Å´ÂâäÈô§„Åß„Åç„Åæ„Åô„ÄÇÂÖ®ÈÉ®Ê∂à„Åó„Åü„ÅÑÂ†¥Âêà„ÅØ„ÄåüóëÔ∏è „ÇØ„É™„Ç¢„Äç„Çí‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
            
            <h3>Q5: Ëá™Áî±‰ΩúÂõ≥„ÅßÁ∑ö„ÇíÂºï„ÅèÊñπÊ≥ï„ÅØÔºü</h3>
            <p><strong>A:</strong> ‰∏äË®ò„ÅÆ„Äå‚úèÔ∏è Ëá™Áî±‰ΩúÂõ≥„ÅÆ‰Ωø„ÅÑÊñπ„Äç„Çí„ÅîË¶ß„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
            
            <h3>Q6: Ë®àÁÆóÁµêÊûú„ÅÆÂÄ§„ÅåÂêà„Çè„Å™„ÅÑ</h3>
            <p><strong>A:</strong> ÁÇπ„ÅÆÁ®ÆÈ°û„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö</p>
            <ul>
                <li><strong>Ëµ§Ôºà„Ç≥„Éº„Éä„ÉºÔºâ</strong>ÔºöÈö£Êé•„Åô„ÇãËæ∫„ÅÆÂπÖ„ÅÆÂçäÂàÜ„ÇíÂºï„Åè</li>
                <li><strong>ÈùíÔºà„Ç®„É≥„ÉâÔºâ</strong>Ôºö‰Ωï„ÇÇÂºï„Åã„Å™„ÅÑ</li>
                <li><strong>Á∑ëÔºàÂ£ÅÔºâ</strong>Ôºö‰Ωï„ÇÇÂºï„Åã„Å™„ÅÑ</li>
            </ul>
            <p>„Ç≥„Éº„Éä„Éº„ÅÆÂ†¥Âêà„ÄÅ‰∏°ÂÅ¥„ÅÆËæ∫„ÅÆÂπÖ„ÅÆÂçäÂàÜ„Åö„Å§Âºï„Åã„Çå„Çã„Åü„ÇÅ„ÄÅ‰∫àÊÉ≥„Çà„ÇäÂ∞è„Åï„Åè„Å™„Çä„Åæ„Åô„ÄÇ</p>
            
            <hr style="margin: 30px 0; border: none; border-top: 2px solid #e5e7eb;">
            
            <p style="text-align: center; color: #6b7280; margin-top: 30px;">‰Ωø„ÅÑÊñπ„ÅßÂõ∞„Å£„Åü„Åì„Å®„Åå„ÅÇ„Çå„Å∞„ÄÅ„Åì„ÅÆÁîªÈù¢„ÇíË¶ãËøî„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
        </div>
    </div>
</body>
</html>
