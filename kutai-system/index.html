<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- ã‚­ãƒ£ãƒƒã‚·ãƒ¥å¯¾ç­– -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
    <title>èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ </title>
    <!--
    ========================================
    èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ 
    ========================================
    ãƒãƒ¼ã‚¸ãƒ§ãƒ³: 1.12.0
    æœ€çµ‚æ›´æ–°: 2024-12-28
    
    [æ›´æ–°å±¥æ­´]
    v1.12.0 (2024-12-28)
    - æ–œã‚ã‚³ãƒ¼ãƒŠãƒ¼ã®è‡ªå‹•æ¤œå‡ºã¨è­¦å‘Šæ©Ÿèƒ½ã‚’è¿½åŠ 
    - ã‚³ãƒ¼ãƒŠãƒ¼è§’åº¦ã®è‡ªå‹•è¨ˆç®—ã¨è¡¨ç¤ºæ©Ÿèƒ½ã‚’è¿½åŠ 
    - ç‚¹ã®ç¨®é¡ã«é–¢ã‚ã‚‰ãšæ–œã‚ã‚³ãƒ¼ãƒŠãƒ¼ã‚’æ¤œå‡º
    - è§’åº¦å…¥åŠ›æ¬„ã‚’ã‚³ãƒ¼ãƒŠãƒ¼ã”ã¨ã«è¿½åŠ ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå¤‰æ›´å¯èƒ½ï¼‰
    
    v1.11.1 (2024-12-27)
    - ä½¿ã„æ–¹ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ã‚’è¿½åŠ ï¼ˆmodalè¡¨ç¤ºï¼‰
    - ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠç”»é¢ã«ã€Œâ“ ä½¿ã„æ–¹ã€ãƒœã‚¿ãƒ³ã‚’è¿½åŠ 
    - æ¡å¯¸ç”»é¢ã«ã‚‚ã€Œâ“ ä½¿ã„æ–¹ã€ãƒœã‚¿ãƒ³ã‚’è¿½åŠ 
    
    v1.11.0 (2024-12-27)
    - ç›´ç·šãŒä¸¦ã‚“ã å ´åˆã«è¨ˆç®—çµæœã®å›³ãŒè¡¨ç¤ºã•ã‚Œãªã„å•é¡Œã‚’ä¿®æ­£
    - ãƒ•ã‚¡ã‚¤ãƒ«åå…¥åŠ›æ¬„ã‚’å‰Šé™¤
    - ä¿å­˜ç¯„å›²ãƒˆã‚°ãƒ«ã‚’å‰Šé™¤
    ========================================
    -->
    <!-- jsPDF ãƒ©ã‚¤ãƒ–ãƒ©ãƒªï¼ˆPDFä¿å­˜ç”¨ï¼‰ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- html2canvas ãƒ©ã‚¤ãƒ–ãƒ©ãƒªï¼ˆãƒšãƒ¼ã‚¸å…¨ä½“ã‚­ãƒ£ãƒ—ãƒãƒ£ç”¨ï¼‰ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, 'Hiragino Kaku Gothic ProN', sans-serif;
            background: #f5f7fa;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 700px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            padding: 40px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }
        
        h1 {
            text-align: center;
            color: #1a1a1a;
            margin-bottom: 40px;
            font-size: 28px;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        
        h2 {
            color: #1a1a1a;
            margin: 30px 0 20px;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            opacity: 0.6;
        }
        
        /* ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠç”»é¢ */
        .pattern-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }
        
        .pattern-btn {
            background: white;
            color: #1a1a1a;
            border: 2px solid #e5e7eb;
            padding: 24px 16px;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            min-height: 110px;
        }
        
        .pattern-btn svg {
            width: 50px;
            height: 50px;
        }
        
        .pattern-btn:hover {
            border-color: #3b82f6;
            background: #f0f9ff;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.15);
        }
        
        .pattern-btn:active {
            transform: translateY(0);
        }
        
        .pattern-btn.custom {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
            grid-column: 1 / -1;
        }
        
        .pattern-btn.custom:hover {
            background: #2563eb;
            border-color: #2563eb;
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.25);
        }
        
        .pattern-btn .delete-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .pattern-btn .delete-btn:hover {
            background: #dc2626;
            transform: scale(1.1);
        }
        
        /* æ¡å¯¸ç”»é¢ */
        .measurement-screen {
            display: none;
        }
        
        .back-btn {
            background: #f3f4f6;
            color: #1a1a1a;
            border: 1px solid #e5e7eb;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 20px;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        
        .back-btn:hover {
            background: #e5e7eb;
            border-color: #d1d5db;
        }
        
        .drawing-area {
            position: relative;
            width: 100%;
            height: 400px;
            background: #f9fafb;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            margin: 20px 0;
            overflow: hidden;
            touch-action: none;
        }
        
        canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }
        
        .dimension-inputs {
            margin: 20px 0;
        }
        
        .dimension-item {
            background: #f9fafb;
            padding: 16px;
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            margin-bottom: 12px;
        }
        
        .dimension-item label {
            display: block;
            color: #1a1a1a;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .dimension-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .dimension-row input {
            padding: 10px 12px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            font-size: 15px;
            transition: all 0.2s ease;
        }
        
        .dimension-row input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        .results {
            background: #f9fafb;
            padding: 20px;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            margin-top: 20px;
        }
        
        .result-item {
            padding: 12px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .result-label {
            color: #555;
            font-weight: bold;
        }
        
        .result-value {
            color: #667eea;
            font-weight: bold;
            font-size: 18px;
        }
        
        .save-pattern-btn {
            width: 100%;
            background: #10b981;
            color: white;
            border: none;
            padding: 14px;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.2s ease;
        }
        
        .save-pattern-btn:hover {
            background: #059669;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.25);
        }
        
        .alert {
            background: #fff3cd;
            color: #856404;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #ffc107;
        }
        
        .success {
            background: #d4edda;
            color: #155724;
            border-left-color: #28a745;
        }
        
        /* ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ãƒ¢ãƒ¼ãƒ€ãƒ« */
        .manual-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            overflow-y: auto;
        }
        
        .manual-content {
            background: white;
            max-width: 800px;
            margin: 20px auto;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        
        .manual-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #ef4444;
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .manual-close:hover {
            background: #dc2626;
            transform: scale(1.1);
        }
        
        .manual-content h1 {
            color: #1e40af;
            border-bottom: 3px solid #3b82f6;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        
        .manual-content h2 {
            color: #2563eb;
            margin-top: 30px;
            margin-bottom: 15px;
        }
        
        .manual-content h3 {
            color: #3b82f6;
            margin-top: 20px;
            margin-bottom: 10px;
        }
        
        .manual-content pre {
            background: #f3f4f6;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            border-left: 4px solid #3b82f6;
        }
        
        .manual-content ul, .manual-content ol {
            padding-left: 25px;
            line-height: 1.8;
        }
        
        .manual-content li {
            margin-bottom: 8px;
        }
        
        .manual-content strong {
            color: #1e40af;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠç”»é¢ -->
        <div id="pattern-select-screen">
            <h1>èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ </h1>
            
            <!-- ä½¿ã„æ–¹ãƒœã‚¿ãƒ³ -->
            <div style="margin-bottom: 20px; text-align: center;">
                <button onclick="openManual()" 
                   style="display: inline-block; padding: 10px 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; font-weight: bold; font-size: 14px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); cursor: pointer;">
                    â“ ä½¿ã„æ–¹
                </button>
            </div>
            
            <h2>åŸºæœ¬ãƒ‘ã‚¿ãƒ¼ãƒ³</h2>
            <div class="pattern-grid">
                <button class="pattern-btn" onclick="selectPattern('i')">
                    <svg viewBox="0 0 60 60">
                        <line x1="10" y1="30" x2="50" y2="30" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                    </svg>
                    Iå­—
                </button>
                <button class="pattern-btn" onclick="selectPattern('l-left')">
                    <svg viewBox="0 0 60 60">
                        <line x1="15" y1="10" x2="15" y2="50" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                        <line x1="15" y1="10" x2="45" y2="10" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                    </svg>
                    å·¦Lå­—
                </button>
                <button class="pattern-btn" onclick="selectPattern('l-right')">
                    <svg viewBox="0 0 60 60">
                        <line x1="45" y1="10" x2="45" y2="50" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                        <line x1="15" y1="10" x2="45" y2="10" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                    </svg>
                    å³Lå­—
                </button>
                <button class="pattern-btn" onclick="selectPattern('u')">
                    <svg viewBox="0 0 60 60">
                        <line x1="15" y1="50" x2="15" y2="10" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                        <line x1="15" y1="10" x2="45" y2="10" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                        <line x1="45" y1="10" x2="45" y2="50" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                    </svg>
                    ã‚³ã®å­—
                </button>
            </div>
            
            <div id="saved-patterns-section" style="display: none;">
                <h2>ä¿å­˜æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³</h2>
                <div class="pattern-grid" id="saved-patterns-grid"></div>
            </div>
            
            <h2>ã‚«ã‚¹ã‚¿ãƒ ä½œå›³</h2>
            <div class="pattern-grid">
                <button class="pattern-btn custom" onclick="selectPattern('custom')">è‡ªç”±ã«ç·šã‚’å¼•ã</button>
            </div>
            
            <!-- ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ± -->
            <div style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #e5e7eb; text-align: center; color: #6b7280; font-size: 13px;">
                <div style="margin-bottom: 5px;">èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ  v1.12.0</div>
                <div>æœ€çµ‚æ›´æ–°: 2024-12-28</div>
            </div>
        </div>
        
        <!-- æ¡å¯¸ç”»é¢ -->
        <div id="measurement-screen" class="measurement-screen">
            <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                <button id="back-btn" class="back-btn" onclick="backToSelect()" style="flex: 2;">â† ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠã«æˆ»ã‚‹</button>
                <button onclick="openManual()" 
                   style="flex: 1; display: flex; align-items: center; justify-content: center; padding: 12px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; font-weight: bold; font-size: 14px; cursor: pointer;">
                    â“ ä½¿ã„æ–¹
                </button>
            </div>
            
            <h1 id="pattern-title">æ¡å¯¸å…¥åŠ›</h1>
            
            <div id="alert" class="alert" style="display: none;"></div>
            
            <div class="drawing-area">
                <canvas id="canvas"></canvas>
            </div>
            
            <div id="drawing-controls" style="display: none; margin-top: 10px; display: flex; gap: 10px; flex-wrap: wrap;">
                <button onclick="clearDrawing()" style="flex: 1; min-width: 120px; padding: 12px; background: #ef4444; color: white; border: none; border-radius: 8px; font-size: 15px; font-weight: 600; cursor: pointer; transition: all 0.2s ease;">ğŸ—‘ï¸ ã‚¯ãƒªã‚¢</button>
                <button onclick="undoLastLine()" style="flex: 1; min-width: 120px; padding: 12px; background: #f59e0b; color: white; border: none; border-radius: 8px; font-size: 15px; font-weight: 600; cursor: pointer; transition: all 0.2s ease;">â†¶ æˆ»ã‚‹</button>
                <button onclick="finishDrawing()" style="flex: 1; min-width: 120px; padding: 12px; background: #10b981; color: white; border: none; border-radius: 8px; font-size: 15px; font-weight: 600; cursor: pointer; transition: all 0.2s ease;">âœ“ ä½œå›³çµ‚äº†</button>
            </div>
            
            <div class="dimension-inputs" id="dimension-inputs"></div>
            
            <div class="results">
                <h2>è¨ˆç®—çµæœ</h2>
                <div id="results-content">
                    <p style="color: #999; text-align: center;">å¯¸æ³•ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„</p>
                </div>
            </div>
            
            <button class="save-pattern-btn" onclick="savePattern()">ã“ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä¿å­˜</button>
        </div>
    </div>
    
    <!-- ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="manual-modal" class="manual-modal">
        <div class="manual-content">
            <button class="manual-close" onclick="closeManual()">Ã—</button>
            
            <h1>ğŸ“± èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ  ä½¿ã„æ–¹ãƒãƒ‹ãƒ¥ã‚¢ãƒ«</h1>
            
            <h2>ğŸ¯ ã“ã®ã‚·ã‚¹ãƒ†ãƒ ã«ã¤ã„ã¦</h2>
            <p><strong>å¤–æ³•å¯¸æ³•ã‹ã‚‰èº¯ä½“èŠ¯å¯¸æ³•ã‚’è‡ªå‹•è¨ˆç®—ã—ã¾ã™ã€‚</strong></p>
            <p>ç¾å ´ã§æ¸¬ã£ãŸå¯¸æ³•ã‚’å…¥åŠ›ã™ã‚‹ã¨ã€æ–½å·¥ã«å¿…è¦ãªèŠ¯å¯¸æ³•ãŒè‡ªå‹•ã§è¨ˆç®—ã•ã‚Œã¾ã™ã€‚</p>
            
            <h2>ğŸ“ åŸºæœ¬çš„ãªæµã‚Œ</h2>
            <ol>
                <li><strong>ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’é¸ã¶</strong> - Iå­—ã€Lå­—ã€ã‚³ã®å­—ã€ã¾ãŸã¯è‡ªç”±ä½œå›³</li>
                <li><strong>å¯¸æ³•ã‚’å…¥åŠ›ã™ã‚‹</strong> - å¤–æ³•å¯¸æ³•ã€èº¯ä½“å¹…ã€èº¯ä½“é«˜ã•</li>
                <li><strong>è¨ˆç®—çµæœã‚’ç¢ºèªã™ã‚‹</strong> - èº¯ä½“èŠ¯å¯¸æ³•ãŒè‡ªå‹•è¨ˆç®—ã•ã‚Œã‚‹</li>
                <li><strong>ä¿å­˜ãƒ»å…±æœ‰ã™ã‚‹</strong> - PDFã€ç”»åƒã€ã¾ãŸã¯LINEãªã©ã§å…±æœ‰</li>
            </ol>
            
            <h2>ğŸ”´ ç‚¹ã®ç¨®é¡ã«ã¤ã„ã¦ï¼ˆé‡è¦ï¼‰</h2>
            <p>è¨ˆç®—çµæœã¯ç‚¹ã®ç¨®é¡ã«ã‚ˆã£ã¦å¤‰ã‚ã‚Šã¾ã™ï¼š</p>
            
            <h3>ğŸ”´ èµ¤ï¼ˆã‚³ãƒ¼ãƒŠãƒ¼ï¼‰</h3>
            <ul>
                <li>2ã¤ã®è¾ºãŒæ¥ç¶šã™ã‚‹è§’</li>
                <li><strong>ä¸¡å´ã®è¾ºã®å¹…ã®åŠåˆ†ãšã¤ã‚’å¼•ã</strong></li>
            </ul>
            
            <h3>ğŸ”µ é’ï¼ˆã‚¨ãƒ³ãƒ‰ï¼‰</h3>
            <ul>
                <li>è¾ºã®ç«¯ç‚¹ï¼ˆå£ãªã—ï¼‰</li>
                <li><strong>éš£æ¥ã™ã‚‹è¾ºã®å¹…ã‚’å¼•ã‹ãªã„</strong></li>
            </ul>
            
            <h3>ğŸŸ¢ ç·‘ï¼ˆå£ï¼‰</h3>
            <ul>
                <li>å£ã‚„æ®µå·®ã«æ¥ã™ã‚‹ç‚¹</li>
                <li><strong>éš£æ¥ã™ã‚‹è¾ºã®å¹…ã‚’å¼•ã‹ãªã„</strong></li>
            </ul>
            
            <h2>âš ï¸ ã‚ˆãã‚ã‚‹è³ªå•</h2>
            
            <h3>Q1: ç‚¹ã®è‰²ãŒå¤‰ã‚ã‚‰ãªã„</h3>
            <p><strong>A:</strong> ä½œå›³ç”»é¢ã®ç‚¹ã‚’ç›´æ¥ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚</p>
            
            <h3>Q2: è¨ˆç®—çµæœãŒè¡¨ç¤ºã•ã‚Œãªã„</h3>
            <p><strong>A:</strong> å¤–æ³•å¯¸æ³•ã€èº¯ä½“å¹…ã€èº¯ä½“é«˜ã•ãŒã™ã¹ã¦å…¥åŠ›ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚</p>
            
            <hr style="margin: 30px 0; border: none; border-top: 2px solid #e5e7eb;">
            
            <p style="text-align: center; color: #6b7280; margin-top: 30px;">ä½¿ã„æ–¹ã§å›°ã£ãŸã“ã¨ãŒã‚ã‚Œã°ã€ã“ã®ç”»é¢ã‚’è¦‹è¿”ã—ã¦ãã ã•ã„ã€‚</p>
        </div>
    </div>
    
    <script>
        let currentPattern = null;
        let lines = [];
        let dimensions = {};
        let isDrawing = false;
        let isDragging = false;
        let startPoint = null;
        let canvas, ctx;
        let drawingPoints = [];
        let lastClickTime = 0;
        let lastTapTime = 0;
        let commonWidth = null;
        let useIndividualWidth = false;
        let commonHeight = null;
        let corners = {};
        
        // ã‚³ãƒ¼ãƒŠãƒ¼ã‚’æ¤œå‡º
        function detectCorners() {
            if (!corners) {
                corners = {};
            }
            
            if (!lines || lines.length === 0) {
                corners = {};
                return;
            }
            
            const newCorners = {};
            const tolerance = 5;
            
            lines.forEach((line, idx) => {
                if (!line) return;
                
                const startKey = findCornerKeyForDetection(line.x1, line.y1, tolerance, newCorners);
                if (!newCorners[startKey]) {
                    const oldCorner = corners[startKey];
                    newCorners[startKey] = { 
                        x: line.x1, 
                        y: line.y1, 
                        hasStep: oldCorner ? oldCorner.hasStep : false, 
                        depth: oldCorner ? oldCorner.depth : null,
                        angle: oldCorner ? oldCorner.angle : null,
                        lines: [] 
                    };
                }
                newCorners[startKey].lines.push({ lineId: line.id, point: 'start' });
                
                const endKey = findCornerKeyForDetection(line.x2, line.y2, tolerance, newCorners);
                if (!newCorners[endKey]) {
                    const oldCorner = corners[endKey];
                    newCorners[endKey] = { 
                        x: line.x2, 
                        y: line.y2, 
                        hasStep: oldCorner ? oldCorner.hasStep : false, 
                        depth: oldCorner ? oldCorner.depth : null,
                        angle: oldCorner ? oldCorner.angle : null,
                        lines: [] 
                    };
                }
                newCorners[endKey].lines.push({ lineId: line.id, point: 'end' });
            });
            
            corners = newCorners;
        }
        
        function findCornerKeyForDetection(x, y, tolerance, cornersObj) {
            for (const key in cornersObj) {
                const corner = cornersObj[key];
                const dist = Math.sqrt(Math.pow(x - corner.x, 2) + Math.pow(y - corner.y, 2));
                if (dist < tolerance) {
                    return key;
                }
            }
            return `${Math.round(x)},${Math.round(y)}`;
        }
        
        function findCornerKey(x, y, tolerance) {
            if (!corners) return `${Math.round(x)},${Math.round(y)}`;
            
            for (const key in corners) {
                const corner = corners[key];
                const dist = Math.sqrt(Math.pow(x - corner.x, 2) + Math.pow(y - corner.y, 2));
                if (dist < tolerance) {
                    return key;
                }
            }
            return `${Math.round(x)},${Math.round(y)}`;
        }
        
        window.onload = function() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            resizeCanvas();
            loadSavedPatterns();
        };
        
        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            if (lines.length > 0) {
                drawLines();
            }
        }
        
        function selectPattern(type) {
            currentPattern = type;
            document.getElementById('pattern-select-screen').style.display = 'none';
            document.getElementById('measurement-screen').style.display = 'block';
            
            setTimeout(resizeCanvas, 100);
            
            lines = [];
            dimensions = {};
            drawingPoints = [];
            commonWidth = null;
            commonHeight = null;
            useIndividualWidth = false;
            
            if (type === 'i') {
                document.getElementById('pattern-title').textContent = 'Iå­—å‹ æ¡å¯¸';
                createIPattern();
            } else if (type === 'l-left') {
                document.getElementById('pattern-title').textContent = 'å·¦Lå­—å‹ æ¡å¯¸';
                createLPatternLeft();
            } else if (type === 'l-right') {
                document.getElementById('pattern-title').textContent = 'å³Lå­—å‹ æ¡å¯¸';
                createLPatternRight();
            } else if (type === 'u') {
                document.getElementById('pattern-title').textContent = 'ã‚³ã®å­—å‹ æ¡å¯¸';
                createUPattern();
            } else if (type === 'custom') {
                document.getElementById('pattern-title').textContent = 'è‡ªç”±ä½œå›³';
                setupCustomDrawing();
            } else {
                loadCustomPattern(type);
            }
        }
        
        function createIPattern() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const lineLength = Math.min(canvas.width, canvas.height) * 0.6;
            
            lines = [
                { 
                    id: 'A', 
                    x1: centerX - lineLength/2, y1: centerY, 
                    x2: centerX + lineLength/2, y2: centerY, 
                    name: 'è¾ºA', 
                    start: 'wall',
                    end: 'wall'
                }
            ];
            drawLines();
            createInputs();
            setupPointClickListener();
        }
        
        function createLPatternLeft() {
            const size = Math.min(canvas.width, canvas.height) * 0.5;
            const margin = Math.min(canvas.width, canvas.height) * 0.2;
            
            lines = [
                { 
                    id: 'A', 
                    x1: margin, y1: margin, 
                    x2: margin, y2: margin + size, 
                    name: 'è¾ºAï¼ˆç¸¦ï¼‰', 
                    start: 'corner',
                    end: 'wall'
                },
                { 
                    id: 'B', 
                    x1: margin, y1: margin, 
                    x2: margin + size, y2: margin, 
                    name: 'è¾ºBï¼ˆæ¨ªï¼‰', 
                    start: 'corner',
                    end: 'wall'
                }
            ];
            drawLines();
            createInputs();
            setupPointClickListener();
        }
        
        function createLPatternRight() {
            const size = Math.min(canvas.width, canvas.height) * 0.5;
            const margin = Math.min(canvas.width, canvas.height) * 0.2;
            
            lines = [
                { 
                    id: 'A', 
                    x1: margin, y1: margin, 
                    x2: margin + size, y2: margin, 
                    name: 'è¾ºAï¼ˆæ¨ªï¼‰', 
                    start: 'wall',
                    end: 'corner'
                },
                { 
                    id: 'B', 
                    x1: margin + size, y1: margin, 
                    x2: margin + size, y2: margin + size, 
                    name: 'è¾ºBï¼ˆç¸¦ï¼‰', 
                    start: 'corner',
                    end: 'wall'
                }
            ];
            drawLines();
            createInputs();
            setupPointClickListener();
        }
        
        function createUPattern() {
            const width = Math.min(canvas.width, canvas.height) * 0.5;
            const height = Math.min(canvas.width, canvas.height) * 0.4;
            const margin = Math.min(canvas.width, canvas.height) * 0.2;
            
            lines = [
                { 
                    id: 'A', 
                    x1: margin, y1: margin + height, 
                    x2: margin, y2: margin, 
                    name: 'è¾ºA', 
                    start: 'wall',
                    end: 'corner'
                },
                { 
                    id: 'B', 
                    x1: margin, y1: margin, 
                    x2: margin + width, y2: margin, 
                    name: 'è¾ºB', 
                    start: 'corner',
                    end: 'corner'
                },
                { 
                    id: 'C', 
                    x1: margin + width, y1: margin, 
                    x2: margin + width, y2: margin + height, 
                    name: 'è¾ºC', 
                    start: 'corner',
                    end: 'wall'
                }
            ];
            drawLines();
            createInputs();
            setupPointClickListener();
        }
        
        function setupPointClickListener() {
            canvas.removeEventListener('click', handlePointClick);
            canvas.removeEventListener('touchend', handlePointClickTouch);
            canvas.addEventListener('click', handlePointClick);
            canvas.addEventListener('touchend', handlePointClickTouch);
        }
        
        function handlePointClickTouch(e) {
            if (isDrawing || isDragging) return;
            if (drawingPoints.length > 0) return;
            
            e.preventDefault();
            const touch = e.changedTouches[0];
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (touch.clientX - rect.left) * scaleX;
            const y = (touch.clientY - rect.top) * scaleY;
            
            const clickRadius = 25;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                const distStart = Math.sqrt(Math.pow(x - line.x1, 2) + Math.pow(y - line.y1, 2));
                if (distStart < clickRadius) {
                    scrollToInput(line.id);
                    return;
                }
                
                const distEnd = Math.sqrt(Math.pow(x - line.x2, 2) + Math.pow(y - line.y2, 2));
                if (distEnd < clickRadius) {
                    scrollToInput(line.id);
                    return;
                }
                
                const distToLine = distanceToLineSegment(x, y, line.x1, line.y1, line.x2, line.y2);
                if (distToLine < 15) {
                    scrollToInput(line.id);
                    return;
                }
            }
        }
        
        function drawLines() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            detectCorners();
            
            if (lines.length === 0) return;
            
            const shouldTransform = currentPattern !== 'custom';
            
            let transform = (x, y) => ({ x, y });
            
            if (shouldTransform) {
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                lines.forEach(line => {
                    minX = Math.min(minX, line.x1, line.x2);
                    minY = Math.min(minY, line.y1, line.y2);
                    maxX = Math.max(maxX, line.x1, line.x2);
                    maxY = Math.max(maxY, line.y1, line.y2);
                });
                
                const shapeWidth = maxX - minX;
                const shapeHeight = maxY - minY;
                const margin = 50;
                const canvasWidth = canvas.width - margin * 2;
                const canvasHeight = canvas.height - margin * 2;
                const scaleX = canvasWidth / shapeWidth;
                const scaleY = canvasHeight / shapeHeight;
                const scale = Math.min(scaleX, scaleY, 1);
                const scaledWidth = shapeWidth * scale;
                const scaledHeight = shapeHeight * scale;
                const offsetX = margin + (canvasWidth - scaledWidth) / 2 - minX * scale;
                const offsetY = margin + (canvasHeight - scaledHeight) / 2 - minY * scale;
                
                transform = (x, y) => ({
                    x: x * scale + offsetX,
                    y: y * scale + offsetY
                });
            }
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 5;
            ctx.lineCap = 'round';
            
            lines.forEach((line, index) => {
                const p1 = transform(line.x1, line.y1);
                const p2 = transform(line.x2, line.y2);
                
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
                
                const midX = (p1.x + p2.x) / 2;
                const midY = (p1.y + p2.y) / 2;
                
                const dim = dimensions[line.id];
                if (dim && dim.length) {
                    ctx.font = 'bold 18px sans-serif';
                    ctx.fillStyle = '#3b82f6';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    const text = `${dim.length}`;
                    const metrics = ctx.measureText(text);
                    const padding = 8;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.fillRect(midX - metrics.width/2 - padding, midY - 12, metrics.width + padding*2, 24);
                    
                    ctx.fillStyle = '#3b82f6';
                    ctx.fillText(text, midX, midY);
                }
                
                ctx.font = 'bold 13px sans-serif';
                const textWidth = ctx.measureText(line.name).width;
                const padding = 8;
                const bgWidth = textWidth + padding * 2;
                const bgHeight = 20;
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.fillRect(midX - bgWidth/2, midY - bgHeight/2 - 35, bgWidth, bgHeight);
                
                ctx.fillStyle = '#333';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(line.name, midX, midY - 35);
            });
            
            const drawnCorners = new Set();
            
            if (corners) {
                for (const cornerKey in corners) {
                    const corner = corners[cornerKey];
                    
                    if (!corner || drawnCorners.has(cornerKey)) continue;
                    drawnCorners.add(cornerKey);
                    
                    if (!corner.lines || corner.lines.length === 0) continue;
                    
                    const firstLineRef = corner.lines[0];
                    const firstLine = lines.find(l => l.id === firstLineRef.lineId);
                    if (!firstLine) continue;
                    
                    const cornerX = corner.x !== undefined ? corner.x : (firstLine[firstLineRef.point === 'start' ? 'x1' : 'x2']);
                    const cornerY = corner.y !== undefined ? corner.y : (firstLine[firstLineRef.point === 'start' ? 'y1' : 'y2']);
                    
                    if (corner.hasStep && corner.lines.length >= 2) {
                        const line1Ref = corner.lines[0];
                        const line2Ref = corner.lines[1];
                        const line1 = lines.find(l => l.id === line1Ref.lineId);
                        const line2 = lines.find(l => l.id === line2Ref.lineId);
                        
                        if (line1 && line2) {
                            const state1 = line1[line1Ref.point] || 'wall';
                            const state2 = line2[line2Ref.point] || 'wall';
                            
                            const offset = 20;
                            
                            let dx1, dy1;
                            if (line1Ref.point === 'start') {
                                dx1 = line1.x2 - line1.x1;
                                dy1 = line1.y2 - line1.y1;
                            } else {
                                dx1 = line1.x1 - line1.x2;
                                dy1 = line1.y1 - line1.y2;
                            }
                            const len1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
                            
                            let dx2, dy2;
                            if (line2Ref.point === 'start') {
                                dx2 = line2.x2 - line2.x1;
                                dy2 = line2.y2 - line2.y1;
                            } else {
                                dx2 = line2.x1 - line2.x2;
                                dy2 = line2.y1 - line2.y2;
                            }
                            const len2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                            
                            if (len1 > 0 && len2 > 0) {
                                const dirX1 = dx1 / len1;
                                const dirY1 = dy1 / len1;
                                const dirX2 = dx2 / len2;
                                const dirY2 = dy2 / len2;
                                
                                const p1 = transform(cornerX + dirX1 * offset, cornerY + dirY1 * offset);
                                const p2 = transform(cornerX + dirX2 * offset, cornerY + dirY2 * offset);
                                
                                drawPoint(p1.x, p1.y, state1);
                                drawPoint(p2.x, p2.y, state2);
                            } else {
                                const p = transform(cornerX, cornerY);
                                drawPoint(p.x, p.y, state1);
                            }
                        }
                    } else {
                        const state = firstLine[firstLineRef.point] || 'wall';
                        const p = transform(cornerX, cornerY);
                        drawPoint(p.x, p.y, state);
                    }
                }
            }
            
            drawingPoints.forEach((point, index) => {
                ctx.fillStyle = '#f39c12';
                ctx.beginPath();
                ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }
        
        function drawPoint(x, y, state) {
            const colors = {
                'corner': '#e74c3c',
                'end': '#3498db',
                'wall': '#2ecc71'
            };
            
            ctx.fillStyle = colors[state] || colors['end'];
            ctx.beginPath();
            ctx.arc(x, y, 10, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.stroke();
        }
        
        // 2ã¤ã®ç·šãŒ90åº¦ã‹ã©ã†ã‹åˆ¤å®š
        function is90Degrees(line1, line2, point1, point2) {
            const dx1 = line1.x2 - line1.x1;
            const dy1 = line1.y2 - line1.y1;
            const dx2 = line2.x2 - line2.x1;
            const dy2 = line2.y2 - line2.y1;
            const dotProduct = dx1 * dx2 + dy1 * dy2;
            const magnitude1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
            const magnitude2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
            
            if (magnitude1 === 0 || magnitude2 === 0) return false;
            
            const cosAngle = dotProduct / (magnitude1 * magnitude2);
            return Math.abs(cosAngle) < 0.1;
        }
        
        // æ–œã‚ã‚³ãƒ¼ãƒŠãƒ¼ã‹ã©ã†ã‹åˆ¤å®šï¼ˆNEW - v1.12.0ï¼‰
        function isDiagonalCorner(line1, line2, point1, point2) {
            if (is90Degrees(line1, line2, point1, point2)) {
                return false;
            }
            const line1IsDiagonal = isLineDiagonal(line1);
            const line2IsDiagonal = isLineDiagonal(line2);
            return line1IsDiagonal || line2IsDiagonal;
        }
        
        // ã‚³ãƒ¼ãƒŠãƒ¼ã®è§’åº¦ã‚’è¨ˆç®—ï¼ˆNEW - v1.12.0ï¼‰
        function getCornerAngle(line1, line2) {
            const angle1 = Math.atan2(line1.y2 - line1.y1, line1.x2 - line1.x1) * (180 / Math.PI);
            const angle2 = Math.atan2(line2.y2 - line2.y1, line2.x2 - line2.x1) * (180 / Math.PI);
            let angleDiff = angle2 - angle1;
            while (angleDiff > 180) angleDiff -= 360;
            while (angleDiff < -180) angleDiff += 360;
            return Math.abs(angleDiff);
        }
        
        // ç·šãŒæ–œã‚ã‹ã©ã†ã‹åˆ¤å®š
        function isLineDiagonal(line) {
            const dx = Math.abs(line.x2 - line.x1);
            const dy = Math.abs(line.y2 - line.y1);
            const threshold = 5;
            return dx > threshold && dy > threshold;
        }
        
        // ç·šã®è§’åº¦ã‚’è¨ˆç®—ï¼ˆåº¦ï¼‰
        function getLineAngle(line) {
            const dx = line.x2 - line.x1;
            const dy = line.y2 - line.y1;
            const radians = Math.atan2(dy, dx);
            return radians * (180 / Math.PI);
        }
        
        function createInputs() {
            const container = document.getElementById('dimension-inputs');
            container.innerHTML = '';
            
            detectCorners();
            
            const infoDiv = document.createElement('div');
            infoDiv.style.cssText = 'background: #e3f2fd; padding: 12px; border-radius: 8px; margin-bottom: 15px;';
            infoDiv.innerHTML = `
                <p style="margin: 0; color: #555; font-size: 14px; line-height: 1.6;">
                    <span style="color: #e74c3c; font-size: 16px;">â—</span> <strong>èµ¤ï¼ã‚³ãƒ¼ãƒŠãƒ¼</strong>ï¼ˆèº¯ä½“å¹…Ã·2ã‚’å¼•ãï¼‰ã€€
                    <span style="color: #3498db; font-size: 16px;">â—</span> <strong>é’ï¼ã‚¨ãƒ³ãƒ‰</strong>ï¼ˆå£ãªã—ï¼‰ã€€
                    <span style="color: #2ecc71; font-size: 16px;">â—</span> <strong>ç·‘ï¼å£</strong>ï¼ˆå£ã‚ã‚Šï¼‰
                </p>
            `;
            container.appendChild(infoDiv);
            
            const widthDiv = document.createElement('div');
            widthDiv.style.cssText = 'background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px;';
            widthDiv.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                    <div>
                        <label style="display: block; color: #555; font-weight: bold; margin-bottom: 8px;">èº¯ä½“å¹… (mm)</label>
                        <input type="number" id="common-width" placeholder="ä¾‹: 180" value="${commonWidth || ''}" 
                               oninput="updateCommonWidth(this.value)" 
                               style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px;">
                    </div>
                    <div>
                        <label style="display: block; color: #555; font-weight: bold; margin-bottom: 8px;">èº¯ä½“é«˜ã• (mm)</label>
                        <input type="number" id="common-height" placeholder="ä¾‹: 1100" value="${commonHeight || ''}" 
                               oninput="updateCommonHeight(this.value)" 
                               style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px;">
                    </div>
                </div>
                <div>
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="individual-width-check" ${useIndividualWidth ? 'checked' : ''} 
                               onchange="toggleIndividualWidth(this.checked)"
                               style="width: 18px; height: 18px; margin-right: 8px; cursor: pointer;">
                        <span style="color: #555; font-size: 14px;">è¾ºã”ã¨ã«èº¯ä½“å¹…ã‚’è¨­å®š</span>
                    </label>
                </div>
            `;
            container.appendChild(widthDiv);
            
            lines.forEach((line, lineIndex) => {
                const div = document.createElement('div');
                div.className = 'dimension-item';
                div.setAttribute('data-line-id', line.id);
                
                const startKey = findCornerKey(line.x1, line.y1, 5);
                const endKey = findCornerKey(line.x2, line.y2, 5);
                const startCorner = corners[startKey];
                const endCorner = corners[endKey];
                
                const startHasStep = startCorner && startCorner.hasStep;
                const endHasStep = endCorner && endCorner.hasStep;
                
                let startState = line.start || 'wall';
                let endState = line.end || 'wall';
                
                const isDiagonal = isLineDiagonal(line);
                const angle = isDiagonal ? getLineAngle(line).toFixed(1) : null;
                
                const widthInput = useIndividualWidth ? `
                    <input type="number" placeholder="èº¯ä½“å¹… (mm)" 
                           oninput="updateDimension('${line.id}', 'width', this.value)"
                           value="${dimensions[line.id]?.width || ''}"
                           style="padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 16px;">
                ` : '';
                
                const angleInput = isDiagonal ? `
                    <div style="margin-top: 10px; padding: 10px; background: #fff3cd; border-radius: 6px; border: 2px solid #ffc107;">
                        <label style="display: block; color: #856404; font-weight: bold; margin-bottom: 5px; font-size: 13px;">
                            âš ï¸ æ–œã‚ç·šï¼šè§’åº¦ï¼ˆåº¦ï¼‰
                        </label>
                        <input type="number" placeholder="è§’åº¦ (åº¦)" 
                               value="${angle || ''}"
                               oninput="updateLineAngle('${line.id}', this.value)"
                               style="width: 100%; padding: 10px; border: 2px solid #ffc107; border-radius: 6px; font-size: 16px;">
                        <p style="margin: 5px 0 0 0; font-size: 12px; color: #856404;">ç¾åœ¨ã®è§’åº¦: ${angle}Â°</p>
                    </div>
                ` : '';
                
                const pointButtons = `
                    <div style="display: flex; gap: 8px;">
                        <button onclick="changePointState('${line.id}', 'start')" style="padding: 6px 12px; background: ${getStateColor(startState)}; color: white; border: none; border-radius: 6px; font-size: 12px; font-weight: bold; cursor: pointer;">
                            å§‹ç‚¹: ${getStateLabel(startState)}
                        </button>
                        <button onclick="changePointState('${line.id}', 'end')" style="padding: 6px 12px; background: ${getStateColor(endState)}; color: white; border: none; border-radius: 6px; font-size: 12px; font-weight: bold; cursor: pointer;">
                            çµ‚ç‚¹: ${getStateLabel(endState)}
                        </button>
                    </div>
                `;

                // æ–œã‚ã‚³ãƒ¼ãƒŠãƒ¼ã®è­¦å‘Šãƒã‚§ãƒƒã‚¯ï¼ˆNEW - v1.12.0ï¼‰- ç‚¹ã®ç¨®é¡ã«é–¢ã‚ã‚‰ãšãƒã‚§ãƒƒã‚¯
                let diagonalCornerWarning = '';
                
                // å§‹ç‚¹ãŒæ–œã‚ã‚³ãƒ¼ãƒŠãƒ¼ã‹ãƒã‚§ãƒƒã‚¯
                if (startCorner && startCorner.lines && startCorner.lines.length >= 2) {
                    for (let ref of startCorner.lines) {
                        if (ref.lineId !== line.id) {
                            const adjacentLine = lines.find(l => l.id === ref.lineId);
                            if (adjacentLine && isDiagonalCorner(line, adjacentLine, 'start', ref.point)) {
                                const cornerAngle = getCornerAngle(line, adjacentLine);
                                diagonalCornerWarning += `
                                    <div style="margin-top: 10px; padding: 12px; background: #fee; border: 2px solid #e74c3c; border-radius: 8px;">
                                        <p style="margin: 0; color: #c0392b; font-weight: bold; font-size: 14px;">
                                            âš ï¸ å§‹ç‚¹ã¯æ–œã‚ã‚³ãƒ¼ãƒŠãƒ¼ã§ã™ï¼ˆè§’åº¦: ${cornerAngle.toFixed(1)}Â°ï¼‰
                                        </p>
                                        <p style="margin: 5px 0 0 0; color: #c0392b; font-size: 13px;">
                                            å¤–æ³•å¯¸æ³•ã‹ã‚‰èŠ¯å¯¸æ³•ã‚’è¨ˆç®—ã§ãã¾ã›ã‚“ã€‚<br>
                                            <strong>ç¾åœ°ã§èŠ¯å¯¸æ³•ã‚’ç›´æ¥æ¸¬å®šã—ã¦ãã ã•ã„ã€‚</strong>
                                        </p>
                                    </div>
                                `;
                                break;
                            }
                        }
                    }
                }
                
                // çµ‚ç‚¹ãŒæ–œã‚ã‚³ãƒ¼ãƒŠãƒ¼ã‹ãƒã‚§ãƒƒã‚¯
                if (endCorner && endCorner.lines && endCorner.lines.length >= 2) {
                    for (let ref of endCorner.lines) {
                        if (ref.lineId !== line.id) {
                            const adjacentLine = lines.find(l => l.id === ref.lineId);
                            if (adjacentLine && isDiagonalCorner(line, adjacentLine, 'end', ref.point)) {
                                const cornerAngle = getCornerAngle(line, adjacentLine);
                                diagonalCornerWarning += `
                                    <div style="margin-top: 10px; padding: 12px; background: #fee; border: 2px solid #e74c3c; border-radius: 8px;">
                                        <p style="margin: 0; color: #c0392b; font-weight: bold; font-size: 14px;">
                                            âš ï¸ çµ‚ç‚¹ã¯æ–œã‚ã‚³ãƒ¼ãƒŠãƒ¼ã§ã™ï¼ˆè§’åº¦: ${cornerAngle.toFixed(1)}Â°ï¼‰
                                        </p>
                                        <p style="margin: 5px 0 0 0; color: #c0392b; font-size: 13px;">
                                            å¤–æ³•å¯¸æ³•ã‹ã‚‰èŠ¯å¯¸æ³•ã‚’è¨ˆç®—ã§ãã¾ã›ã‚“ã€‚<br>
                                            <strong>ç¾åœ°ã§èŠ¯å¯¸æ³•ã‚’ç›´æ¥æ¸¬å®šã—ã¦ãã ã•ã„ã€‚</strong>
                                        </p>
                                    </div>
                                `;
                                break;
                            }
                        }
                    }
                }

                div.innerHTML = `
                    <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <span style="font-weight: bold; color: #667eea;">${line.name}${isDiagonal ? ' <span style="color: #ff9800;">âš ï¸æ–œã‚</span>' : ''}</span>
                        ${pointButtons}
                    </label>
                    ${diagonalCornerWarning}
                    <div class="dimension-row" style="display: grid; grid-template-columns: ${useIndividualWidth ? '1fr 1fr' : '1fr'}; gap: 10px;">
                        <input type="number" placeholder="å¤–æ³•å¯¸æ³• (mm)" 
                               oninput="updateDimension('${line.id}', 'length', this.value)"
                               value="${dimensions[line.id]?.length || ''}"
                               style="padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 16px;">
                        ${widthInput}
                    </div>
                    ${angleInput}
                `;
                container.appendChild(div);
                
                if (!dimensions[line.id]) {
                    dimensions[line.id] = { length: null, width: null };
                }
                
                // ã‚³ãƒ¼ãƒŠãƒ¼ã®è§’åº¦å…¥åŠ›æ¬„ã‚’è¿½åŠ ï¼ˆNEW - v1.12.0ï¼‰
                if (endCorner && endCorner.lines.length >= 2 && lineIndex < lines.length - 1) {
                    const nextLine = lines[lineIndex + 1];
                    
                    if (isDiagonalCorner(line, nextLine, 'end', 'start')) {
                        const cornerAngle = getCornerAngle(line, nextLine);
                        const cornerLabel = `${line.name}â”${nextLine.name}`;
                        
                        const angleDiv = document.createElement('div');
                        angleDiv.style.cssText = 'margin: 10px 0 10px 0; padding: 12px; background: #fff3cd; border-radius: 6px; border: 2px solid #ffc107;';
                        
                        angleDiv.innerHTML = `
                            <label style="display: block; color: #856404; font-weight: bold; margin-bottom: 8px; font-size: 14px;">
                                ğŸ“ ${cornerLabel} ã®ã‚³ãƒ¼ãƒŠãƒ¼è§’åº¦
                            </label>
                            <input type="number" placeholder="è§’åº¦ (åº¦)" 
                                   value="${cornerAngle.toFixed(1)}"
                                   oninput="updateCornerAngle('${endKey}', this.value)"
                                   style="width: 100%; padding: 10px; border: 2px solid #ffc107; border-radius: 6px; font-size: 16px;">
                            <p style="margin: 8px 0 0 0; font-size: 12px; color: #856404;">
                                âš ï¸ æ–œã‚ã‚³ãƒ¼ãƒŠãƒ¼ã§ã™ã€‚ç¾åœ°ã§è§’åº¦ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚
                            </p>
                        `;
                        container.appendChild(angleDiv);
                    }
                }
                
                // æ®µå·®è¨­å®šã‚’è¿½åŠ 
                if (endCorner && endCorner.lines.length >= 2 && lineIndex < lines.length - 1) {
                    const cornerDiv = document.createElement('div');
                    cornerDiv.style.cssText = 'margin: 10px 0 20px 0; padding: 12px; background: #e8f5e9; border-radius: 6px; border: 2px solid #4caf50;';
                    
                    const nextLine = lines[lineIndex + 1];
                    const cornerLabel = `${line.name}â”${nextLine.name}`;
                    
                    cornerDiv.innerHTML = `
                        <label style="display: flex; align-items: center; cursor: pointer; margin-bottom: 8px;">
                            <input type="checkbox" ${endCorner.hasStep ? 'checked' : ''} 
                                   onchange="toggleCornerStep('${endKey}', this.checked)"
                                   style="width: 18px; height: 18px; margin-right: 8px; cursor: pointer;">
                            <span style="color: #2e7d32; font-weight: bold; font-size: 14px;">ğŸ“ ${cornerLabel} ã«æ®µå·®ã‚ã‚Š</span>
                        </label>
                        ${endCorner.hasStep ? `
                            <input type="number" placeholder="æ·±ã• (mm)" 
                                   value="${endCorner.depth || ''}"
                                   oninput="updateCornerDepth('${endKey}', this.value)"
                                   style="width: 100%; padding: 8px; border: 2px solid #4caf50; border-radius: 6px; font-size: 14px;">
                        ` : ''}
                    `;
                    container.appendChild(cornerDiv);
                }
            });
        }
        
        // è§’åº¦ã‚’æ›´æ–°
        function updateLineAngle(lineId, angleDegrees) {
            const lineIndex = lines.findIndex(line => line.id === lineId);
            if (lineIndex === -1) return;
            
            const line = lines[lineIndex];
            const angle = parseFloat(angleDegrees);
            if (isNaN(angle)) return;
            
            const dx = line.x2 - line.x1;
            const dy = line.y2 - line.y1;
            const length = Math.sqrt(dx * dx + dy * dy);
            
            const radians = angle * (Math.PI / 180);
            line.x2 = line.x1 + length * Math.cos(radians);
            line.y2 = line.y1 + length * Math.sin(radians);
            
            drawLines();
            createInputs();
        }
        
        function updateCommonWidth(value) {
            commonWidth = value ? parseFloat(value) : null;
            if (!useIndividualWidth) {
                lines.forEach(line => {
                    if (dimensions[line.id]) {
                        dimensions[line.id].width = commonWidth;
                    }
                });
                drawLines();
                calculate();
            }
        }
        
        function updateCommonHeight(value) {
            commonHeight = value ? parseFloat(value) : null;
            drawLines();
            calculate();
        }
        
        function toggleCornerStep(cornerKey, hasStep) {
            if (!corners[cornerKey]) return;
            
            corners[cornerKey].hasStep = hasStep;
            const corner = corners[cornerKey];
            
            if (!hasStep) {
                corners[cornerKey].depth = null;
                corner.lines.forEach(lineRef => {
                    const line = lines.find(l => l.id === lineRef.lineId);
                    if (line) {
                        line[lineRef.point] = 'corner';
                    }
                });
            } else {
                corner.lines.forEach((lineRef, index) => {
                    const line = lines.find(l => l.id === lineRef.lineId);
                    if (line) {
                        if (index === 0) {
                            line[lineRef.point] = 'end';
                        } else {
                            line[lineRef.point] = 'wall';
                        }
                    }
                });
            }
            
            drawLines();
            createInputs();
        }
        
        function updateCornerDepth(cornerKey, depth) {
            if (!corners[cornerKey]) return;
            corners[cornerKey].depth = depth ? parseFloat(depth) : null;
        }
        
        // ã‚³ãƒ¼ãƒŠãƒ¼ã®è§’åº¦ã‚’æ›´æ–°ï¼ˆNEW - v1.12.0ï¼‰
        function updateCornerAngle(cornerKey, angle) {
            if (!corners[cornerKey]) return;
            corners[cornerKey].angle = angle ? parseFloat(angle) : null;
            calculate();
        }
        
        function toggleIndividualWidth(checked) {
            useIndividualWidth = checked;
            if (!checked && commonWidth) {
                lines.forEach(line => {
                    if (dimensions[line.id]) {
                        dimensions[line.id].width = commonWidth;
                    }
                });
            }
            createInputs();
            drawLines();
            calculate();
        }
        
        function getStateColor(state) {
            const colors = {
                'corner': '#e74c3c',
                'end': '#3498db',
                'wall': '#2ecc71'
            };
            return colors[state] || colors['end'];
        }
        
        function getStateLabel(state) {
            const labels = {
                'corner': 'ã‚³ãƒ¼ãƒŠãƒ¼',
                'end': 'ã‚¨ãƒ³ãƒ‰',
                'wall': 'å£'
            };
            return labels[state] || labels['end'];
        }
        
        function changePointState(lineId, point) {
            const lineIndex = lines.findIndex(line => line.id === lineId);
            if (lineIndex === -1) return;
            
            const line = lines[lineIndex];
            const x = point === 'start' ? line.x1 : line.x2;
            const y = point === 'start' ? line.y1 : line.y2;
            const cornerKey = findCornerKey(x, y, 5);
            const corner = corners[cornerKey];
            
            const isClosed = lines.length > 0 && 
                Math.abs(lines[0].x1 - lines[lines.length - 1].x2) < 5 && 
                Math.abs(lines[0].y1 - lines[lines.length - 1].y2) < 5;
            
            const isFirstLineStart = (lineIndex === 0 && point === 'start' && !isClosed);
            const isLastLineEnd = (lineIndex === lines.length - 1 && point === 'end' && !isClosed);
            const hasStepAtCorner = corner && corner.hasStep;
            
            let states;
            if (isFirstLineStart || isLastLineEnd || hasStepAtCorner) {
                states = ['end', 'wall'];
            } else {
                states = ['corner', 'end', 'wall'];
            }
            
            const currentState = lines[lineIndex][point] || 'wall';
            const currentIndex = states.indexOf(currentState);
            const nextIndex = (currentIndex + 1) % states.length;
            lines[lineIndex][point] = states[nextIndex];
            
            if (lines[lineIndex][point] === 'corner') {
                autoSetCorners();
            }
            
            if (corner && corner.hasStep && corner.lines.length >= 2) {
                syncCornerStatesWithStep(cornerKey, lineId, point, lines[lineIndex][point]);
            }
            
            drawLines();
            createInputs();
            calculate();
        }
        
        function syncCornerStatesWithStep(cornerKey, changedLineId, changedPoint, newState) {
            const corner = corners[cornerKey];
            if (!corner) return;
            
            corner.lines.forEach(lineRef => {
                const line = lines.find(l => l.id === lineRef.lineId);
                if (!line) return;
                
                if (line.id !== changedLineId) {
                    if (newState === 'end') {
                        line[lineRef.point] = 'wall';
                    }
                }
            });
        }
        
        function updateDimension(id, type, value) {
            if (!dimensions[id]) {
                dimensions[id] = { length: null, width: null };
            }
            
            dimensions[id][type] = value ? parseFloat(value) : null;
            drawLines();
            calculate();
        }
        
        function calculate() {
            const resultsContent = document.getElementById('results-content');
            let html = '';
            let hasAll = true;
            let missingItems = [];
            
            detectCorners();
            
            lines.forEach(line => {
                const dim = dimensions[line.id];
                
                if (!dim || !dim.length) {
                    hasAll = false;
                    missingItems.push(`${line.name}ã®å¤–æ³•å¯¸æ³•`);
                }
                
                const hasWidth = useIndividualWidth ? (dim && dim.width) : commonWidth;
                if (!hasWidth) {
                    hasAll = false;
                    if (useIndividualWidth) {
                        missingItems.push(`${line.name}ã®èº¯ä½“å¹…`);
                    } else if (!commonWidth) {
                        if (!missingItems.includes('èº¯ä½“å¹…')) {
                            missingItems.push('èº¯ä½“å¹…');
                        }
                    }
                }
            });
            
            if (!commonHeight) {
                hasAll = false;
                missingItems.push('èº¯ä½“é«˜ã•');
            }
            
            if (corners) {
                for (const cornerKey in corners) {
                    const corner = corners[cornerKey];
                    if (corner && corner.hasStep) {
                        if (!corner.depth) {
                            hasAll = false;
                            if (corner.lines && corner.lines.length >= 2) {
                                const line1 = lines.find(l => l.id === corner.lines[0].lineId);
                                const line2 = lines.find(l => l.id === corner.lines[1].lineId);
                                if (line1 && line2) {
                                    missingItems.push(`${line1.name}â”${line2.name}ã®æ®µå·®å¯¸æ³•`);
                                } else {
                                    missingItems.push('æ®µå·®å¯¸æ³•');
                                }
                            } else {
                                missingItems.push('æ®µå·®å¯¸æ³•');
                            }
                        }
                    }
                }
            }
            
            if (hasAll) {
                lines.forEach(line => {
                    const dim = dimensions[line.id];
                    let result = dim.length;
                    
                    if (line.start === 'corner') {
                        const adjacentWidth = getAdjacentLineWidth(line.id, 'start');
                        if (adjacentWidth > 0) {
                            result -= adjacentWidth / 2;
                        }
                    }
                    
                    if (line.end === 'corner') {
                        const adjacentWidth = getAdjacentLineWidth(line.id, 'end');
                        if (adjacentWidth > 0) {
                            result -= adjacentWidth / 2;
                        }
                    }
                    
                    const startLabel = getPointLabel(line.start);
                    const endLabel = getPointLabel(line.end);
                    
                    html += `
                        <div class="result-item">
                            <span class="result-label">${line.name} ${startLabel}â”${endLabel}</span>
                            <span class="result-value">${Math.floor(result)} mm</span>
                        </div>
                    `;
                });
                
                html = `
                    <div style="margin-bottom: 20px;">
                        <canvas id="result-canvas" width="500" height="400" style="width: 100%; border-radius: 10px;"></canvas>
                    </div>
                    
                    <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
                        <button onclick="downloadAsPDF()" style="flex: 1; min-width: 140px; padding: 12px 20px; background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                            ğŸ“„ PDFã§ä¿å­˜
                        </button>
                        <button onclick="downloadAsPNG()" style="flex: 1; min-width: 140px; padding: 12px 20px; background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                            ğŸ–¼ï¸ ç”»åƒã§ä¿å­˜
                        </button>
                        <button onclick="shareResult()" style="flex: 1; min-width: 140px; padding: 12px 20px; background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                            ğŸ“¤ å…±æœ‰
                        </button>
                    </div>
                ` + html;
                
                resultsContent.innerHTML = html;
                drawResultDiagram();
            } else {
                const warningHtml = `
                    <div style="background: #fee; border: 2px solid #e74c3c; border-radius: 10px; padding: 20px; text-align: center;">
                        <div style="color: #e74c3c; font-size: 20px; font-weight: bold; margin-bottom: 15px;">
                            âš ï¸ å…¥åŠ›ãŒå®Œäº†ã—ã¦ã„ã¾ã›ã‚“
                        </div>
                        <div style="color: #c0392b; font-size: 16px; line-height: 1.8;">
                            ä»¥ä¸‹ã®é …ç›®ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼š<br>
                            <strong>${missingItems.join('ã€')}</strong>
                        </div>
                    </div>
                `;
                resultsContent.innerHTML = warningHtml;
            }
        }
        
        function getAdjacentLineWidth(lineId, point) {
            const currentLine = lines.find(l => l.id === lineId);
            if (!currentLine) return 0;
            
            const x = point === 'start' ? currentLine.x1 : currentLine.x2;
            const y = point === 'start' ? currentLine.y1 : currentLine.y2;ã€€
            const cornerKey = findCornerKey(x, y, 5);
            
            if (!corners || !corners[cornerKey]) return 0;
            
            const corner = corners[cornerKey];
            
            for (const lineRef of corner.lines) {
                if (lineRef.lineId !== lineId) {
                    const adjacentLine = lines.find(l => l.id === lineRef.lineId);
                    if (adjacentLine) {
                        const adjacentDim = dimensions[lineRef.lineId];
                        if (adjacentDim && adjacentDim.width) {
                            return adjacentDim.width;
                        }
                    }
                }
            }
            
            return 0;
        }
        
        function drawResultDiagram() {
            const resultCanvas = document.getElementById('result-canvas');
            if (!resultCanvas) return;
            
            const ctx = resultCanvas.getContext('2d');
            
            ctx.fillStyle = '#f0f9ff';
            ctx.fillRect(0, 0, resultCanvas.width, resultCanvas.height);
            
            if (lines.length === 0) return;
            
            const realLines = [];
            const minLength = 300;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const dim = dimensions[line.id];
                
                if (!dim || !dim.length) continue;
                
                let realLength = dim.length;
                
                const dx = line.x2 - line.x1;
                const dy = line.y2 - line.y1;
                const originalLength = Math.sqrt(dx * dx + dy * dy);
                
                if (originalLength === 0) continue;
                
                const dirX = dx / originalLength;
                const dirY = dy / originalLength;
                
                let displayLength = Math.max(realLength * 0.2, minLength);
                
                let startX = line.x1;
                let startY = line.y1;
                
                for (let j = 0; j < realLines.length; j++) {
                    const prevLine = realLines[j].line;
                    
                    if (Math.abs(line.x1 - prevLine.x2) < 1 && Math.abs(line.y1 - prevLine.y2) < 1) {
                        startX = realLines[j].x2;
                        startY = realLines[j].y2;
                        break;
                    }
                    
                    if (Math.abs(line.x1 - prevLine.x1) < 1 && Math.abs(line.y1 - prevLine.y1) < 1) {
                        startX = realLines[j].x1;
                        startY = realLines[j].y1;
                        break;
                    }
                }
                
                realLines.push({
                    x1: startX,
                    y1: startY,
                    x2: startX + dirX * displayLength,
                    y2: startY + dirY * displayLength,
                    line: line
                });
            }
            
            if (realLines.length === 0) return;
            
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            
            realLines.forEach(rLine => {
                minX = Math.min(minX, rLine.x1, rLine.x2);
                minY = Math.min(minY, rLine.y1, rLine.y2);
                maxX = Math.max(maxX, rLine.x1, rLine.x2);
                maxY = Math.max(maxY, rLine.y1, rLine.y2);
            });
            
            const shapeWidth = Math.max(maxX - minX, 1);
            const shapeHeight = Math.max(maxY - minY, 1);
            
            const margin = 60;
            const canvasWidth = resultCanvas.width - margin * 2;
            const canvasHeight = resultCanvas.height - margin * 2;
            
            const scaleX = canvasWidth / shapeWidth;
            const scaleY = canvasHeight / shapeHeight;
            const scale = Math.min(scaleX, scaleY);
            
            const scaledWidth = shapeWidth * scale;
            const scaledHeight = shapeHeight * scale;
            const offsetX = margin + (canvasWidth - scaledWidth) / 2 - minX * scale;
            const offsetY = margin + (canvasHeight - scaledHeight) / 2 - minY * scale;
            
            function transformX(x) {
                return x * scale + offsetX;
            }
            
            function transformY(y) {
                return y * scale + offsetY;
            }
            
            function drawResultPoint(x, y, state) {
                const colors = {
                    'corner': '#ef4444',
                    'end': '#3b82f6',
                    'wall': '#10b981'
                };
                
                ctx.fillStyle = colors[state] || colors['end'];
                ctx.beginPath();
                ctx.arc(transformX(x), transformY(y), 6, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(transformX(x), transformY(y), 6, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            detectCorners();
            
            realLines.forEach(rLine => {
                const line = rLine.line;
                
                ctx.strokeStyle = '#1a1a1a';
                ctx.lineWidth = 5;
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                ctx.moveTo(transformX(rLine.x1), transformY(rLine.y1));
                ctx.lineTo(transformX(rLine.x2), transformY(rLine.y2));
                ctx.stroke();
                
                const dim = dimensions[line.id];
                if (dim && dim.length) {
                    let result = dim.length;
                    
                    if (line.start === 'corner') {
                        const adjacentWidth = getAdjacentLineWidth(line.id, 'start');
                        if (adjacentWidth > 0) {
                            result -= adjacentWidth / 2;
                        }
                    }
                    
                    if (line.end === 'corner') {
                        const adjacentWidth = getAdjacentLineWidth(line.id, 'end');
                        if (adjacentWidth > 0) {
                            result -= adjacentWidth / 2;
                        }
                    }
                    
                    const midX = (rLine.x1 + rLine.x2) / 2;
                    const midY = (rLine.y1 + rLine.y2) / 2;
                    const dx = rLine.x2 - rLine.x1;
                    const dy = rLine.y2 - rLine.y1;
                    const lineLength = Math.sqrt(dx * dx + dy * dy);
                    
                    const perpX = -dy / lineLength;
                    const perpY = dx / lineLength;
                    
                    const offset = 30;
                    const textX = transformX(midX + perpX * offset);
                    const textY = transformY(midY + perpY * offset);
                    
                    ctx.font = 'bold 16px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    const resultText = `${Math.floor(result)}`;
                    const resultMetrics = ctx.measureText(resultText);
                    const padding = 6;
                    
                    ctx.fillStyle = 'rgba(254, 243, 199, 0.85)';
                    ctx.fillRect(textX - resultMetrics.width/2 - padding, textY - 10, resultMetrics.width + padding*2, 20);
                    
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 1.5;
                    ctx.strokeRect(textX - resultMetrics.width/2 - padding, textY - 10, resultMetrics.width + padding*2, 20);
                    
                    ctx.fillStyle = '#1e40af';
                    ctx.fillText(resultText, textX, textY);
                    
                    if (dim.width) {
                        ctx.font = '10px sans-serif';
                        const widthText = `å¹…:${dim.width}`;
                        const widthMetrics = ctx.measureText(widthText);
                        const widthY = textY + 16;
                        const widthPadding = 3;
                        
                        ctx.fillStyle = 'rgba(243, 244, 246, 0.85)';
                        ctx.fillRect(textX - widthMetrics.width/2 - widthPadding, widthY - 7, widthMetrics.width + widthPadding*2, 14);
                        
                        ctx.fillStyle = '#6b7280';
                        ctx.fillText(widthText, textX, widthY);
                    }
                }
            });
            
            const drawnCorners = new Set();
            const coordMap = new Map();
            realLines.forEach((rLine, idx) => {
                const line = rLine.line;
                const startKey = `${line.x1},${line.y1}`;
                if (!coordMap.has(startKey)) {
                    coordMap.set(startKey, { x: rLine.x1, y: rLine.y1 });
                }
                const endKey = `${line.x2},${line.y2}`;
                if (!coordMap.has(endKey)) {
                    coordMap.set(endKey, { x: rLine.x2, y: rLine.y2 });
                }
            });
            
            if (corners) {
                for (const cornerKey in corners) {
                    const corner = corners[cornerKey];
                    
                    if (!corner || drawnCorners.has(cornerKey)) continue;
                    drawnCorners.add(cornerKey);
                    
                    if (!corner.lines || corner.lines.length === 0) continue;
                    
                    const firstLineRef = corner.lines[0];
                    const firstLine = lines.find(l => l.id === firstLineRef.lineId);
                    if (!firstLine) continue;
                    
                    const cornerX = corner.x !== undefined ? corner.x : (firstLine[firstLineRef.point === 'start' ? 'x1' : 'x2']);
                    const cornerY = corner.y !== undefined ? corner.y : (firstLine[firstLineRef.point === 'start' ? 'y1' : 'y2']);
                    
                    const coordKey = `${cornerX},${cornerY}`;
                    const realCoord = coordMap.get(coordKey);
                    
                    if (!realCoord) continue;
                    
                    if (corner.hasStep && corner.lines.length >= 2) {
                        const line1Ref = corner.lines[0];
                        const line2Ref = corner.lines[1];
                        const line1 = lines.find(l => l.id === line1Ref.lineId);
                        const line2 = lines.find(l => l.id === line2Ref.lineId);
                        
                        if (line1 && line2) {
                            const state1 = line1[line1Ref.point] || 'wall';
                            const state2 = line2[line2Ref.point] || 'wall';
                            
                            const offset = 20;
                            
                            const rLine1 = realLines.find(rl => rl.line.id === line1.id);
                            const rLine2 = realLines.find(rl => rl.line.id === line2.id);
                            
                            if (rLine1 && rLine2) {
                                let dx1, dy1;
                                if (line1Ref.point === 'start') {
                                    dx1 = rLine1.x2 - rLine1.x1;
                                    dy1 = rLine1.y2 - rLine1.y1;
                                } else {
                                    dx1 = rLine1.x1 - rLine1.x2;
                                    dy1 = rLine1.y1 - rLine1.y2;
                                }
                                const len1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
                                
                                let dx2, dy2;
                                if (line2Ref.point === 'start') {
                                    dx2 = rLine2.x2 - rLine2.x1;
                                    dy2 = rLine2.y2 - rLine2.y1;
                                } else {
                                    dx2 = rLine2.x1 - rLine2.x2;
                                    dy2 = rLine2.y1 - rLine2.y2;
                                }
                                const len2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                                
                                if (len1 > 0 && len2 > 0) {
                                    const dirX1 = dx1 / len1;
                                    const dirY1 = dy1 / len1;
                                    const dirX2 = dx2 / len2;
                                    const dirY2 = dy2 / len2;
                                    
                                    drawResultPoint(realCoord.x + dirX1 * offset, realCoord.y + dirY1 * offset, state1);
                                    drawResultPoint(realCoord.x + dirX2 * offset, realCoord.y + dirY2 * offset, state2);
                                } else {
                                    drawResultPoint(realCoord.x, realCoord.y, state1);
                                }
                            } else {
                                drawResultPoint(realCoord.x, realCoord.y, state1);
                            }
                        }
                    } else {
                        const state = firstLine[firstLineRef.point] || 'wall';
                        drawResultPoint(realCoord.x, realCoord.y, state);
                    }
                }
            }
            
            const legendX = resultCanvas.width - 85;
            const legendY = resultCanvas.height - 70;
            
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'left';
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillText('ç‚¹ã®ç¨®é¡', legendX + 1, legendY + 1);
            ctx.fillText('ç‚¹ã®ç¨®é¡', legendX - 1, legendY - 1);
            ctx.fillText('ç‚¹ã®ç¨®é¡', legendX + 1, legendY - 1);
            ctx.fillText('ç‚¹ã®ç¨®é¡', legendX - 1, legendY + 1);
            
            ctx.fillStyle = '#1f2937';
            ctx.fillText('ç‚¹ã®ç¨®é¡', legendX, legendY);
            
            const legendItems = [
                { color: '#ef4444', label: 'ã‚³ãƒ¼ãƒŠãƒ¼' },
                { color: '#3b82f6', label: 'ã‚¨ãƒ³ãƒ‰' },
                { color: '#10b981', label: 'å£' }
            ];
            
            legendItems.forEach((item, index) => {
                const itemY = legendY + 22 + index * 18;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(legendX + 6, itemY + 1, 5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = item.color;
                ctx.beginPath();
                ctx.arc(legendX + 5, itemY, 5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.font = '11px sans-serif';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillText(item.label, legendX + 16, itemY + 5);
                ctx.fillText(item.label, legendX + 14, itemY + 3);
                ctx.fillText(item.label, legendX + 16, itemY + 3);
                ctx.fillText(item.label, legendX + 14, itemY + 5);
                
                ctx.fillStyle = '#374151';
                ctx.fillText(item.label, legendX + 15, itemY + 4);
            });
        }
        
        function getPointLabel(state) {
            const labels = {
                'corner': '<span style="color: #e74c3c;">â—</span>',
                'end': '<span style="color: #3498db;">â—</span>',
                'wall': '<span style="color: #2ecc71;">â—</span>'
            };
            return labels[state] || labels['end'];
        }
        
        function setupCustomDrawing() {
            document.getElementById('dimension-inputs').innerHTML = `
                <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0; color: #1976d2; font-size: 16px;">ğŸ“ ä½œå›³æ–¹æ³•</h3>
                    <p style="margin: 0; color: #555; font-size: 14px;">
                        <strong>ã‚¯ãƒªãƒƒã‚¯</strong>ã§ç‚¹ã‚’æ‰“ã¡ã€ç·šã‚’é€£ç¶šã—ã¦å¼•ã<br>
                        <strong>ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯</strong>ã¾ãŸã¯ä¸‹ã®ãƒœã‚¿ãƒ³ã§ä½œå›³çµ‚äº†
                    </p>
                    <button onclick="finishDrawing()" style="width: 100%; padding: 12px; background: #27ae60; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: bold; cursor: pointer; margin-top: 10px;">
                        âœ“ ä½œå›³çµ‚äº†
                    </button>
                    <h3 style="margin: 15px 0 10px 0; color: #1976d2; font-size: 16px;">ğŸ¨ ç‚¹ã®æ„å‘³</h3>
                    <p style="margin: 0; color: #555; font-size: 14px;">
                        <span style="color: #e74c3c;">â—</span> èµ¤ï¼šã‚³ãƒ¼ãƒŠãƒ¼ï¼ˆèº¯ä½“å¹…Ã·2ã‚’å¼•ãï¼‰<br>
                        <span style="color: #3498db;">â—</span> é’ï¼šã‚¨ãƒ³ãƒ‰ï¼ˆç«¯éƒ¨ã€å£ãªã—ï¼‰<br>
                        <span style="color: #2ecc71;">â—</span> ç·‘ï¼šå£ï¼ˆå£ã‚ã‚Šï¼‰<br>
                        <strong>ä½œå›³çµ‚äº†å¾Œã€ç‚¹ã‚’ã‚¿ãƒƒãƒ—ã§åˆ‡ã‚Šæ›¿ãˆ</strong>
                    </p>
                </div>
            `;
            
            drawingPoints = [];
            
            canvas.removeEventListener('mousedown', startDrawing);
            canvas.removeEventListener('mousemove', drawing);
            canvas.removeEventListener('mouseup', endDrawing);
            canvas.removeEventListener('click', handlePointClick);
            canvas.removeEventListener('touchend', handlePointClickTouch);
            
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('mousemove', handleCanvasMouseMove);
            
            canvas.addEventListener('touchstart', handleTouchDrawing);
            canvas.addEventListener('touchmove', handleTouchDrawingMove);
            
            updateDrawingControls();
        }
        
        function handleCanvasClick(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let x = (e.offsetX || e.clientX - rect.left) * scaleX;
            let y = (e.offsetY || e.clientY - rect.top) * scaleY;
            
            if (drawingPoints.length > 0) {
                const lastPoint = drawingPoints[drawingPoints.length - 1];
                const snapped = snapToAxis(lastPoint.x, lastPoint.y, x, y);
                x = snapped.x;
                y = snapped.y;
            }
            
            if (drawingPoints.length >= 3) {
                const startPoint = drawingPoints[0];
                const distToStart = Math.sqrt(Math.pow(x - startPoint.x, 2) + Math.pow(y - startPoint.y, 2));
                
                if (distToStart < 30) {
                    if (confirm('å›³å½¢ã‚’é–‰ã˜ã¾ã™ã‹ï¼Ÿ\nï¼ˆå§‹ç‚¹ã¨çµ‚ç‚¹ã‚’çµåˆã—ã¾ã™ï¼‰')) {
                        x = startPoint.x;
                        y = startPoint.y;
                        
                        drawingPoints.push({ x, y });
                        
                        const prevPoint = drawingPoints[drawingPoints.length - 2];
                        const currPoint = drawingPoints[drawingPoints.length - 1];
                        
                        const id = String.fromCharCode(65 + lines.length);
                        lines.push({
                            id: id,
                            x1: prevPoint.x,
                            y1: prevPoint.y,
                            x2: currPoint.x,
                            y2: currPoint.y,
                            name: `è¾º${id}`,
                            start: 'wall',
                            end: 'wall'
                        });
                        
                        autoSetCorners();
                        finishDrawing();
                        return;
                    } else {
                        return;
                    }
                }
            }
            
            const clickRadius = 20;
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                let isStartPoint = false;
                if (drawingPoints.length >= 3 && i === 0) {
                    const startPoint = drawingPoints[0];
                    const distToStart = Math.sqrt(Math.pow(line.x1 - startPoint.x, 2) + Math.pow(line.y1 - startPoint.y, 2));
                    isStartPoint = distToStart < 5;
                }
                
                const distStart = Math.sqrt(Math.pow(x - line.x1, 2) + Math.pow(y - line.y1, 2));
                const distEnd = Math.sqrt(Math.pow(x - line.x2, 2) + Math.pow(y - line.y2, 2));
                
                if (!isStartPoint && distStart < clickRadius) {
                    return;
                }
                if (distEnd < clickRadius) {
                    return;
                }
            }
            
            const currentTime = new Date().getTime();
            const timeDiff = currentTime - lastClickTime;
            lastClickTime = currentTime;
            
            if (timeDiff < 500 && drawingPoints.length > 0) {
                finishDrawing();
                return;
            }
            
            drawingPoints.push({ x, y });
            
            if (drawingPoints.length >= 2) {
                const prevPoint = drawingPoints[drawingPoints.length - 2];
                const currPoint = drawingPoints[drawingPoints.length - 1];
                
                const id = String.fromCharCode(65 + lines.length);
                lines.push({
                    id: id,
                    x1: prevPoint.x,
                    y1: prevPoint.y,
                    x2: currPoint.x,
                    y2: currPoint.y,
                    name: `è¾º${id}`,
                    start: 'wall',
                    end: 'wall'
                });
                
                autoSetCorners();
            }
            
            drawLines();
            updateDrawingControls();
        }
        
        function handleCanvasMouseMove(e) {
            if (drawingPoints.length === 0) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let x = (e.offsetX || e.clientX - rect.left) * scaleX;
            let y = (e.offsetY || e.clientY - rect.top) * scaleY;
            
            const lastPoint = drawingPoints[drawingPoints.length - 1];
            const snapped = snapToAxis(lastPoint.x, lastPoint.y, x, y);
            x = snapped.x;
            y = snapped.y;
            
            drawLines();
            
            let snapToStart = false;
            if (drawingPoints.length >= 3) {
                const startPoint = drawingPoints[0];
                const threshold = 10;
                
                if (Math.abs(y - startPoint.y) < threshold) {
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(x, startPoint.y);
                    ctx.lineTo(startPoint.x, startPoint.y);
                    ctx.stroke();
                    
                    y = startPoint.y;
                    
                    if (Math.abs(x - startPoint.x) < threshold) {
                        x = startPoint.x;
                        snapToStart = true;
                    }
                }
                
                if (Math.abs(x - startPoint.x) < threshold) {
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(startPoint.x, y);
                    ctx.lineTo(startPoint.x, startPoint.y);
                    ctx.stroke();
                    
                    x = startPoint.x;
                    
                    if (Math.abs(y - startPoint.y) < threshold) {
                        y = startPoint.y;
                        snapToStart = true;
                    }
                }
                
                if (snapToStart) {
                    ctx.fillStyle = '#f59e0b';
                    ctx.beginPath();
                    ctx.arc(startPoint.x, startPoint.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
            
            if (!snapToStart) {
                if (Math.abs(y - lastPoint.y) < 30) {
                    ctx.strokeStyle = '#10b981';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.moveTo(0, lastPoint.y);
                    ctx.lineTo(canvas.width, lastPoint.y);
                    ctx.stroke();
                }
                
                if (Math.abs(x - lastPoint.x) < 30) {
                    ctx.strokeStyle = '#10b981';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.moveTo(lastPoint.x, 0);
                    ctx.lineTo(lastPoint.x, canvas.height);
                    ctx.stroke();
                }
            }
            
            ctx.strokeStyle = snapToStart ? '#f59e0b' : '#667eea';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(lastPoint.x, lastPoint.y);
            ctx.lineTo(x, y);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        function snapToAxis(x1, y1, x2, y2) {
            const dx = Math.abs(x2 - x1);
            const dy = Math.abs(y2 - y1);
            const threshold = 30;
            
            if (dx > dy && dy < threshold) {
                return { x: x2, y: y1 };
            }
            else if (dy > dx && dx < threshold) {
                return { x: x1, y: y2 };
            }
            return { x: x2, y: y2 };
        }
        
        function handleTouchDrawing(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let x = (touch.clientX - rect.left) * scaleX;
            let y = (touch.clientY - rect.top) * scaleY;
            
            if (drawingPoints.length > 0) {
                const lastPoint = drawingPoints[drawingPoints.length - 1];
                const snapped = snapToAxis(lastPoint.x, lastPoint.y, x, y);
                x = snapped.x;
                y = snapped.y;
            }
            
            if (drawingPoints.length >= 3) {
                const startPoint = drawingPoints[0];
                const distToStart = Math.sqrt(Math.pow(x - startPoint.x, 2) + Math.pow(y - startPoint.y, 2));
                
                if (distToStart < 40) {
                    if (confirm('å›³å½¢ã‚’é–‰ã˜ã¾ã™ã‹ï¼Ÿ\nï¼ˆå§‹ç‚¹ã¨çµ‚ç‚¹ã‚’çµåˆã—ã¾ã™ï¼‰')) {
                        x = startPoint.x;
                        y = startPoint.y;
                        
                        drawingPoints.push({ x, y });
                        
                        const prevPoint = drawingPoints[drawingPoints.length - 2];
                        const currPoint = drawingPoints[drawingPoints.length - 1];
                        
                        const id = String.fromCharCode(65 + lines.length);
                        lines.push({
                            id: id,
                            x1: prevPoint.x,
                            y1: prevPoint.y,
                            x2: currPoint.x,
                            y2: currPoint.y,
                            name: `è¾º${id}`,
                            start: 'wall',
                            end: 'wall'
                        });
                        
                        autoSetCorners();
                        finishDrawing();
                        return;
                    } else {
                        return;
                    }
                }
            }
            
            const clickRadius = 25;
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                let isStartPoint = false;
                if (drawingPoints.length >= 3 && i === 0) {
                    const startPoint = drawingPoints[0];
                    const distToStart = Math.sqrt(Math.pow(line.x1 - startPoint.x, 2) + Math.pow(line.y1 - startPoint.y, 2));
                    isStartPoint = distToStart < 5;
                }
                
                const distStart = Math.sqrt(Math.pow(x - line.x1, 2) + Math.pow(y - line.y1, 2));
                const distEnd = Math.sqrt(Math.pow(x - line.x2, 2) + Math.pow(y - line.y2, 2));
                
                if (!isStartPoint && distStart < clickRadius) {
                    return;
                }
                if (distEnd < clickRadius) {
                    return;
                }
            }
            
            const currentTime = new Date().getTime();
            const timeDiff = currentTime - lastTapTime;
            lastTapTime = currentTime;
            
            if (timeDiff < 500 && drawingPoints.length > 0) {
                finishDrawing();
                return;
            }
            
            drawingPoints.push({ x, y });
            
            if (drawingPoints.length >= 2) {
                const prevPoint = drawingPoints[drawingPoints.length - 2];
                const currPoint = drawingPoints[drawingPoints.length - 1];
                
                const id = String.fromCharCode(65 + lines.length);
                lines.push({
                    id: id,
                    x1: prevPoint.x,
                    y1: prevPoint.y,
                    x2: currPoint.x,
                    y2: currPoint.y,
                    name: `è¾º${id}`,
                    start: 'wall',
                    end: 'wall'
                });
                
                autoSetCorners();
            }
            
            drawLines();
            updateDrawingControls();
        }
        
        function handleTouchDrawingMove(e) {
            if (drawingPoints.length === 0) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let x = (touch.clientX - rect.left) * scaleX;
            let y = (touch.clientY - rect.top) * scaleY;
            
            const lastPoint = drawingPoints[drawingPoints.length - 1];
            const snapped = snapToAxis(lastPoint.x, lastPoint.y, x, y);
            x = snapped.x;
            y = snapped.y;
            
            drawLines();
            
            let snapToStart = false;
            if (drawingPoints.length >= 3) {
                const startPoint = drawingPoints[0];
                const threshold = 15;
                
                if (Math.abs(y - startPoint.y) < threshold) {
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(x, startPoint.y);
                    ctx.lineTo(startPoint.x, startPoint.y);
                    ctx.stroke();
                    
                    y = startPoint.y;
                    
                    if (Math.abs(x - startPoint.x) < threshold) {
                        x = startPoint.x;
                        snapToStart = true;
                    }
                }
                
                if (Math.abs(x - startPoint.x) < threshold) {
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(startPoint.x, y);
                    ctx.lineTo(startPoint.x, startPoint.y);
                    ctx.stroke();
                    
                    x = startPoint.x;
                    
                    if (Math.abs(y - startPoint.y) < threshold) {
                        y = startPoint.y;
                        snapToStart = true;
                    }
                }
                
                if (snapToStart) {
                    ctx.fillStyle = '#f59e0b';
                    ctx.beginPath();
                    ctx.arc(startPoint.x, startPoint.y, 10, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
            
            if (!snapToStart) {
                if (Math.abs(y - lastPoint.y) < 30) {
                    ctx.strokeStyle = '#10b981';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.moveTo(0, lastPoint.y);
                    ctx.lineTo(canvas.width, lastPoint.y);
                    ctx.stroke();
                }
                
                if (Math.abs(x - lastPoint.x) < 30) {
                    ctx.strokeStyle = '#10b981';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.moveTo(lastPoint.x, 0);
                    ctx.lineTo(lastPoint.x, canvas.height);
                    ctx.stroke();
                }
            }
            
            ctx.strokeStyle = snapToStart ? '#f59e0b' : '#667eea';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(lastPoint.x, lastPoint.y);
            ctx.lineTo(x, y);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        function finishDrawing() {
            drawingPoints = [];
            drawLines();
            
            canvas.removeEventListener('click', handleCanvasClick);
            canvas.removeEventListener('mousemove', handleCanvasMouseMove);
            canvas.removeEventListener('touchstart', handleTouchDrawing);
            canvas.removeEventListener('touchmove', handleTouchDrawingMove);
            
            canvas.addEventListener('click', handlePointClick);
            canvas.addEventListener('touchend', handlePointClickTouch);
            
            if (lines.length > 0) {
                createInputs();
            }
            
            updateDrawingControls();
        }
        
        function handlePointClick(e) {
            if (isDrawing || isDragging) return;
            if (drawingPoints.length > 0) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.offsetX || e.clientX - rect.left) * scaleX;
            const y = (e.offsetY || e.clientY - rect.top) * scaleY;
            
            const clickRadius = 20;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                const distStart = Math.sqrt(Math.pow(x - line.x1, 2) + Math.pow(y - line.y1, 2));
                if (distStart < clickRadius) {
                    scrollToInput(line.id);
                    return;
                }
                
                const distEnd = Math.sqrt(Math.pow(x - line.x2, 2) + Math.pow(y - line.y2, 2));
                if (distEnd < clickRadius) {
                    scrollToInput(line.id);
                    return;
                }
                
                const distToLine = distanceToLineSegment(x, y, line.x1, line.y1, line.x2, line.y2);
                if (distToLine < 10) {
                    scrollToInput(line.id);
                    return;
                }
            }
        }
        
        function distanceToLineSegment(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const lengthSquared = dx * dx + dy * dy;
            
            if (lengthSquared === 0) {
                return Math.sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1));
            }
            
            let t = ((px - x1) * dx + (py - y1) * dy) / lengthSquared;
            t = Math.max(0, Math.min(1, t));
            
            const nearestX = x1 + t * dx;
            const nearestY = y1 + t * dy;
            
            return Math.sqrt((px - nearestX) * (px - nearestX) + (py - nearestY) * (py - nearestY));
        }
        
        function scrollToInput(lineId) {
            setTimeout(() => {
                const inputGroup = document.querySelector(`[data-line-id="${lineId}"]`);
                if (inputGroup) {
                    inputGroup.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    
                    inputGroup.style.transition = 'background-color 0.3s';
                    inputGroup.style.backgroundColor = '#fef3c7';
                    
                    setTimeout(() => {
                        inputGroup.style.backgroundColor = '';
                    }, 2000);
                }
            }, 100);
        }
        
        function autoSetCorners() {
            const tolerance = 5;
            
            const isClosed = lines.length > 0 && 
                Math.abs(lines[0].x1 - lines[lines.length - 1].x2) < tolerance && 
                Math.abs(lines[0].y1 - lines[lines.length - 1].y2) < tolerance;
            
            for (let i = 0; i < lines.length; i++) {
                for (let j = i + 1; j < lines.length; j++) {
                    const line1 = lines[i];
                    const line2 = lines[j];
                    
                    if (Math.abs(line1.x1 - line2.x1) < tolerance && Math.abs(line1.y1 - line2.y1) < tolerance) {
                        if (is90Degrees(line1, line2, 'start', 'start')) {
                            if (i !== 0 || isClosed) line1.start = 'corner';
                            if (j !== 0 || isClosed) line2.start = 'corner';
                        } else {
                            if ((i !== 0 || isClosed) && line1.start === 'corner') line2.start = 'corner';
                            if ((j !== 0 || isClosed) && line2.start === 'corner') line1.start = 'corner';
                        }
                    }
                    
                    if (Math.abs(line1.x1 - line2.x2) < tolerance && Math.abs(line1.y1 - line2.y2) < tolerance) {
                        if (is90Degrees(line1, line2, 'start', 'end')) {
                            if (i !== 0 || isClosed) line1.start = 'corner';
                            if (j !== lines.length - 1 || isClosed) line2.end = 'corner';
                        } else {
                            if ((i !== 0 || isClosed) && line1.start === 'corner') line2.end = 'corner';
                            if ((j !== lines.length - 1 || isClosed) && line2.end === 'corner') line1.start = 'corner';
                        }
                    }
                    
                    if (Math.abs(line1.x2 - line2.x1) < tolerance && Math.abs(line1.y2 - line2.y1) < tolerance) {
                        if (is90Degrees(line1, line2, 'end', 'start')) {
                            if (i !== lines.length - 1 || isClosed) line1.end = 'corner';
                            if (j !== 0 || isClosed) line2.start = 'corner';
                        } else {
                            if ((i !== lines.length - 1 || isClosed) && line1.end === 'corner') line2.start = 'corner';
                            if ((j !== 0 || isClosed) && line2.start === 'corner') line1.end = 'corner';
                        }
                    }
                    
                    if (Math.abs(line1.x2 - line2.x2) < tolerance && Math.abs(line1.y2 - line2.y2) < tolerance) {
                        if (is90Degrees(line1, line2, 'end', 'end')) {
                            if (i !== lines.length - 1 || isClosed) line1.end = 'corner';
                            if (j !== lines.length - 1 || isClosed) line2.end = 'corner';
                        } else {
                            if ((i !== lines.length - 1 || isClosed) && line1.end === 'corner') line2.end = 'corner';
                            if ((j !== lines.length - 1 || isClosed) && line2.end === 'corner') line1.end = 'corner';
                        }
                    }
                }
            }
        }
        
        function togglePointState(lineIndex, point) {
            const line = lines[lineIndex];
            
            const x = point === 'start' ? line.x1 : line.x2;
            const y = point === 'start' ? line.y1 : line.y2;
            const cornerKey = findCornerKey(x, y, 5);
            const corner = corners[cornerKey];
            
            const isClosed = lines.length > 0 && 
                Math.abs(lines[0].x1 - lines[lines.length - 1].x2) < 5 && 
                Math.abs(lines[0].y1 - lines[lines.length - 1].y2) < 5;
            
            const isFirstLineStart = (lineIndex === 0 && point === 'start' && !isClosed);
            const isLastLineEnd = (lineIndex === lines.length - 1 && point === 'end' && !isClosed);
            const hasStepAtCorner = corner && corner.hasStep;
            
            let states;
            if (isFirstLineStart || isLastLineEnd || hasStepAtCorner) {
                states = ['end', 'wall'];
            } else {
                states = ['corner', 'end', 'wall'];
            }
            
            const currentState = lines[lineIndex][point] || 'wall';
            const currentIndex = states.indexOf(currentState);
            const nextIndex = (currentIndex + 1) % states.length;
            lines[lineIndex][point] = states[nextIndex];
            
            if (lines[lineIndex][point] === 'corner') {
                autoSetCorners();
            }
            
            if (corner && corner.hasStep && corner.lines.length >= 2) {
                syncCornerStatesWithStep(cornerKey, line.id, point, lines[lineIndex][point]);
            }
        }
        
        function handleTouch(e) {
            e.preventDefault();
            const touch = e.touches[0] || e.changedTouches[0];
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (touch.clientX - rect.left) * scaleX;
            const y = (touch.clientY - rect.top) * scaleY;
            
            if (e.type === 'touchstart') {
                startDrawing({ offsetX: x, offsetY: y });
            } else if (e.type === 'touchmove') {
                drawing({ offsetX: x, offsetY: y });
            } else if (e.type === 'touchend') {
                endDrawing({ offsetX: x, offsetY: y });
            }
        }
        
        function startDrawing(e) {
            isDrawing = true;
            isDragging = false;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            startPoint = { 
                x: (e.offsetX || e.clientX - rect.left) * scaleX, 
                y: (e.offsetY || e.clientY - rect.top) * scaleY 
            };
        }
        
        function drawing(e) {
            if (!isDrawing) return;
            
            isDragging = true;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.offsetX || e.clientX - rect.left) * scaleX;
            const y = (e.offsetY || e.clientY - rect.top) * scaleY;
            
            drawLines();
            
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(startPoint.x, startPoint.y);
            ctx.lineTo(x, y);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        function endDrawing(e) {
            if (!isDrawing) return;
            
            if (isDragging) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.offsetX || e.clientX - rect.left) * scaleX;
                const y = (e.offsetY || e.clientY - rect.top) * scaleY;
                
                const id = String.fromCharCode(65 + lines.length);
                lines.push({
                    id: id,
                    x1: startPoint.x,
                    y1: startPoint.y,
                    x2: x,
                    y2: y,
                    name: `è¾º${id}`,
                    start: 'wall',
                    end: 'wall'
                });
                
                drawLines();
                createInputs();
            }
            
            isDrawing = false;
            isDragging = false;
        }
        
        function savePattern() {
            const name = prompt('ãƒ‘ã‚¿ãƒ¼ãƒ³åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:');
            if (!name) return;
            
            const savedPatterns = JSON.parse(localStorage.getItem('savedPatterns') || '{}');
            savedPatterns[name] = {
                lines: lines,
                dimensions: dimensions
            };
            localStorage.setItem('savedPatterns', JSON.stringify(savedPatterns));
            
            alert('ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä¿å­˜ã—ã¾ã—ãŸ');
        }
        
        function loadSavedPatterns() {
            const savedPatterns = JSON.parse(localStorage.getItem('savedPatterns') || '{}');
            const keys = Object.keys(savedPatterns);
            
            if (keys.length === 0) return;
            
            document.getElementById('saved-patterns-section').style.display = 'block';
            const grid = document.getElementById('saved-patterns-grid');
            grid.innerHTML = '';
            
            keys.forEach(name => {
                const btn = document.createElement('button');
                btn.className = 'pattern-btn';
                btn.innerHTML = `
                    ${name}
                    <span class="delete-btn" onclick="event.stopPropagation(); deletePattern('${name}')">Ã—</span>
                `;
                btn.onclick = () => selectPattern(name);
                grid.appendChild(btn);
            });
        }
        
        function loadCustomPattern(name) {
            const savedPatterns = JSON.parse(localStorage.getItem('savedPatterns') || '{}');
            const pattern = savedPatterns[name];
            
            if (!pattern) return;
            
            document.getElementById('pattern-title').textContent = name;
            lines = pattern.lines;
            dimensions = pattern.dimensions || {};
            
            drawLines();
            createInputs();
        }
        
        function deletePattern(name) {
            if (!confirm(`ã€Œ${name}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`)) return;
            
            const savedPatterns = JSON.parse(localStorage.getItem('savedPatterns') || '{}');
            delete savedPatterns[name];
            localStorage.setItem('savedPatterns', JSON.stringify(savedPatterns));
            
            loadSavedPatterns();
        }
        
        function undoLastLine() {
            if (lines.length === 0) return;
            
            if (drawingPoints.length === 0 && lines.length > 0) {
                drawingPoints = [];
                drawingPoints.push({ x: lines[0].x1, y: lines[0].y1 });
                
                for (let i = 0; i < lines.length; i++) {
                    drawingPoints.push({ x: lines[i].x2, y: lines[i].y2 });
                }
                
                canvas.removeEventListener('click', handlePointClick);
                canvas.removeEventListener('touchend', handlePointClickTouch);
                
                canvas.addEventListener('click', handleCanvasClick);
                canvas.addEventListener('mousemove', handleCanvasMouseMove);
                canvas.addEventListener('touchstart', handleTouchDrawing);
                canvas.addEventListener('touchmove', handleTouchDrawingMove);
            }
            
            const lastLineId = lines[lines.length - 1].id;
            lines.pop();
            delete dimensions[lastLineId];
            
            if (drawingPoints.length > 1) {
                drawingPoints.pop();
            }
            
            drawLines();
            createInputs();
            calculate();
            updateDrawingControls();
        }
        
        function clearDrawing() {
            if (lines.length > 0 && !confirm('ã™ã¹ã¦ã®ä½œå›³ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã‹ï¼Ÿ')) {
                return;
            }
            
            lines = [];
            dimensions = {};
            drawingPoints = [];
            corners = {};
            commonWidth = null;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            document.getElementById('dimension-inputs').innerHTML = '';
            document.getElementById('results-content').innerHTML = '<p style="color: #999; text-align: center;">å¯¸æ³•ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„</p>';
            
            updateDrawingControls();
            
            if (currentPattern === 'custom') {
                canvas.removeEventListener('click', handlePointClick);
                canvas.removeEventListener('touchend', handlePointClickTouch);
                
                canvas.addEventListener('click', handleCanvasClick);
                canvas.addEventListener('mousemove', handleCanvasMouseMove);
                canvas.addEventListener('touchstart', handleTouchDrawing);
                canvas.addEventListener('touchmove', handleTouchDrawingMove);
            } else {
                selectPattern(currentPattern);
            }
        }
        
        function updateDrawingControls() {
            const controls = document.getElementById('drawing-controls');
            if (controls) {
                controls.style.display = (drawingPoints.length > 0 || currentPattern === 'custom') ? 'flex' : 'none';
            }
        }
        
        function backToSelect() {
            document.getElementById('pattern-select-screen').style.display = 'block';
            document.getElementById('measurement-screen').style.display = 'none';
            loadSavedPatterns();
        }
        
        function clearAll() {
            if (!confirm('ã™ã¹ã¦ã®ä½œå›³ã¨å…¥åŠ›å†…å®¹ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã‹ï¼Ÿ')) {
                return;
            }
            
            lines = [];
            dimensions = {};
            drawingPoints = [];
            corners = {};
            commonWidth = null;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            document.getElementById('dimension-inputs').innerHTML = '';
            document.getElementById('results-content').innerHTML = '<p style="color: #999; text-align: center;">å¯¸æ³•ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„</p>';
            
            updateDrawingControls();
            
            if (currentPattern === 'Iå­—') {
                createIPattern();
            } else if (currentPattern === 'å·¦Lå­—') {
                createLPatternLeft();
            } else if (currentPattern === 'å³Lå­—') {
                createLPatternRight();
            } else if (currentPattern === 'ã‚³ã®å­—') {
                createUPattern();
            } else if (currentPattern === 'custom') {
                setupCustomDrawing();
            }
        }
        
        function getFilename() {
            const date = new Date().toISOString().slice(0, 10);
            return `kutai-keisoku_${date}`;
        }
        
        async function downloadAsPDF() {
            const measurementScreen = document.getElementById('measurement-screen');
            if (!measurementScreen || measurementScreen.style.display === 'none') {
                alert('è¨ˆç®—çµæœãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }
            
            try {
                let canvas, titleText;
                
                const container = measurementScreen.querySelector('.container');
                if (!container) {
                    canvas = await html2canvas(measurementScreen, {
                        scale: 2,
                        backgroundColor: '#ffffff',
                        logging: false
                    });
                } else {
                    canvas = await html2canvas(container, {
                        scale: 2,
                        backgroundColor: '#ffffff',
                        logging: false
                    });
                }
                titleText = 'èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ ';
                
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF({
                    orientation: 'portrait',
                    unit: 'mm',
                    format: 'a4'
                });
                
                const imgData = canvas.toDataURL('image/png');
                
                const pageWidth = 210;
                const pageHeight = 297;
                const margin = 10;
                const imgWidth = pageWidth - margin * 2;
                const imgHeight = (canvas.height * imgWidth) / canvas.width;
                const maxHeight = pageHeight - margin * 2 - 25;
                
                pdf.setFontSize(16);
                pdf.text(titleText, pageWidth / 2, 15, { align: 'center' });
                
                const date = new Date().toLocaleDateString('ja-JP');
                pdf.setFontSize(10);
                pdf.text(date, pageWidth / 2, 22, { align: 'center' });
                
                let finalImgWidth, finalImgHeight;
                
                if (imgHeight <= maxHeight) {
                    finalImgWidth = imgWidth;
                    finalImgHeight = imgHeight;
                } else {
                    finalImgHeight = maxHeight;
                    finalImgWidth = (canvas.width * finalImgHeight) / canvas.height;
                    
                    if (finalImgWidth > imgWidth) {
                        finalImgWidth = imgWidth;
                        finalImgHeight = (canvas.height * finalImgWidth) / canvas.width;
                    }
                }
                
                const xOffset = margin + (imgWidth - finalImgWidth) / 2;
                pdf.addImage(imgData, 'PNG', xOffset, 30, finalImgWidth, finalImgHeight);
                
                const filename = getFilename() + '.pdf';
                pdf.save(filename);
                
            } catch (error) {
                console.error('PDFä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
                alert('PDFã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ');
            }
        }
        
        async function downloadAsPNG() {
            const measurementScreen = document.getElementById('measurement-screen');
            if (!measurementScreen || measurementScreen.style.display === 'none') {
                alert('è¨ˆç®—çµæœãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }
            
            try {
                let canvas;
                
                const container = measurementScreen.querySelector('.container');
                if (!container) {
                    canvas = await html2canvas(measurementScreen, {
                        scale: 2,
                        backgroundColor: '#ffffff',
                        logging: false
                    });
                } else {
                    canvas = await html2canvas(container, {
                        scale: 2,
                        backgroundColor: '#ffffff',
                        logging: false
                    });
                }
                
                const imgData = canvas.toDataURL('image/png');
                
                const link = document.createElement('a');
                link.download = getFilename() + '.png';
                link.href = imgData;
                link.click();
                
            } catch (error) {
                console.error('PNGä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
                alert('ç”»åƒã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ');
            }
        }
        
        async function shareResult() {
            const measurementScreen = document.getElementById('measurement-screen');
            if (!measurementScreen || measurementScreen.style.display === 'none') {
                alert('è¨ˆç®—çµæœãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }
            
            try {
                if (!navigator.share && !navigator.canShare) {
                    alert('ã“ã®ç«¯æœ«ã§ã¯å…±æœ‰æ©Ÿèƒ½ãŒä½¿ãˆã¾ã›ã‚“ã€‚ç”»åƒã¨ã—ã¦ä¿å­˜ã—ã¾ã™ã€‚');
                    downloadAsPNG();
                    return;
                }
                
                let canvas;
                
                const container = measurementScreen.querySelector('.container');
                if (!container) {
                    canvas = await html2canvas(measurementScreen, {
                        scale: 2,
                        backgroundColor: '#ffffff',
                        logging: false
                    });
                } else {
                    canvas = await html2canvas(container, {
                        scale: 2,
                        backgroundColor: '#ffffff',
                        logging: false
                    });
                }
                
                canvas.toBlob(async (blob) => {
                    try {
                        const file = new File([blob], getFilename() + '.png', { type: 'image/png' });
                        
                        const shareData = {
                            title: 'èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ ',
                            text: 'èº¯ä½“æ¡å¯¸ã®ä½œå›³ã¨è¨ˆç®—çµæœã§ã™',
                            files: [file]
                        };
                        
                        if (navigator.canShare && !navigator.canShare(shareData)) {
                            await navigator.share({
                                title: shareData.title,
                                text: shareData.text,
                                url: window.location.href
                            });
                        } else {
                            await navigator.share(shareData);
                        }
                        
                    } catch (shareError) {
                        if (shareError.name !== 'AbortError') {
                            console.error('å…±æœ‰ã‚¨ãƒ©ãƒ¼:', shareError);
                            alert('å…±æœ‰ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ç”»åƒã¨ã—ã¦ä¿å­˜ã—ã¾ã™ã€‚');
                            downloadAsPNG();
                        }
                    }
                }, 'image/png');
                
            } catch (error) {
                console.error('å…±æœ‰ã‚¨ãƒ©ãƒ¼:', error);
                alert('å…±æœ‰ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ç”»åƒã¨ã—ã¦ä¿å­˜ã—ã¾ã™ã€‚');
                downloadAsPNG();
            }
        }
        
        function openManual() {
            document.getElementById('manual-modal').style.display = 'block';
            document.body.style.overflow = 'hidden';
        }
        
        function closeManual() {
            document.getElementById('manual-modal').style.display = 'none';
            document.body.style.overflow = 'auto';
        }
        
        window.onclick = function(event) {
            const modal = document.getElementById('manual-modal');
            if (event.target === modal) {
                closeManual();
            }
        }
    </script>
</body>
</html>
