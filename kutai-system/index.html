<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ </title>
    <!--
    ========================================
    èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ 
    ========================================
    ãƒãƒ¼ã‚¸ãƒ§ãƒ³: 1.11.1
    æœ€çµ‚æ›´æ–°: 2024-12-27
    
    [æ›´æ–°å±¥æ­´]
    v1.11.1 (2024-12-27)
    - ä½¿ã„æ–¹ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ã‚’è¿½åŠ ï¼ˆmodalè¡¨ç¤ºï¼‰
    - ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠç”»é¢ã«ã€Œâ“ ä½¿ã„æ–¹ã€ãƒœã‚¿ãƒ³ã‚’è¿½åŠ 
    - æ¡å¯¸ç”»é¢ã«ã‚‚ã€Œâ“ ä½¿ã„æ–¹ã€ãƒœã‚¿ãƒ³ã‚’è¿½åŠ 
    - ãƒãƒ‹ãƒ¥ã‚¢ãƒ«å†…å®¹ï¼šå¤–æ³•â†’èº¯ä½“èŠ¯ã®èª¬æ˜ã€è‡ªç”±ä½œå›³ã®è©³ã—ã„ä½¿ã„æ–¹ã€ç‚¹ã®ç¨®é¡ã€æ®µå·®è¨­å®šã€è¨ˆç®—çµæœã€ä¿å­˜ãƒ»å…±æœ‰ã€ã‚ˆãã‚ã‚‹è³ªå•
    - ã‚·ã‚¹ãƒ†ãƒ å†…ã§å®Œçµï¼ˆGitHubã«é£›ã°ãªã„ï¼‰
    
    v1.11.0 (2024-12-27)
    - ç›´ç·šãŒä¸¦ã‚“ã å ´åˆã«è¨ˆç®—çµæœã®å›³ãŒè¡¨ç¤ºã•ã‚Œãªã„å•é¡Œã‚’ä¿®æ­£
    - ãƒ•ã‚¡ã‚¤ãƒ«åå…¥åŠ›æ¬„ã‚’å‰Šé™¤
    - ä¿å­˜ç¯„å›²ãƒˆã‚°ãƒ«ã‚’å‰Šé™¤
    - å¸¸ã«ãƒšãƒ¼ã‚¸å…¨ä½“ã‚’ä¿å­˜ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰
    - ãƒ•ã‚¡ã‚¤ãƒ«åã¯å›ºå®šï¼škutai-keisoku_YYYY-MM-DD
    - å…±æœ‰æ©Ÿèƒ½ãŒæ­£å¸¸ã«å‹•ä½œã™ã‚‹ã‚ˆã†ã«æ”¹å–„
    
    v1.10.6 (2024-12-27)
    - æ®µå·®ãŒã‚ã‚‹å ´åˆã®ç‚¹ã®é…ç½®ã‚’æ”¹å–„
    - ç·šã‹ã‚‰å‚ç›´æ–¹å‘ã«ãšã‚‰ã™ â†’ ç·šã®æ–¹å‘ã«æ²¿ã£ã¦è§’ã‹ã‚‰ãšã‚‰ã™
    - ã©ã¡ã‚‰ã®è¾ºã®ç‚¹ãªã®ã‹æ˜ç¢ºã«åˆ¤åˆ¥ã§ãã‚‹ã‚ˆã†ã«
    - ä½œå›³ç”»é¢ã¨è¨ˆç®—çµæœã®ä¸¡æ–¹ã«é©ç”¨
    
    v1.10.5 (2024-12-27)
    - æ®µå·®ã‚ã‚Šãƒã‚§ãƒƒã‚¯æ™‚ã®ç‚¹ã®ç¨®é¡ã‚’æ”¹å–„
    - ãƒã‚§ãƒƒã‚¯æ™‚ï¼š1ã¤ç›®ã‚’ã‚¨ãƒ³ãƒ‰ï¼ˆé’ï¼‰ã€æ®‹ã‚Šã‚’å£ï¼ˆç·‘ï¼‰ã«å¤‰æ›´
    - ãƒã‚§ãƒƒã‚¯å¤–ã™æ™‚ï¼šã‚³ãƒ¼ãƒŠãƒ¼ï¼ˆèµ¤ï¼‰ã«æˆ»ã™
    - èª¤æ“ä½œæ™‚ã®å¾©å…ƒãŒç°¡å˜ã«
    
    v1.10.4 (2024-12-27)
    - å³Lå­—ã®è¨ˆç®—çµæœã®å›³ã®ç ´ç¶»ã‚’ä¿®æ­£
    - ç·šã®æ¥ç¶šé–¢ä¿‚ã‚’è€ƒæ…®ã—ã¦åº§æ¨™ã‚’èª¿æ•´
    - å…±æœ‰ç‚¹ã‚’æŒã¤ç·šãŒæ­£ã—ãç¹‹ãŒã‚‹ã‚ˆã†ã«æ”¹å–„
    - Lå­—ã‚„ã‚³ã®å­—ãªã©ã®å½¢çŠ¶ãŒæ­£ã—ãè¡¨ç¤ºã•ã‚Œã‚‹
    
    v1.10.3 (2024-12-27)
    - è¨ˆç®—çµæœã®å›³ã®æç”»ãƒ­ã‚¸ãƒƒã‚¯ã‚’æ ¹æœ¬çš„ã«ä¿®æ­£
    - å…ƒã®åº§æ¨™é–¢ä¿‚ã‚’ä¿æŒã—ãŸã¾ã¾å®Ÿå¯¸æ³•ã‚’é©ç”¨
    - Lå­—ãªã©ã®å½¢çŠ¶ãŒæ­£ã—ãè¡¨ç¤ºã•ã‚Œã‚‹ã‚ˆã†ã«
    - ç·šã‚’é †ç•ªã«é€£çµã™ã‚‹å•é¡Œã‚’è§£æ¶ˆ
    
    v1.10.2 (2024-12-27)
    - å·¦Lå­—ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ã‚³ãƒ¼ãƒŠãƒ¼éƒ¨ã‚’ä¿®æ­£ï¼ˆè¾ºAã®å§‹ç‚¹ã‚’cornerã«ï¼‰
    - è¨ˆç®—çµæœã®å›³ã®Yè»¸åè»¢å•é¡Œã‚’ä¿®æ­£ï¼ˆä¸Šä¸‹ãŒæ­£ã—ãè¡¨ç¤ºã•ã‚Œã‚‹ï¼‰
    - Lå­—ã®è§’ãŒæ­£ã—ãã‚³ãƒ¼ãƒŠãƒ¼ã¨ã—ã¦èªè­˜ã•ã‚Œã‚‹ã‚ˆã†ã«ä¿®æ­£
    
    v1.10.1 (2024-12-27)
    - ä¸Šéƒ¨ã®å¤§ãã„ã‚¯ãƒªã‚¢ãƒœã‚¿ãƒ³ã‚’å‰Šé™¤ï¼ˆä½œå›³ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã®ã‚¯ãƒªã‚¢ãƒœã‚¿ãƒ³ã®ã¿ï¼‰
    - æ®µå·®ãŒã‚ã‚‹å ´åˆã€ã‚¨ãƒ³ãƒ‰ï¼ˆé’ï¼‰ã‚’ä¸Šã«ã€å£ï¼ˆç·‘ï¼‰ã‚’ä¸‹ã«é…ç½®
    - ç‚¹ã®é–“éš”ã‚’åºƒã’ã¦é‡ãªã‚‰ãªã„ã‚ˆã†ã«æ”¹å–„ï¼ˆoffset: 12 â†’ 20ï¼‰
    - è‡ªç”±ä½œå›³ã®åº§æ¨™å¤‰æ›å•é¡Œã‚’ä¿®æ­£
    
    v1.10.0 (2024-12-27)
    - åŸºæœ¬ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆIå­—ã€Lå­—ã€ã‚³ã®å­—ï¼‰ãŒç”»é¢ã‹ã‚‰ã¯ã¿å‡ºã‚‹å•é¡Œã‚’ä¿®æ­£
    - ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºã«å¿œã˜ã¦è‡ªå‹•çš„ã«å›³å½¢ã‚’é…ç½®
    - ã‚¯ãƒªã‚¢ãƒœã‚¿ãƒ³ã‚’å®Ÿè£…ï¼ˆä½œå›³ã¨å…¥åŠ›ã‚’ãƒªã‚»ãƒƒãƒˆï¼‰
    - ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ä»˜ãã§èª¤æ“ä½œã‚’é˜²æ­¢
    
    v1.9.0 (2024-12-27)
    - ãƒ•ã‚¡ã‚¤ãƒ«åã‚’è‡ªç”±ã«è¨­å®šã§ãã‚‹æ©Ÿèƒ½ã‚’è¿½åŠ 
    - ä¿å­˜ç¯„å›²ãƒˆã‚°ãƒ«ã®ä¸Šã«å…¥åŠ›æ¬„ã‚’è¿½åŠ 
    - å…¥åŠ›ã—ãŸåå‰ã¯ä¿å­˜ã•ã‚Œã€æ¬¡å›ã‚‚ä½¿ãˆã‚‹
    - ä¾‹ï¼šã€Œç”°ä¸­é‚¸ã€â†’ ç”°ä¸­é‚¸_2024-12-27.pdf
    - ç©ºæ¬„ã®å ´åˆã¯ã€Œkutai-keisokuã€ãŒä½¿ç”¨ã•ã‚Œã‚‹
    
    v1.8.2 (2024-12-27)
    - ãƒ•ã‚¡ã‚¤ãƒ«åã‚’è‹±èªï¼ˆãƒ­ãƒ¼ãƒå­—ï¼‰ã«å¤‰æ›´
    - æ–‡å­—åŒ–ã‘ã‚’é˜²æ­¢ï¼škutai-keisoku_2024-12-27.pdf
    - ã™ã¹ã¦ã®ä¿å­˜ãƒ»å…±æœ‰ã§æ­£ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«åãŒè¡¨ç¤ºã•ã‚Œã‚‹
    
    v1.8.1 (2024-12-27)
    - å‡¡ä¾‹ã®ãƒ‡ã‚¶ã‚¤ãƒ³ã‚’å½±ä»˜ãæ–‡å­—ã«å¤‰æ›´ï¼ˆç™½æŠœãèƒŒæ™¯ã‚’å‰Šé™¤ï¼‰
    - PDFã‚’å¿…ãš1ãƒšãƒ¼ã‚¸ã«åã‚ã‚‹ã‚ˆã†ã«æ”¹å–„ï¼ˆç¸®å°ã—ã¦å…¨ä½“è¡¨ç¤ºï¼‰
    - é•·ã„ãƒšãƒ¼ã‚¸ã§ã‚‚åˆ‡ã‚Œãšã«1ãƒšãƒ¼ã‚¸ã§ä¿å­˜å¯èƒ½ã«
    
    v1.8.0 (2024-12-27)
    - ä¿å­˜ç¯„å›²ã‚’é¸æŠã§ãã‚‹ãƒˆã‚°ãƒ«ã‚¹ã‚¤ãƒƒãƒã‚’è¿½åŠ 
    - ã€Œè¨ˆç®—çµæœã®ã¿ã€ã¨ã€Œãƒšãƒ¼ã‚¸å…¨ä½“ã€ã‚’åˆ‡ã‚Šæ›¿ãˆå¯èƒ½ã«
    - ç”¨é€”ã«å¿œã˜ã¦ä¿å­˜ç¯„å›²ã‚’é¸ã¹ã‚‹ã‚ˆã†ã«
    
    v1.7.0 (2024-12-27)
    - ãƒšãƒ¼ã‚¸å…¨ä½“ã‚’å…±æœ‰ã§ãã‚‹ã‚ˆã†ã«æ”¹å–„ï¼ˆä½œå›³ + å…¥åŠ› + è¨ˆç®—çµæœï¼‰
    - PDF/PNGä¿å­˜æ™‚ã‚‚ãƒšãƒ¼ã‚¸å…¨ä½“ãŒä¿å­˜ã•ã‚Œã‚‹
    - è¨ˆç®—çµæœã®å›³ã«å‡¡ä¾‹ã‚’è¿½åŠ ï¼ˆç‚¹ã®è‰²ã®èª¬æ˜ï¼‰
    - ä½œå›³ç”»é¢ã®å›³ã¯å…ƒã®æ¯”ç‡ã®ã¾ã¾ï¼ˆè¨ˆç®—çµæœã®å›³ã®ã¿å®Ÿå¯¸æ³•æ¯”ç‡ï¼‰
    - å¾Œã§ç¢ºèªã™ã‚‹éš›ã«ä½œå›³éƒ¨åˆ†ã‚‚å«ã¾ã‚Œã‚‹ã‚ˆã†ã«æ”¹å–„
    
    v1.6.1 (2024-12-27)
    - è¨ˆç®—çµæœã®å›³ã‚’å¤§å¹…ã«è¦‹ã‚„ã™ãæ”¹å–„
    - ç·šã®å¤ªã•ã‚’5pxã«å¢—åŠ ï¼ˆå°ã•ã„è¾ºã§ã‚‚è¦‹ã‚„ã™ãï¼‰
    - æ–‡å­—ã‚µã‚¤ã‚ºã‚’16pxã«ç¸®å°ï¼ˆã‚³ãƒ³ãƒ‘ã‚¯ãƒˆã«ï¼‰
    - èƒŒæ™¯ã‚’åŠé€æ˜åŒ–ï¼ˆç·šãŒé€ã‘ã¦è¦‹ãˆã‚‹ï¼‰
    - æœ€å°è¡¨ç¤ºé•·ã•ã‚’300pxã«å¢—åŠ 
    - ãƒ†ã‚­ã‚¹ãƒˆã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’30pxã«èª¿æ•´
    - ã‚¹ãƒãƒ›ã§ã®è¦–èªæ€§ã‚’å¤§å¹…æ”¹å–„
    
    v1.6.0 (2024-12-27)
    - PDFä¿å­˜æ©Ÿèƒ½è¿½åŠ ï¼ˆGoodNotesã€Notionã€ã‚¯ãƒ©ã‚¦ãƒ‰ã«ä¿å­˜å¯èƒ½ï¼‰
    - PNGç”»åƒä¿å­˜æ©Ÿèƒ½è¿½åŠ 
    - å…±æœ‰æ©Ÿèƒ½è¿½åŠ ï¼ˆiPhoneã®å…±æœ‰ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‹ã‚‰ç›´æ¥å…±æœ‰ï¼‰
    - è¨ˆç®—çµæœã®å›³ã‚’ç°¡å˜ã«ä¿å­˜ãƒ»å…±æœ‰ã§ãã‚‹ã‚ˆã†ã«æ”¹å–„
    
    v1.5.2 (2024-12-26) - å®Œæˆç‰ˆ
    - è¨ˆç®—çµæœã®å°æ•°ç‚¹ä»¥ä¸‹ã‚’åˆ‡ã‚Šæ¨ã¦ã«å¤‰æ›´
    - ã™ã¹ã¦ã®æ©Ÿèƒ½ãŒå®Œæˆ
    
    v1.5.1 (2024-12-26)
    - ä½œå›³çµ‚äº†å¾Œã®æˆ»ã‚‹ãƒœã‚¿ãƒ³ã§ä½œå›³å†é–‹ã§ãã‚‹æ©Ÿèƒ½ã‚’ä¿®æ­£
    - ä½œå›³ç”¨ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’æ­£ã—ãå†è¨­å®š
    - è¨ˆç®—çµæœã®èº¯ä½“å¹…è¡¨ç¤ºã«èƒŒæ™¯ã‚’è¿½åŠ ï¼ˆé‡ãªã‚Šé˜²æ­¢ï¼‰
    
    v1.5.0 (2024-12-26)
    - ä½œå›³å¾Œã€ç‚¹ãƒ»ç·šã‚¯ãƒªãƒƒã‚¯ã§å…¥åŠ›æ¬„ã«ç§»å‹•ï¼ˆçŠ¶æ…‹å¤‰æ›´ãªã—ï¼‰
    - ç·šã‚¯ãƒªãƒƒã‚¯æ©Ÿèƒ½è¿½åŠ ï¼ˆç‚¹ã‹ã‚‰ç·šåˆ†ã¸ã®è·é›¢è¨ˆç®—ï¼‰
    - è¨ˆç®—çµæœã®å›³ï¼šæœ€å°è¡¨ç¤ºé•·ã•200pxã€ãƒ†ã‚­ã‚¹ãƒˆã‚’ç·šã®å¤–å´ã«é…ç½®
    - ãƒ†ã‚­ã‚¹ãƒˆã®é‡ãªã‚Šã‚’å®Œå…¨ã«é˜²æ­¢ï¼ˆå‚ç›´æ–¹å‘40pxã‚ªãƒ•ã‚»ãƒƒãƒˆï¼‰
    
    v1.4.0 (2024-12-26)
    - è¨ˆç®—çµæœã®å›³ã®æœ€å°è¡¨ç¤ºé•·ã•ã‚’150pxã«å¢—åŠ ï¼ˆæ•°å­—ã®é‡ãªã‚Šã‚’é˜²æ­¢ï¼‰
    - ä½œå›³çµ‚äº†å¾Œã«ç‚¹ã‚¯ãƒªãƒƒã‚¯ã§çŠ¶æ…‹å¤‰æ›´ã§ãã‚‹æ©Ÿèƒ½ã‚’ä¿®æ­£
    - å§‹ç‚¹ã‚¯ãƒªãƒƒã‚¯ã§å›³å½¢ã‚’é–‰ã˜ã‚‹æ©Ÿèƒ½ã‚’ä¿®æ­£ï¼ˆã‚¹ãƒŠãƒƒãƒ—å‡¦ç†å¾Œã«åˆ¤å®šï¼‰
    - PC: 30pxä»¥å†…ã€ã‚¿ãƒƒãƒ: 40pxä»¥å†…ã§å§‹ç‚¹ã¨ã—ã¦èªè­˜
    
    v1.3.1 (2024-12-26)
    - è¨ˆç®—çµæœã®å›³ã§ã‚³ãƒ¼ãƒŠãƒ¼ç‚¹ãŒè¡¨ç¤ºã•ã‚Œãªã„å•é¡Œã‚’ä¿®æ­£
    - ç‚¹ã‚¯ãƒªãƒƒã‚¯æ™‚ã®å…¥åŠ›æ¬„ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æ©Ÿèƒ½ã‚’ä¿®æ­£ï¼ˆDOMã®æ›´æ–°ã‚’å¾…ã¤ï¼‰
    - å§‹ç‚¹ã‚’ç›´æ¥ã‚¯ãƒªãƒƒã‚¯ã—ã¦å›³å½¢ã‚’é–‰ã˜ã‚‹æ©Ÿèƒ½ã‚’ä¿®æ­£
    
    v1.3.0 (2024-12-26)
    - ç‚¹ã‚¯ãƒªãƒƒã‚¯ã§å…¥åŠ›æ¬„ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«&ãƒã‚¤ãƒ©ã‚¤ãƒˆæ©Ÿèƒ½è¿½åŠ 
    - è¨ˆç®—çµæœã®å›³ã‚’å®Ÿå¯¸æ³•æ¯”ç‡ã§è¡¨ç¤ºï¼ˆè¦‹ã‚„ã™ã•å„ªå…ˆï¼‰
    - æœ€å°è¡¨ç¤ºé•·ã•80pxã§å¯¸æ³•ã®è¦–èªæ€§ã‚’ç¢ºä¿
    
    v1.2.0 (2024-12-26)
    - å§‹ç‚¹ã®å¼·èª¿è¡¨ç¤ºã‚µã‚¤ã‚ºã‚’èª¿æ•´
    - å§‹ç‚¹ã‚’ç›´æ¥ã‚¯ãƒªãƒƒã‚¯/ã‚¿ãƒƒãƒ—ã§å›³å½¢ã‚’é–‰ã˜ã‚‹æ©Ÿèƒ½è¿½åŠ 
    - ä½œå›³çµ‚äº†å¾Œã«æˆ»ã‚‹ãƒœã‚¿ãƒ³ã§ä½œå›³ã‚’å†é–‹ã§ãã‚‹æ©Ÿèƒ½è¿½åŠ 
    - ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠã«æˆ»ã‚‹ãƒœã‚¿ãƒ³ã‚’å¸¸ã«æœ‰åŠ¹åŒ–
    
    v1.1.0 (2024-12-26)
    - ã‚¹ãƒãƒ¼ãƒˆã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³è¿½åŠ ï¼ˆã‚¤ãƒ©ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼é¢¨ï¼‰
    - å§‹ç‚¹ã«å‘ã‹ã†ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³è¡¨ç¤º
    - ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³åˆè‡´æ™‚ã«å§‹ç‚¹ã‚’å¼·èª¿è¡¨ç¤º
    - æ®µå·®å¯¸æ³•ã®å…¥åŠ›ãƒã‚§ãƒƒã‚¯è¿½åŠ 
    
    v1.0.0 (2024-12-26)
    - åˆå›ãƒªãƒªãƒ¼ã‚¹
    - Iå­—å‹ã€Lå­—å‹ã€ã‚³ã®å­—å‹ã€è‡ªç”±ä½œå›³å¯¾å¿œ
    - æ®µå·®æ©Ÿèƒ½ã€ã‚³ãƒ¼ãƒŠãƒ¼è¨ˆç®—æ©Ÿèƒ½
    - å››è§’å½¢ã®é–‰ã˜ãŸå›³å½¢å¯¾å¿œ
    ========================================
    -->
    <!-- jsPDF ãƒ©ã‚¤ãƒ–ãƒ©ãƒªï¼ˆPDFä¿å­˜ç”¨ï¼‰ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- html2canvas ãƒ©ã‚¤ãƒ–ãƒ©ãƒªï¼ˆãƒšãƒ¼ã‚¸å…¨ä½“ã‚­ãƒ£ãƒ—ãƒãƒ£ç”¨ï¼‰ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, 'Hiragino Kaku Gothic ProN', sans-serif;
            background: #f5f7fa;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 700px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            padding: 40px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }
        
        h1 {
            text-align: center;
            color: #1a1a1a;
            margin-bottom: 40px;
            font-size: 28px;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        
        h2 {
            color: #1a1a1a;
            margin: 30px 0 20px;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            opacity: 0.6;
        }
        
        /* ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠç”»é¢ */
        .pattern-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }
        
        .pattern-btn {
            background: white;
            color: #1a1a1a;
            border: 2px solid #e5e7eb;
            padding: 24px 16px;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            min-height: 110px;
        }
        
        .pattern-btn svg {
            width: 50px;
            height: 50px;
        }
        
        .pattern-btn:hover {
            border-color: #3b82f6;
            background: #f0f9ff;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.15);
        }
        
        .pattern-btn:active {
            transform: translateY(0);
        }
        
        .pattern-btn.custom {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
            grid-column: 1 / -1;
        }
        
        .pattern-btn.custom:hover {
            background: #2563eb;
            border-color: #2563eb;
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.25);
        }
        
        .pattern-btn .delete-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .pattern-btn .delete-btn:hover {
            background: #dc2626;
            transform: scale(1.1);
        }
        
        /* æ¡å¯¸ç”»é¢ */
        .measurement-screen {
            display: none;
        }
        
        .back-btn {
            background: #f3f4f6;
            color: #1a1a1a;
            border: 1px solid #e5e7eb;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 20px;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        
        .back-btn:hover {
            background: #e5e7eb;
            border-color: #d1d5db;
        }
        
        .drawing-area {
            position: relative;
            width: 100%;
            height: 400px;
            background: #f9fafb;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            margin: 20px 0;
            overflow: hidden;
            touch-action: none;
        }
        
        canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }
        
        .dimension-inputs {
            margin: 20px 0;
        }
        
        .dimension-item {
            background: #f9fafb;
            padding: 16px;
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            margin-bottom: 12px;
        }
        
        .dimension-item label {
            display: block;
            color: #1a1a1a;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .dimension-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .dimension-row input {
            padding: 10px 12px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            font-size: 15px;
            transition: all 0.2s ease;
        }
        
        .dimension-row input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        .results {
            background: #f9fafb;
            padding: 20px;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            margin-top: 20px;
        }
        
        .result-item {
            padding: 12px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .result-label {
            color: #555;
            font-weight: bold;
        }
        
        .result-value {
            color: #667eea;
            font-weight: bold;
            font-size: 18px;
        }
        
        .save-pattern-btn {
            width: 100%;
            background: #10b981;
            color: white;
            border: none;
            padding: 14px;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.2s ease;
        }
        
        .save-pattern-btn:hover {
            background: #059669;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.25);
        }
        
        .alert {
            background: #fff3cd;
            color: #856404;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #ffc107;
        }
        
        .success {
            background: #d4edda;
            color: #155724;
            border-left-color: #28a745;
        }
        
        /* ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ãƒ¢ãƒ¼ãƒ€ãƒ« */
        .manual-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            overflow-y: auto;
        }
        
        .manual-content {
            background: white;
            max-width: 800px;
            margin: 20px auto;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        
        .manual-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #ef4444;
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .manual-close:hover {
            background: #dc2626;
            transform: scale(1.1);
        }
        
        .manual-content h1 {
            color: #1e40af;
            border-bottom: 3px solid #3b82f6;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        
        .manual-content h2 {
            color: #2563eb;
            margin-top: 30px;
            margin-bottom: 15px;
        }
        
        .manual-content h3 {
            color: #3b82f6;
            margin-top: 20px;
            margin-bottom: 10px;
        }
        
        .manual-content pre {
            background: #f3f4f6;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            border-left: 4px solid #3b82f6;
        }
        
        .manual-content ul, .manual-content ol {
            padding-left: 25px;
            line-height: 1.8;
        }
        
        .manual-content li {
            margin-bottom: 8px;
        }
        
        .manual-content strong {
            color: #1e40af;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠç”»é¢ -->
        <div id="pattern-select-screen">
            <h1>èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ </h1>
            
            <!-- ä½¿ã„æ–¹ãƒœã‚¿ãƒ³ -->
            <div style="margin-bottom: 20px; text-align: center;">
                <button onclick="openManual()" 
                   style="display: inline-block; padding: 10px 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; font-weight: bold; font-size: 14px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); cursor: pointer;">
                    â“ ä½¿ã„æ–¹
                </button>
            </div>
            
            <h2>åŸºæœ¬ãƒ‘ã‚¿ãƒ¼ãƒ³</h2>
            <div class="pattern-grid">
                <button class="pattern-btn" onclick="selectPattern('i')">
                    <svg viewBox="0 0 60 60">
                        <line x1="10" y1="30" x2="50" y2="30" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                    </svg>
                    Iå­—
                </button>
                <button class="pattern-btn" onclick="selectPattern('l-left')">
                    <svg viewBox="0 0 60 60">
                        <line x1="15" y1="10" x2="15" y2="50" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                        <line x1="15" y1="10" x2="45" y2="10" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                    </svg>
                    å·¦Lå­—
                </button>
                <button class="pattern-btn" onclick="selectPattern('l-right')">
                    <svg viewBox="0 0 60 60">
                        <line x1="45" y1="10" x2="45" y2="50" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                        <line x1="15" y1="10" x2="45" y2="10" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                    </svg>
                    å³Lå­—
                </button>
                <button class="pattern-btn" onclick="selectPattern('u')">
                    <svg viewBox="0 0 60 60">
                        <line x1="15" y1="50" x2="15" y2="10" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                        <line x1="15" y1="10" x2="45" y2="10" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                        <line x1="45" y1="10" x2="45" y2="50" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                    </svg>
                    ã‚³ã®å­—
                </button>
            </div>
            
            <div id="saved-patterns-section" style="display: none;">
                <h2>ä¿å­˜æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³</h2>
                <div class="pattern-grid" id="saved-patterns-grid"></div>
            </div>
            
            <h2>ã‚«ã‚¹ã‚¿ãƒ ä½œå›³</h2>
            <div class="pattern-grid">
                <button class="pattern-btn custom" onclick="selectPattern('custom')">è‡ªç”±ã«ç·šã‚’å¼•ã</button>
            </div>
            
            <!-- ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ± -->
            <div style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #e5e7eb; text-align: center; color: #6b7280; font-size: 13px;">
                <div style="margin-bottom: 5px;">èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ  v1.11.1</div>
                <div>æœ€çµ‚æ›´æ–°: 2024-12-27</div>
            </div>
        </div>
        
        <!-- æ¡å¯¸ç”»é¢ -->
        <div id="measurement-screen" class="measurement-screen">
            <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                <button id="back-btn" class="back-btn" onclick="backToSelect()" style="flex: 2;">â† ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠã«æˆ»ã‚‹</button>
                <button onclick="openManual()" 
                   style="flex: 1; display: flex; align-items: center; justify-content: center; padding: 12px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; font-weight: bold; font-size: 14px; cursor: pointer;">
                    â“ ä½¿ã„æ–¹
                </button>
            </div>
            
            <h1 id="pattern-title">æ¡å¯¸å…¥åŠ›</h1>
            
            <div id="alert" class="alert" style="display: none;"></div>
            
            <div class="drawing-area">
                <canvas id="canvas"></canvas>
            </div>
            
            <div id="drawing-controls" style="display: none; margin-top: 10px; display: flex; gap: 10px; flex-wrap: wrap;">
                <button onclick="clearDrawing()" style="flex: 1; min-width: 120px; padding: 12px; background: #ef4444; color: white; border: none; border-radius: 8px; font-size: 15px; font-weight: 600; cursor: pointer; transition: all 0.2s ease;">ğŸ—‘ï¸ ã‚¯ãƒªã‚¢</button>
                <button onclick="undoLastLine()" style="flex: 1; min-width: 120px; padding: 12px; background: #f59e0b; color: white; border: none; border-radius: 8px; font-size: 15px; font-weight: 600; cursor: pointer; transition: all 0.2s ease;">â†¶ æˆ»ã‚‹</button>
                <button onclick="finishDrawing()" style="flex: 1; min-width: 120px; padding: 12px; background: #10b981; color: white; border: none; border-radius: 8px; font-size: 15px; font-weight: 600; cursor: pointer; transition: all 0.2s ease;">âœ“ ä½œå›³çµ‚äº†</button>
            </div>
            
            <div class="dimension-inputs" id="dimension-inputs"></div>
            
            <div class="results">
                <h2>è¨ˆç®—çµæœ</h2>
                <div id="results-content">
                    <p style="color: #999; text-align: center;">å¯¸æ³•ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„</p>
                </div>
            </div>
            
            <button class="save-pattern-btn" onclick="savePattern()">ã“ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä¿å­˜</button>
        </div>
    </div>
    
    <script>
        let currentPattern = null;
        let lines = [];
        let dimensions = {};
        let isDrawing = false;
        let isDragging = false;
        let startPoint = null;
        let canvas, ctx;
        let drawingPoints = [];
        let lastClickTime = 0;
        let lastTapTime = 0;
        let commonWidth = null; // èº¯ä½“å¹…
        let useIndividualWidth = false; // å€‹åˆ¥è¨­å®šãƒ•ãƒ©ã‚°
        let commonHeight = null; // èº¯ä½“é«˜ã•
        let corners = {}; // ã‚³ãƒ¼ãƒŠãƒ¼æƒ…å ± { 'x,y': { hasStep: bool, depth: number, lines: [...] } }
        
        // ã‚³ãƒ¼ãƒŠãƒ¼ã‚’æ¤œå‡º
        function detectCorners() {
            if (!corners) {
                corners = {};
            }
            
            if (!lines || lines.length === 0) {
                corners = {};
                return;
            }
            
            const newCorners = {};
            const tolerance = 5; // åŒã˜ç‚¹ã¨ã¿ãªã™è¨±å®¹ç¯„å›²
            
            lines.forEach((line, idx) => {
                if (!line) return;
                
                // å§‹ç‚¹
                const startKey = findCornerKeyForDetection(line.x1, line.y1, tolerance, newCorners);
                if (!newCorners[startKey]) {
                    // æ—¢å­˜ã®ã‚³ãƒ¼ãƒŠãƒ¼æƒ…å ±ã‚’ä¿æŒ
                    const oldCorner = corners[startKey];
                    newCorners[startKey] = { 
                        x: line.x1, 
                        y: line.y1, 
                        hasStep: oldCorner ? oldCorner.hasStep : false, 
                        depth: oldCorner ? oldCorner.depth : null, 
                        lines: [] 
                    };
                }
                newCorners[startKey].lines.push({ lineId: line.id, point: 'start' });
                
                // çµ‚ç‚¹
                const endKey = findCornerKeyForDetection(line.x2, line.y2, tolerance, newCorners);
                if (!newCorners[endKey]) {
                    // æ—¢å­˜ã®ã‚³ãƒ¼ãƒŠãƒ¼æƒ…å ±ã‚’ä¿æŒ
                    const oldCorner = corners[endKey];
                    newCorners[endKey] = { 
                        x: line.x2, 
                        y: line.y2, 
                        hasStep: oldCorner ? oldCorner.hasStep : false, 
                        depth: oldCorner ? oldCorner.depth : null, 
                        lines: [] 
                    };
                }
                newCorners[endKey].lines.push({ lineId: line.id, point: 'end' });
            });
            
            corners = newCorners;
        }
        
        // ã‚³ãƒ¼ãƒŠãƒ¼ã‚­ãƒ¼ã‚’æ¤œç´¢ï¼ˆæ¤œå‡ºç”¨ - æ–°ã—ã„cornersã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‚ç…§ï¼‰
        function findCornerKeyForDetection(x, y, tolerance, cornersObj) {
            for (const key in cornersObj) {
                const corner = cornersObj[key];
                const dist = Math.sqrt(Math.pow(x - corner.x, 2) + Math.pow(y - corner.y, 2));
                if (dist < tolerance) {
                    return key;
                }
            }
            // æ–°ã—ã„ã‚­ãƒ¼ã‚’ç”Ÿæˆ
            return `${Math.round(x)},${Math.round(y)}`;
        }
        
        // ã‚³ãƒ¼ãƒŠãƒ¼ã‚­ãƒ¼ã‚’æ¤œç´¢ï¼ˆæ—¢å­˜ã®cornersã‹ã‚‰æ¤œç´¢ï¼‰
        function findCornerKey(x, y, tolerance) {
            if (!corners) return `${Math.round(x)},${Math.round(y)}`;
            
            for (const key in corners) {
                const corner = corners[key];
                const dist = Math.sqrt(Math.pow(x - corner.x, 2) + Math.pow(y - corner.y, 2));
                if (dist < tolerance) {
                    return key;
                }
            }
            // æ–°ã—ã„ã‚­ãƒ¼ã‚’ç”Ÿæˆ
            return `${Math.round(x)},${Math.round(y)}`;
        }
        
        
        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚
        window.onload = function() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            resizeCanvas();
            
            loadSavedPatterns();
        };
        
        // Canvas ãƒªã‚µã‚¤ã‚º
        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            if (lines.length > 0) {
                drawLines();
            }
        }
        
        // ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠ
        function selectPattern(type) {
            currentPattern = type;
            document.getElementById('pattern-select-screen').style.display = 'none';
            document.getElementById('measurement-screen').style.display = 'block';
            
            // Canvasã‚’ãƒªã‚µã‚¤ã‚º
            setTimeout(resizeCanvas, 100);
            
            lines = [];
            dimensions = {};
            drawingPoints = [];
            commonWidth = null;
            commonHeight = null;
            useIndividualWidth = false;
            
            if (type === 'i') {
                document.getElementById('pattern-title').textContent = 'Iå­—å‹ æ¡å¯¸';
                createIPattern();
            } else if (type === 'l-left') {
                document.getElementById('pattern-title').textContent = 'å·¦Lå­—å‹ æ¡å¯¸';
                createLPatternLeft();
            } else if (type === 'l-right') {
                document.getElementById('pattern-title').textContent = 'å³Lå­—å‹ æ¡å¯¸';
                createLPatternRight();
            } else if (type === 'u') {
                document.getElementById('pattern-title').textContent = 'ã‚³ã®å­—å‹ æ¡å¯¸';
                createUPattern();
            } else if (type === 'custom') {
                document.getElementById('pattern-title').textContent = 'è‡ªç”±ä½œå›³';
                setupCustomDrawing();
            } else {
                // ä¿å­˜æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³ã®èª­ã¿è¾¼ã¿
                loadCustomPattern(type);
            }
        }
        
        // Iå­—ãƒ‘ã‚¿ãƒ¼ãƒ³
        function createIPattern() {
            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ä¸­å¤®ã«é…ç½®
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const lineLength = Math.min(canvas.width, canvas.height) * 0.6; // ã‚­ãƒ£ãƒ³ãƒã‚¹ã®60%ã®é•·ã•
            
            lines = [
                { 
                    id: 'A', 
                    x1: centerX - lineLength/2, y1: centerY, 
                    x2: centerX + lineLength/2, y2: centerY, 
                    name: 'è¾ºA', 
                    start: 'wall', // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯å£
                    end: 'wall'
                }
            ];
            drawLines();
            createInputs();
            setupPointClickListener();
        }
        
        // å·¦Lå­—ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆâ”Œå‹ï¼‰
        function createLPatternLeft() {
            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºã«å¿œã˜ã¦é…ç½®
            const size = Math.min(canvas.width, canvas.height) * 0.5;
            const margin = Math.min(canvas.width, canvas.height) * 0.2;
            
            lines = [
                { 
                    id: 'A', 
                    x1: margin, y1: margin, 
                    x2: margin, y2: margin + size, 
                    name: 'è¾ºAï¼ˆç¸¦ï¼‰', 
                    start: 'corner',  // ã‚³ãƒ¼ãƒŠãƒ¼ï¼ˆè¾ºBã¨æ¥ç¶šï¼‰
                    end: 'wall'  // å£
                },
                { 
                    id: 'B', 
                    x1: margin, y1: margin, 
                    x2: margin + size, y2: margin, 
                    name: 'è¾ºBï¼ˆæ¨ªï¼‰', 
                    start: 'corner',  // ã‚³ãƒ¼ãƒŠãƒ¼ï¼ˆè¾ºAã¨æ¥ç¶šï¼‰
                    end: 'wall'  // å£
                }
            ];
            drawLines();
            createInputs();
            setupPointClickListener();
        }
        
        // å³Lå­—ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆâ”å‹ï¼‰
        function createLPatternRight() {
            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºã«å¿œã˜ã¦é…ç½®
            const size = Math.min(canvas.width, canvas.height) * 0.5;
            const margin = Math.min(canvas.width, canvas.height) * 0.2;
            
            lines = [
                { 
                    id: 'A', 
                    x1: margin, y1: margin, 
                    x2: margin + size, y2: margin, 
                    name: 'è¾ºAï¼ˆæ¨ªï¼‰', 
                    start: 'wall',  // ã‚¨ãƒ³ãƒ‰ã¯å£
                    end: 'corner'
                },
                { 
                    id: 'B', 
                    x1: margin + size, y1: margin, 
                    x2: margin + size, y2: margin + size, 
                    name: 'è¾ºBï¼ˆç¸¦ï¼‰', 
                    start: 'corner',
                    end: 'wall'  // ã‚¨ãƒ³ãƒ‰ã¯å£
                }
            ];
            drawLines();
            createInputs();
            setupPointClickListener();
        }
        
        // ã‚³ã®å­—ãƒ‘ã‚¿ãƒ¼ãƒ³
        function createUPattern() {
            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºã«å¿œã˜ã¦é…ç½®
            const width = Math.min(canvas.width, canvas.height) * 0.5;
            const height = Math.min(canvas.width, canvas.height) * 0.4;
            const margin = Math.min(canvas.width, canvas.height) * 0.2;
            
            lines = [
                { 
                    id: 'A', 
                    x1: margin, y1: margin + height, 
                    x2: margin, y2: margin, 
                    name: 'è¾ºA', 
                    start: 'wall',  // ã‚¨ãƒ³ãƒ‰ã¯å£
                    end: 'corner'
                },
                { 
                    id: 'B', 
                    x1: margin, y1: margin, 
                    x2: margin + width, y2: margin, 
                    name: 'è¾ºB', 
                    start: 'corner',
                    end: 'corner'
                },
                { 
                    id: 'C', 
                    x1: margin + width, y1: margin, 
                    x2: margin + width, y2: margin + height, 
                    name: 'è¾ºC', 
                    start: 'corner',
                    end: 'wall'  // ã‚¨ãƒ³ãƒ‰ã¯å£
                }
            ];
            drawLines();
            createInputs();
            setupPointClickListener();
        }
        
        // ç‚¹ã‚¯ãƒªãƒƒã‚¯ãƒªã‚¹ãƒŠãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        function setupPointClickListener() {
            // æ—¢å­˜ã®ãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤ï¼ˆé‡è¤‡é˜²æ­¢ï¼‰
            canvas.removeEventListener('click', handlePointClick);
            canvas.removeEventListener('touchend', handlePointClickTouch);
            
            // æ–°ã—ã„ãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
            canvas.addEventListener('click', handlePointClick);
            canvas.addEventListener('touchend', handlePointClickTouch);
        }
        
        // ã‚¿ãƒƒãƒã§ç‚¹ã®çŠ¶æ…‹ã‚’åˆ‡ã‚Šæ›¿ãˆ
        function handlePointClickTouch(e) {
            if (isDrawing || isDragging) return;
            if (drawingPoints.length > 0) return;
            
            e.preventDefault();
            const touch = e.changedTouches[0];
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (touch.clientX - rect.left) * scaleX;
            const y = (touch.clientY - rect.top) * scaleY;
            
            const clickRadius = 25;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                const distStart = Math.sqrt(Math.pow(x - line.x1, 2) + Math.pow(y - line.y1, 2));
                if (distStart < clickRadius) {
                    // å…¥åŠ›æ¬„ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«&ãƒã‚¤ãƒ©ã‚¤ãƒˆã®ã¿ï¼ˆçŠ¶æ…‹å¤‰æ›´ã—ãªã„ï¼‰
                    scrollToInput(line.id);
                    return;
                }
                
                const distEnd = Math.sqrt(Math.pow(x - line.x2, 2) + Math.pow(y - line.y2, 2));
                if (distEnd < clickRadius) {
                    // å…¥åŠ›æ¬„ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«&ãƒã‚¤ãƒ©ã‚¤ãƒˆã®ã¿ï¼ˆçŠ¶æ…‹å¤‰æ›´ã—ãªã„ï¼‰
                    scrollToInput(line.id);
                    return;
                }
                
                // ç·šã‚’ã‚¿ãƒƒãƒ—ã—ãŸã‹ãƒã‚§ãƒƒã‚¯
                const distToLine = distanceToLineSegment(x, y, line.x1, line.y1, line.x2, line.y2);
                if (distToLine < 15) {
                    // å…¥åŠ›æ¬„ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«&ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                    scrollToInput(line.id);
                    return;
                }
            }
        }
        
        // ç·šã‚’æç”»
        function drawLines() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ã‚³ãƒ¼ãƒŠãƒ¼ã‚’æ¤œå‡º
            detectCorners();
            
            if (lines.length === 0) return;
            
            // åŸºæœ¬ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ã¿åº§æ¨™å¤‰æ›ã‚’é©ç”¨ï¼ˆè‡ªç”±ä½œå›³ã¯å…ƒã®ã¾ã¾ï¼‰
            const shouldTransform = currentPattern !== 'custom';
            
            let transform = (x, y) => ({ x, y }); // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯å¤‰æ›ãªã—
            
            if (shouldTransform) {
                // å…¨ã¦ã®ç‚¹ã‹ã‚‰å¢ƒç•Œãƒœãƒƒã‚¯ã‚¹ã‚’è¨ˆç®—
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                lines.forEach(line => {
                    minX = Math.min(minX, line.x1, line.x2);
                    minY = Math.min(minY, line.y1, line.y2);
                    maxX = Math.max(maxX, line.x1, line.x2);
                    maxY = Math.max(maxY, line.y1, line.y2);
                });
                
                const shapeWidth = maxX - minX;
                const shapeHeight = maxY - minY;
                
                // ãƒãƒ¼ã‚¸ãƒ³
                const margin = 50;
                const canvasWidth = canvas.width - margin * 2;
                const canvasHeight = canvas.height - margin * 2;
                
                // ã‚¹ã‚±ãƒ¼ãƒ«ä¿‚æ•°ã‚’è¨ˆç®—ï¼ˆã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’ç¶­æŒï¼‰
                const scaleX = canvasWidth / shapeWidth;
                const scaleY = canvasHeight / shapeHeight;
                const scale = Math.min(scaleX, scaleY, 1); // æœ€å¤§1å€ï¼ˆæ‹¡å¤§ã—ãªã„ï¼‰
                
                // ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨ˆç®—ï¼ˆä¸­å¤®é…ç½®ï¼‰
                const scaledWidth = shapeWidth * scale;
                const scaledHeight = shapeHeight * scale;
                const offsetX = margin + (canvasWidth - scaledWidth) / 2 - minX * scale;
                const offsetY = margin + (canvasHeight - scaledHeight) / 2 - minY * scale;
                
                // åº§æ¨™å¤‰æ›é–¢æ•°ã‚’ä¸Šæ›¸ã
                transform = (x, y) => ({
                    x: x * scale + offsetX,
                    y: y * scale + offsetY
                });
            }
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 5;
            ctx.lineCap = 'round';
            
            // ç·šã‚’æç”»
            lines.forEach((line, index) => {
                const p1 = transform(line.x1, line.y1);
                const p2 = transform(line.x2, line.y2);
                
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
                
                // ãƒ©ãƒ™ãƒ«ä½ç½®è¨ˆç®—
                const midX = (p1.x + p2.x) / 2;
                const midY = (p1.y + p2.y) / 2;
                
                // å…¥åŠ›ã•ã‚ŒãŸå¤–æ³•å¯¸æ³•ã‚’è¡¨ç¤º
                const dim = dimensions[line.id];
                if (dim && dim.length) {
                    ctx.font = 'bold 18px sans-serif';
                    ctx.fillStyle = '#3b82f6';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // èƒŒæ™¯ã‚’ç™½ã
                    const text = `${dim.length}`;
                    const metrics = ctx.measureText(text);
                    const padding = 8;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.fillRect(midX - metrics.width/2 - padding, midY - 12, metrics.width + padding*2, 24);
                    
                    // æ–‡å­—ã‚’æç”»
                    ctx.fillStyle = '#3b82f6';
                    ctx.fillText(text, midX, midY);
                }
                
                // è¾ºåãƒ©ãƒ™ãƒ«
                ctx.font = 'bold 13px sans-serif';
                const textWidth = ctx.measureText(line.name).width;
                const padding = 8;
                const bgWidth = textWidth + padding * 2;
                const bgHeight = 20;
                
                // èƒŒæ™¯
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.fillRect(midX - bgWidth/2, midY - bgHeight/2 - 35, bgWidth, bgHeight);
                
                // æ–‡å­—
                ctx.fillStyle = '#333';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(line.name, midX, midY - 35);
            });
            
            // æ—¢ã«æç”»ã—ãŸã‚³ãƒ¼ãƒŠãƒ¼ã‚’è¨˜éŒ²
            const drawnCorners = new Set();
            
            // ã‚³ãƒ¼ãƒŠãƒ¼ãƒ™ãƒ¼ã‚¹ã§ç‚¹ã‚’æç”»
            if (corners) {
                for (const cornerKey in corners) {
                    const corner = corners[cornerKey];
                    
                    if (!corner || drawnCorners.has(cornerKey)) continue;
                    drawnCorners.add(cornerKey);
                    
                    // ã“ã®ã‚³ãƒ¼ãƒŠãƒ¼ã«æ¥ç¶šã—ã¦ã„ã‚‹è¾ºã‚’å–å¾—
                    if (!corner.lines || corner.lines.length === 0) continue;
                    
                    // ã‚³ãƒ¼ãƒŠãƒ¼ã®åº§æ¨™ã‚’å–å¾—
                    const firstLineRef = corner.lines[0];
                    const firstLine = lines.find(l => l.id === firstLineRef.lineId);
                    if (!firstLine) continue;
                    
                    const cornerX = corner.x !== undefined ? corner.x : (firstLine[firstLineRef.point === 'start' ? 'x1' : 'x2']);
                    const cornerY = corner.y !== undefined ? corner.y : (firstLine[firstLineRef.point === 'start' ? 'y1' : 'y2']);
                    
                    // æ®µå·®ãŒã‚ã‚‹å ´åˆã¯2ã¤ã®ç‚¹ã€ãªã„å ´åˆã¯1ã¤ã®ç‚¹
                    if (corner.hasStep && corner.lines.length >= 2) {
                        // 2ã¤ã®è¾ºã‹ã‚‰çŠ¶æ…‹ã‚’å–å¾—
                        const line1Ref = corner.lines[0];
                        const line2Ref = corner.lines[1];
                        const line1 = lines.find(l => l.id === line1Ref.lineId);
                        const line2 = lines.find(l => l.id === line2Ref.lineId);
                        
                        if (line1 && line2) {
                            const state1 = line1[line1Ref.point] || 'wall';
                            const state2 = line2[line2Ref.point] || 'wall';
                            
                            const offset = 20; // è§’ã‹ã‚‰ã®ãšã‚‰ã—è·é›¢
                            
                            // line1ã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—ï¼ˆè§’ã‹ã‚‰ç·šã«æ²¿ã£ã¦é€²ã‚€æ–¹å‘ï¼‰
                            let dx1, dy1;
                            if (line1Ref.point === 'start') {
                                dx1 = line1.x2 - line1.x1;
                                dy1 = line1.y2 - line1.y1;
                            } else {
                                dx1 = line1.x1 - line1.x2;
                                dy1 = line1.y1 - line1.y2;
                            }
                            const len1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
                            
                            // line2ã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—ï¼ˆè§’ã‹ã‚‰ç·šã«æ²¿ã£ã¦é€²ã‚€æ–¹å‘ï¼‰
                            let dx2, dy2;
                            if (line2Ref.point === 'start') {
                                dx2 = line2.x2 - line2.x1;
                                dy2 = line2.y2 - line2.y1;
                            } else {
                                dx2 = line2.x1 - line2.x2;
                                dy2 = line2.y1 - line2.y2;
                            }
                            const len2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                            
                            if (len1 > 0 && len2 > 0) {
                                // æ­£è¦åŒ–ã•ã‚ŒãŸæ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«
                                const dirX1 = dx1 / len1;
                                const dirY1 = dy1 / len1;
                                const dirX2 = dx2 / len2;
                                const dirY2 = dy2 / len2;
                                
                                // å„ç·šã®æ–¹å‘ã«æ²¿ã£ã¦è§’ã‹ã‚‰ãšã‚‰ã—ãŸä½ç½®ã«ç‚¹ã‚’é…ç½®
                                const p1 = transform(cornerX + dirX1 * offset, cornerY + dirY1 * offset);
                                const p2 = transform(cornerX + dirX2 * offset, cornerY + dirY2 * offset);
                                
                                drawPoint(p1.x, p1.y, state1);
                                drawPoint(p2.x, p2.y, state2);
                            } else {
                                // æ–¹å‘ãŒå®šã¾ã‚‰ãªã„å ´åˆã¯1ã¤ã ã‘
                                const p = transform(cornerX, cornerY);
                                drawPoint(p.x, p.y, state1);
                            }
                        }
                    } else {
                        // æ®µå·®ãªã—ï¼š1ã¤ã®ç‚¹ï¼ˆåº§æ¨™å¤‰æ›é©ç”¨ï¼‰
                        const state = firstLine[firstLineRef.point] || 'wall';
                        const p = transform(cornerX, cornerY);
                        drawPoint(p.x, p.y, state);
                    }
                }
            }
            
            // æç”»ä¸­ã®ãƒã‚¤ãƒ³ãƒˆã‚’è¡¨ç¤º
            drawingPoints.forEach((point, index) => {
                ctx.fillStyle = '#f39c12';
                ctx.beginPath();
                ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }
        
        // ç‚¹ã‚’æç”»
        function drawPoint(x, y, state) {
            const colors = {
                'corner': '#e74c3c', // èµ¤ï¼šã‚³ãƒ¼ãƒŠãƒ¼
                'end': '#3498db',    // é’ï¼šã‚¨ãƒ³ãƒ‰
                'wall': '#2ecc71'    // ç·‘ï¼šå£
            };
            
            ctx.fillStyle = colors[state] || colors['end'];
            ctx.beginPath();
            ctx.arc(x, y, 10, 0, Math.PI * 2); // 8ã‹ã‚‰10ã«å¤‰æ›´
            ctx.fill();
            
            // ç™½ã„æ 
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3; // 2ã‹ã‚‰3ã«å¤‰æ›´
            ctx.stroke();
        }
        
        // å…¥åŠ›ãƒ•ã‚©ãƒ¼ãƒ ä½œæˆ
        function createInputs() {
            const container = document.getElementById('dimension-inputs');
            container.innerHTML = '';
            
            // ã‚³ãƒ¼ãƒŠãƒ¼ã‚’æ¤œå‡º
            detectCorners();
            
            // ç‚¹ã®èª¬æ˜
            const infoDiv = document.createElement('div');
            infoDiv.style.cssText = 'background: #e3f2fd; padding: 12px; border-radius: 8px; margin-bottom: 15px;';
            infoDiv.innerHTML = `
                <p style="margin: 0; color: #555; font-size: 14px; line-height: 1.6;">
                    <span style="color: #e74c3c; font-size: 16px;">â—</span> <strong>èµ¤ï¼ã‚³ãƒ¼ãƒŠãƒ¼</strong>ï¼ˆèº¯ä½“å¹…Ã·2ã‚’å¼•ãï¼‰ã€€
                    <span style="color: #3498db; font-size: 16px;">â—</span> <strong>é’ï¼ã‚¨ãƒ³ãƒ‰</strong>ï¼ˆå£ãªã—ï¼‰ã€€
                    <span style="color: #2ecc71; font-size: 16px;">â—</span> <strong>ç·‘ï¼å£</strong>ï¼ˆå£ã‚ã‚Šï¼‰
                </p>
            `;
            container.appendChild(infoDiv);
            
            // èº¯ä½“å¹…ãƒ»é«˜ã•å…¥åŠ›
            const widthDiv = document.createElement('div');
            widthDiv.style.cssText = 'background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px;';
            widthDiv.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                    <div>
                        <label style="display: block; color: #555; font-weight: bold; margin-bottom: 8px;">èº¯ä½“å¹… (mm)</label>
                        <input type="number" id="common-width" placeholder="ä¾‹: 180" value="${commonWidth || ''}" 
                               oninput="updateCommonWidth(this.value)" 
                               style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px;">
                    </div>
                    <div>
                        <label style="display: block; color: #555; font-weight: bold; margin-bottom: 8px;">èº¯ä½“é«˜ã• (mm)</label>
                        <input type="number" id="common-height" placeholder="ä¾‹: 1100" value="${commonHeight || ''}" 
                               oninput="updateCommonHeight(this.value)" 
                               style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px;">
                    </div>
                </div>
                <div>
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="individual-width-check" ${useIndividualWidth ? 'checked' : ''} 
                               onchange="toggleIndividualWidth(this.checked)"
                               style="width: 18px; height: 18px; margin-right: 8px; cursor: pointer;">
                        <span style="color: #555; font-size: 14px;">è¾ºã”ã¨ã«èº¯ä½“å¹…ã‚’è¨­å®š</span>
                    </label>
                </div>
            `;
            container.appendChild(widthDiv);
            
            // å„è¾ºã®å…¥åŠ›
            lines.forEach((line, lineIndex) => {
                const div = document.createElement('div');
                div.className = 'dimension-item';
                div.setAttribute('data-line-id', line.id);  // IDã‚’è¿½åŠ 
                
                // ã‚³ãƒ¼ãƒŠãƒ¼ã®æ®µå·®çŠ¶æ…‹ã‚’ç¢ºèª
                const startKey = findCornerKey(line.x1, line.y1, 5);
                const endKey = findCornerKey(line.x2, line.y2, 5);
                const startCorner = corners[startKey];
                const endCorner = corners[endKey];
                
                // æ®µå·®ãŒã‚ã‚‹å ´åˆã®çŠ¶æ…‹ã‚’å–å¾—
                const startHasStep = startCorner && startCorner.hasStep;
                const endHasStep = endCorner && endCorner.hasStep;
                
                // ç‚¹ã®çŠ¶æ…‹ã‚’å–å¾—
                let startState = line.start || 'wall';
                let endState = line.end || 'wall';
                
                // æ–œã‚ç·šã‹ã©ã†ã‹åˆ¤å®š
                const isDiagonal = isLineDiagonal(line);
                const angle = isDiagonal ? getLineAngle(line).toFixed(1) : null;
                
                // å€‹åˆ¥èº¯ä½“å¹…å…¥åŠ›æ¬„
                const widthInput = useIndividualWidth ? `
                    <input type="number" placeholder="èº¯ä½“å¹… (mm)" 
                           oninput="updateDimension('${line.id}', 'width', this.value)"
                           value="${dimensions[line.id]?.width || ''}"
                           style="padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 16px;">
                ` : '';
                
                // è§’åº¦å…¥åŠ›æ¬„ï¼ˆæ–œã‚ç·šã®å ´åˆã®ã¿ï¼‰
                const angleInput = isDiagonal ? `
                    <div style="margin-top: 10px; padding: 10px; background: #fff3cd; border-radius: 6px; border: 2px solid #ffc107;">
                        <label style="display: block; color: #856404; font-weight: bold; margin-bottom: 5px; font-size: 13px;">
                            âš ï¸ æ–œã‚ç·šï¼šè§’åº¦ï¼ˆåº¦ï¼‰
                        </label>
                        <input type="number" placeholder="è§’åº¦ (åº¦)" 
                               value="${angle || ''}"
                               oninput="updateLineAngle('${line.id}', this.value)"
                               style="width: 100%; padding: 10px; border: 2px solid #ffc107; border-radius: 6px; font-size: 16px;">
                        <p style="margin: 5px 0 0 0; font-size: 12px; color: #856404;">ç¾åœ¨ã®è§’åº¦: ${angle}Â°</p>
                    </div>
                ` : '';
                
                // ç‚¹ã®çŠ¶æ…‹ãƒœã‚¿ãƒ³ï¼ˆé€šå¸¸ï¼‰
                const pointButtons = `
                    <div style="display: flex; gap: 8px;">
                        <button onclick="changePointState('${line.id}', 'start')" style="padding: 6px 12px; background: ${getStateColor(startState)}; color: white; border: none; border-radius: 6px; font-size: 12px; font-weight: bold; cursor: pointer;">
                            å§‹ç‚¹: ${getStateLabel(startState)}
                        </button>
                        <button onclick="changePointState('${line.id}', 'end')" style="padding: 6px 12px; background: ${getStateColor(endState)}; color: white; border: none; border-radius: 6px; font-size: 12px; font-weight: bold; cursor: pointer;">
                            çµ‚ç‚¹: ${getStateLabel(endState)}
                        </button>
                    </div>
                `;
                
                div.innerHTML = `
                    <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <span style="font-weight: bold; color: #667eea;">${line.name}${isDiagonal ? ' <span style="color: #ff9800;">âš ï¸æ–œã‚</span>' : ''}</span>
                        ${pointButtons}
                    </label>
                    <div class="dimension-row" style="display: grid; grid-template-columns: ${useIndividualWidth ? '1fr 1fr' : '1fr'}; gap: 10px;">
                        <input type="number" placeholder="å¤–æ³•å¯¸æ³• (mm)" 
                               oninput="updateDimension('${line.id}', 'length', this.value)"
                               value="${dimensions[line.id]?.length || ''}"
                               style="padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 16px;">
                        ${widthInput}
                    </div>
                    ${angleInput}
                `;
                container.appendChild(div);
                
                if (!dimensions[line.id]) {
                    dimensions[line.id] = { length: null, width: null };
                }
                
                // ã“ã®è¾ºã®çµ‚ç‚¹ãŒã‚³ãƒ¼ãƒŠãƒ¼ã®å ´åˆã€æ®µå·®è¨­å®šã‚’è¿½åŠ 
                if (endCorner && endCorner.lines.length >= 2 && lineIndex < lines.length - 1) {
                    const cornerDiv = document.createElement('div');
                    cornerDiv.style.cssText = 'margin: 10px 0 20px 0; padding: 12px; background: #e8f5e9; border-radius: 6px; border: 2px solid #4caf50;';
                    
                    const nextLine = lines[lineIndex + 1];
                    const cornerLabel = `${line.name}â”${nextLine.name}`;
                    
                    cornerDiv.innerHTML = `
                        <label style="display: flex; align-items: center; cursor: pointer; margin-bottom: 8px;">
                            <input type="checkbox" ${endCorner.hasStep ? 'checked' : ''} 
                                   onchange="toggleCornerStep('${endKey}', this.checked)"
                                   style="width: 18px; height: 18px; margin-right: 8px; cursor: pointer;">
                            <span style="color: #2e7d32; font-weight: bold; font-size: 14px;">ğŸ“ ${cornerLabel} ã«æ®µå·®ã‚ã‚Š</span>
                        </label>
                        ${endCorner.hasStep ? `
                            <input type="number" placeholder="æ·±ã• (mm)" 
                                   value="${endCorner.depth || ''}"
                                   oninput="updateCornerDepth('${endKey}', this.value)"
                                   style="width: 100%; padding: 8px; border: 2px solid #4caf50; border-radius: 6px; font-size: 14px;">
                        ` : ''}
                    `;
                    container.appendChild(cornerDiv);
                }
            });
        }
        
        // è§’åº¦ã‚’æ›´æ–°ã—ã¦ç·šã‚’å†è¨ˆç®—
        function updateLineAngle(lineId, angleDegrees) {
            const lineIndex = lines.findIndex(line => line.id === lineId);
            if (lineIndex === -1) return;
            
            const line = lines[lineIndex];
            const angle = parseFloat(angleDegrees);
            if (isNaN(angle)) return;
            
            // ç·šã®é•·ã•ã‚’è¨ˆç®—
            const dx = line.x2 - line.x1;
            const dy = line.y2 - line.y1;
            const length = Math.sqrt(dx * dx + dy * dy);
            
            // æ–°ã—ã„è§’åº¦ã§çµ‚ç‚¹ã‚’å†è¨ˆç®—
            const radians = angle * (Math.PI / 180);
            line.x2 = line.x1 + length * Math.cos(radians);
            line.y2 = line.y1 + length * Math.sin(radians);
            
            drawLines();
            createInputs();
        }
        
        // èº¯ä½“å¹…ã‚’æ›´æ–°
        function updateCommonWidth(value) {
            commonWidth = value ? parseFloat(value) : null;
            if (!useIndividualWidth) {
                // å…¨ã¦ã®è¾ºã«é©ç”¨
                lines.forEach(line => {
                    if (dimensions[line.id]) {
                        dimensions[line.id].width = commonWidth;
                    }
                });
                drawLines();
                calculate();
            }
        }
        
        // èº¯ä½“é«˜ã•ã‚’æ›´æ–°
        function updateCommonHeight(value) {
            commonHeight = value ? parseFloat(value) : null;
            drawLines();
            calculate();
        }
        
        // ã‚³ãƒ¼ãƒŠãƒ¼ã®æ®µå·®ã‚’åˆ‡ã‚Šæ›¿ãˆ
        function toggleCornerStep(cornerKey, hasStep) {
            if (!corners[cornerKey]) return;
            
            corners[cornerKey].hasStep = hasStep;
            const corner = corners[cornerKey];
            
            if (!hasStep) {
                // ãƒã‚§ãƒƒã‚¯ã‚’å¤–ã—ãŸæ™‚ï¼šã‚³ãƒ¼ãƒŠãƒ¼ã«æˆ»ã™
                corners[cornerKey].depth = null;
                corner.lines.forEach(lineRef => {
                    const line = lines.find(l => l.id === lineRef.lineId);
                    if (line) {
                        line[lineRef.point] = 'corner';
                    }
                });
            } else {
                // æ®µå·®ã‚’æœ‰åŠ¹ã«ã—ãŸå ´åˆã€1ã¤ç›®ã‚’ã‚¨ãƒ³ãƒ‰ã€æ®‹ã‚Šã‚’å£ã«
                corner.lines.forEach((lineRef, index) => {
                    const line = lines.find(l => l.id === lineRef.lineId);
                    if (line) {
                        if (index === 0) {
                            line[lineRef.point] = 'end';
                        } else {
                            line[lineRef.point] = 'wall';
                        }
                    }
                });
            }
            
            drawLines();
            createInputs();
        }
        
        // ã‚³ãƒ¼ãƒŠãƒ¼ã®æ·±ã•ã‚’æ›´æ–°
        function updateCornerDepth(cornerKey, depth) {
            if (!corners[cornerKey]) return;
            
            corners[cornerKey].depth = depth ? parseFloat(depth) : null;
        }
        
        // å€‹åˆ¥è¨­å®šã®åˆ‡ã‚Šæ›¿ãˆ
        function toggleIndividualWidth(checked) {
            useIndividualWidth = checked;
            if (!checked && commonWidth) {
                // å€‹åˆ¥â†’å…±é€šã«åˆ‡ã‚Šæ›¿ãˆï¼šå…±é€šå€¤ã‚’å…¨è¾ºã«é©ç”¨
                lines.forEach(line => {
                    if (dimensions[line.id]) {
                        dimensions[line.id].width = commonWidth;
                    }
                });
            }
            createInputs();
            drawLines();
            calculate();
        }
        
        // çŠ¶æ…‹ã®è‰²ã‚’å–å¾—
        function getStateColor(state) {
            const colors = {
                'corner': '#e74c3c',
                'end': '#3498db',
                'wall': '#2ecc71'
            };
            return colors[state] || colors['end'];
        }
        
        // çŠ¶æ…‹ã®ãƒ©ãƒ™ãƒ«ã‚’å–å¾—
        function getStateLabel(state) {
            const labels = {
                'corner': 'ã‚³ãƒ¼ãƒŠãƒ¼',
                'end': 'ã‚¨ãƒ³ãƒ‰',
                'wall': 'å£'
            };
            return labels[state] || labels['end'];
        }
        
        // ãƒœã‚¿ãƒ³ã‹ã‚‰ç‚¹ã®çŠ¶æ…‹ã‚’å¤‰æ›´
        function changePointState(lineId, point) {
            const lineIndex = lines.findIndex(line => line.id === lineId);
            if (lineIndex === -1) return;
            
            const line = lines[lineIndex];
            
            // ã“ã®ç‚¹ã®ã‚³ãƒ¼ãƒŠãƒ¼ã‚­ãƒ¼ã‚’å–å¾—
            const x = point === 'start' ? line.x1 : line.x2;
            const y = point === 'start' ? line.y1 : line.y2;
            const cornerKey = findCornerKey(x, y, 5);
            const corner = corners[cornerKey];
            
            // å›³å½¢ãŒé–‰ã˜ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆæœ€åˆã®ç·šã®å§‹ç‚¹ã¨æœ€å¾Œã®ç·šã®çµ‚ç‚¹ãŒåŒã˜ä½ç½®ï¼‰
            const isClosed = lines.length > 0 && 
                Math.abs(lines[0].x1 - lines[lines.length - 1].x2) < 5 && 
                Math.abs(lines[0].y1 - lines[lines.length - 1].y2) < 5;
            
            // æœ€åˆã®ç·šã®å§‹ç‚¹ã¯ã‚³ãƒ¼ãƒŠãƒ¼ã«ãªã‚Œãªã„ï¼ˆé–‰ã˜ã¦ã„ã‚‹å ´åˆã¯é™¤ãï¼‰
            const isFirstLineStart = (lineIndex === 0 && point === 'start' && !isClosed);
            
            // æœ€å¾Œã®ç·šã®çµ‚ç‚¹ã¯ã‚³ãƒ¼ãƒŠãƒ¼ã«ãªã‚Œãªã„ï¼ˆé–‰ã˜ã¦ã„ã‚‹å ´åˆã¯é™¤ãï¼‰
            const isLastLineEnd = (lineIndex === lines.length - 1 && point === 'end' && !isClosed);
            
            // æ®µå·®ãŒã‚ã‚‹ã‚³ãƒ¼ãƒŠãƒ¼ã®å ´åˆã¯ã€ã‚³ãƒ¼ãƒŠãƒ¼é¸æŠã‚’é™¤å¤–
            const hasStepAtCorner = corner && corner.hasStep;
            
            // é¸æŠå¯èƒ½ãªçŠ¶æ…‹ã‚’æ±ºå®š
            let states;
            if (isFirstLineStart || isLastLineEnd || hasStepAtCorner) {
                states = ['end', 'wall'];
            } else {
                states = ['corner', 'end', 'wall'];
            }
            
            const currentState = lines[lineIndex][point] || 'wall';
            const currentIndex = states.indexOf(currentState);
            const nextIndex = (currentIndex + 1) % states.length;
            lines[lineIndex][point] = states[nextIndex];
            
            // ã‚³ãƒ¼ãƒŠãƒ¼ã«å¤‰æ›´ã—ãŸå ´åˆã€åŒã˜ä½ç½®ã®ç‚¹ã‚‚é€£å‹•
            if (lines[lineIndex][point] === 'corner') {
                autoSetCorners();
            }
            
            // æ®µå·®ãŒã‚ã‚‹ã‚³ãƒ¼ãƒŠãƒ¼ã§çŠ¶æ…‹ã‚’å¤‰æ›´ã—ãŸå ´åˆã€æ¥ç¶šã—ã¦ã„ã‚‹è¾ºã®çŠ¶æ…‹ã‚’è‡ªå‹•èª¿æ•´
            if (corner && corner.hasStep && corner.lines.length >= 2) {
                syncCornerStatesWithStep(cornerKey, lineId, point, lines[lineIndex][point]);
            }
            
            // å†æç”»
            drawLines();
            createInputs(); // ãƒœã‚¿ãƒ³ã®è‰²ã‚’æ›´æ–°
            calculate();
        }
        
        // æ®µå·®ãŒã‚ã‚‹ã‚³ãƒ¼ãƒŠãƒ¼ã®çŠ¶æ…‹ã‚’åŒæœŸï¼ˆç‰‡æ–¹ãŒã‚¨ãƒ³ãƒ‰â†’ã‚‚ã†ç‰‡æ–¹ã¯å£ï¼‰
        function syncCornerStatesWithStep(cornerKey, changedLineId, changedPoint, newState) {
            const corner = corners[cornerKey];
            if (!corner) return;
            
            // ã“ã®ã‚³ãƒ¼ãƒŠãƒ¼ã«æ¥ç¶šã—ã¦ã„ã‚‹è¾ºã‚’å–å¾—
            corner.lines.forEach(lineRef => {
                const line = lines.find(l => l.id === lineRef.lineId);
                if (!line) return;
                
                // å¤‰æ›´ã—ãŸè¾ºä»¥å¤–ã®è¾ºã®çŠ¶æ…‹ã‚’èª¿æ•´
                if (line.id !== changedLineId) {
                    if (newState === 'end') {
                        // ç‰‡æ–¹ãŒã‚¨ãƒ³ãƒ‰ â†’ ã‚‚ã†ç‰‡æ–¹ã¯å£
                        line[lineRef.point] = 'wall';
                    } else if (newState === 'wall') {
                        // ç‰‡æ–¹ãŒå£ â†’ ã‚‚ã†ç‰‡æ–¹ã¯ã‚¨ãƒ³ãƒ‰ã¾ãŸã¯å£ï¼ˆå¤‰æ›´ã—ãªã„ï¼‰
                        // ä½•ã‚‚ã—ãªã„
                    }
                }
            });
        }
        
        // å¯¸æ³•æ›´æ–°
        function updateDimension(id, type, value) {
            if (!dimensions[id]) {
                dimensions[id] = { length: null, width: null };
            }
            
            dimensions[id][type] = value ? parseFloat(value) : null;
            
            // å›³é¢ã‚’å†æç”»ï¼ˆã‚¹ã‚±ãƒ¼ãƒ«èª¿æ•´ã¯ã—ãªã„ï¼‰
            drawLines();
            calculate();
        }
        
        // è¨ˆç®—
        function calculate() {
            const resultsContent = document.getElementById('results-content');
            let html = '';
            let hasAll = true;
            let missingItems = []; // æœªå…¥åŠ›é …ç›®ãƒªã‚¹ãƒˆ
            
            // ã‚³ãƒ¼ãƒŠãƒ¼ã‚’æ¤œå‡º
            detectCorners();
            
            // å…¥åŠ›ãƒã‚§ãƒƒã‚¯
            lines.forEach(line => {
                const dim = dimensions[line.id];
                
                // å¤–æ³•å¯¸æ³•ã®ãƒã‚§ãƒƒã‚¯
                if (!dim || !dim.length) {
                    hasAll = false;
                    missingItems.push(`${line.name}ã®å¤–æ³•å¯¸æ³•`);
                }
                
                // èº¯ä½“å¹…ã®ãƒã‚§ãƒƒã‚¯
                const hasWidth = useIndividualWidth ? (dim && dim.width) : commonWidth;
                if (!hasWidth) {
                    hasAll = false;
                    if (useIndividualWidth) {
                        missingItems.push(`${line.name}ã®èº¯ä½“å¹…`);
                    } else if (!commonWidth) {
                        // èº¯ä½“å¹…ã®ãƒã‚§ãƒƒã‚¯ï¼ˆé‡è¤‡ã‚’é¿ã‘ã‚‹ãŸã‚ä¸€åº¦ã ã‘è¿½åŠ ï¼‰
                        if (!missingItems.includes('èº¯ä½“å¹…')) {
                            missingItems.push('èº¯ä½“å¹…');
                        }
                    }
                }
            });
            
            // èº¯ä½“é«˜ã•ã®ãƒã‚§ãƒƒã‚¯
            if (!commonHeight) {
                hasAll = false;
                missingItems.push('èº¯ä½“é«˜ã•');
            }
            
            // æ®µå·®å¯¸æ³•ã®ãƒã‚§ãƒƒã‚¯
            if (corners) {
                for (const cornerKey in corners) {
                    const corner = corners[cornerKey];
                    if (corner && corner.hasStep) {
                        // æ®µå·®ãŒã‚ã‚‹å ´åˆã€æ·±ã•ãŒå…¥åŠ›ã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                        if (!corner.depth) {
                            hasAll = false;
                            // ã‚³ãƒ¼ãƒŠãƒ¼ã«æ¥ç¶šã—ã¦ã„ã‚‹è¾ºã®åå‰ã‚’å–å¾—
                            if (corner.lines && corner.lines.length >= 2) {
                                const line1 = lines.find(l => l.id === corner.lines[0].lineId);
                                const line2 = lines.find(l => l.id === corner.lines[1].lineId);
                                if (line1 && line2) {
                                    missingItems.push(`${line1.name}â”${line2.name}ã®æ®µå·®å¯¸æ³•`);
                                } else {
                                    missingItems.push('æ®µå·®å¯¸æ³•');
                                }
                            } else {
                                missingItems.push('æ®µå·®å¯¸æ³•');
                            }
                        }
                    }
                }
            }
            
            // å…¨ã¦å…¥åŠ›ã•ã‚Œã¦ã„ã‚‹å ´åˆã®ã¿è¨ˆç®—çµæœã‚’è¡¨ç¤º
            if (hasAll) {
                lines.forEach(line => {
                    const dim = dimensions[line.id];
                    let result = dim.length;
                    
                    // å§‹ç‚¹ãŒã‚³ãƒ¼ãƒŠãƒ¼ãªã‚‰éš£æ¥ã™ã‚‹è¾ºã®å¹…ã®åŠåˆ†ã‚’å¼•ã
                    if (line.start === 'corner') {
                        const adjacentWidth = getAdjacentLineWidth(line.id, 'start');
                        if (adjacentWidth > 0) {
                            result -= adjacentWidth / 2;
                        }
                    }
                    
                    // çµ‚ç‚¹ãŒã‚³ãƒ¼ãƒŠãƒ¼ãªã‚‰éš£æ¥ã™ã‚‹è¾ºã®å¹…ã®åŠåˆ†ã‚’å¼•ã
                    if (line.end === 'corner') {
                        const adjacentWidth = getAdjacentLineWidth(line.id, 'end');
                        if (adjacentWidth > 0) {
                            result -= adjacentWidth / 2;
                        }
                    }
                    
                    const startLabel = getPointLabel(line.start);
                    const endLabel = getPointLabel(line.end);
                    
                    html += `
                        <div class="result-item">
                            <span class="result-label">${line.name} ${startLabel}â”${endLabel}</span>
                            <span class="result-value">${Math.floor(result)} mm</span>
                        </div>
                    `;
                });
                
                // ã‚­ãƒ£ãƒ³ãƒã‚¹ã¨ä¿å­˜ãƒœã‚¿ãƒ³ã‚’è¿½åŠ ã—ã¦å›³ã‚’æç”»
                html = `
                    <div style="margin-bottom: 20px;">
                        <canvas id="result-canvas" width="500" height="400" style="width: 100%; border-radius: 10px;"></canvas>
                    </div>
                    
                    <!-- ä¿å­˜ãƒ»å…±æœ‰ãƒœã‚¿ãƒ³ -->
                    <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
                        <button onclick="downloadAsPDF()" style="flex: 1; min-width: 140px; padding: 12px 20px; background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                            ğŸ“„ PDFã§ä¿å­˜
                        </button>
                        <button onclick="downloadAsPNG()" style="flex: 1; min-width: 140px; padding: 12px 20px; background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                            ğŸ–¼ï¸ ç”»åƒã§ä¿å­˜
                        </button>
                        <button onclick="shareResult()" style="flex: 1; min-width: 140px; padding: 12px 20px; background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                            ğŸ“¤ å…±æœ‰
                        </button>
                    </div>
                ` + html;
                
                resultsContent.innerHTML = html;
                
                // å›³ã‚’æç”»
                drawResultDiagram();
            } else {
                // å…¥åŠ›æ¼ã‚ŒãŒã‚ã‚‹å ´åˆã€èµ¤æ–‡å­—ã§è­¦å‘Šè¡¨ç¤º
                const warningHtml = `
                    <div style="background: #fee; border: 2px solid #e74c3c; border-radius: 10px; padding: 20px; text-align: center;">
                        <div style="color: #e74c3c; font-size: 20px; font-weight: bold; margin-bottom: 15px;">
                            âš ï¸ å…¥åŠ›ãŒå®Œäº†ã—ã¦ã„ã¾ã›ã‚“
                        </div>
                        <div style="color: #c0392b; font-size: 16px; line-height: 1.8;">
                            ä»¥ä¸‹ã®é …ç›®ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼š<br>
                            <strong>${missingItems.join('ã€')}</strong>
                        </div>
                    </div>
                `;
                resultsContent.innerHTML = warningHtml;
            }
        }
        
        // éš£æ¥ã™ã‚‹è¾ºã®å¹…ã‚’å–å¾—
        function getAdjacentLineWidth(lineId, point) {
            // è©²å½“ã™ã‚‹è¾ºã‚’æ¢ã™
            const currentLine = lines.find(l => l.id === lineId);
            if (!currentLine) return 0;
            
            // ã‚³ãƒ¼ãƒŠãƒ¼ã‚­ãƒ¼ã‚’å–å¾—
            const x = point === 'start' ? currentLine.x1 : currentLine.x2;
            const y = point === 'start' ? currentLine.y1 : currentLine.y2;
            const cornerKey = findCornerKey(x, y, 5);
            
            if (!corners || !corners[cornerKey]) return 0;
            
            const corner = corners[cornerKey];
            
            // ã“ã®ã‚³ãƒ¼ãƒŠãƒ¼ã«æ¥ç¶šã—ã¦ã„ã‚‹ä»–ã®è¾ºã‚’æ¢ã™
            for (const lineRef of corner.lines) {
                if (lineRef.lineId !== lineId) {
                    // éš£æ¥ã™ã‚‹è¾ºãŒè¦‹ã¤ã‹ã£ãŸ
                    const adjacentLine = lines.find(l => l.id === lineRef.lineId);
                    if (adjacentLine) {
                        const adjacentDim = dimensions[lineRef.lineId];
                        if (adjacentDim && adjacentDim.width) {
                            return adjacentDim.width;
                        }
                    }
                }
            }
            
            return 0;
        }
        
        // è¨ˆç®—çµæœã®å›³ã‚’æç”»
        function drawResultDiagram() {
            const resultCanvas = document.getElementById('result-canvas');
            if (!resultCanvas) return;
            
            const ctx = resultCanvas.getContext('2d');
            
            // èƒŒæ™¯è‰²ã‚’å¡—ã‚‹ï¼ˆè¨ˆç®—çµæœã¨ã‚ã‹ã‚‹ã‚ˆã†ã«ï¼‰
            ctx.fillStyle = '#f0f9ff';
            ctx.fillRect(0, 0, resultCanvas.width, resultCanvas.height);
            
            if (lines.length === 0) return;
            
            // å®Ÿå¯¸æ³•ã‚’ä½¿ã£ã¦å›³å½¢ã‚’å†æ§‹ç¯‰
            const realLines = [];
            const minLength = 300; // æœ€å°è¡¨ç¤ºé•·ã•ï¼ˆpxï¼‰- è¦‹ã‚„ã™ã•å„ªå…ˆ
            
            // å„ç·šã®å®Ÿå¯¸æ³•ã«åŸºã¥ã„ã¦åº§æ¨™ã‚’è¨ˆç®—
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const dim = dimensions[line.id];
                
                if (!dim || !dim.length) continue;
                
                // å®Ÿéš›ã®é•·ã•ã‚’å–å¾—ï¼ˆmmï¼‰
                let realLength = dim.length;
                
                // ç·šã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—
                const dx = line.x2 - line.x1;
                const dy = line.y2 - line.y1;
                const originalLength = Math.sqrt(dx * dx + dy * dy);
                
                if (originalLength === 0) continue;
                
                // æ­£è¦åŒ–ã•ã‚ŒãŸæ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«
                const dirX = dx / originalLength;
                const dirY = dy / originalLength;
                
                // å®Ÿå¯¸æ³•ã‚’ãƒ”ã‚¯ã‚»ãƒ«ã«å¤‰æ›ï¼ˆ1mm = 0.2pxã€ãŸã ã—æœ€å°é•·ã•ã‚’ä¿è¨¼ï¼‰
                let displayLength = Math.max(realLength * 0.2, minLength);
                
                // å§‹ç‚¹åº§æ¨™ã‚’æ±ºå®š
                let startX = line.x1;
                let startY = line.y1;
                
                // ä»–ã®ç·šã¨ã®æ¥ç¶šã‚’ç¢ºèª
                for (let j = 0; j < realLines.length; j++) {
                    const prevLine = realLines[j].line;
                    
                    // ç¾åœ¨ã®ç·šã®å§‹ç‚¹ãŒã€æ—¢å­˜ã®ç·šã®çµ‚ç‚¹ã¨ä¸€è‡´ã™ã‚‹å ´åˆ
                    if (Math.abs(line.x1 - prevLine.x2) < 1 && Math.abs(line.y1 - prevLine.y2) < 1) {
                        startX = realLines[j].x2;
                        startY = realLines[j].y2;
                        break;
                    }
                    
                    // ç¾åœ¨ã®ç·šã®å§‹ç‚¹ãŒã€æ—¢å­˜ã®ç·šã®å§‹ç‚¹ã¨ä¸€è‡´ã™ã‚‹å ´åˆ
                    if (Math.abs(line.x1 - prevLine.x1) < 1 && Math.abs(line.y1 - prevLine.y1) < 1) {
                        startX = realLines[j].x1;
                        startY = realLines[j].y1;
                        break;
                    }
                }
                
                // çµ‚ç‚¹ã‚’è¨ˆç®—
                realLines.push({
                    x1: startX,
                    y1: startY,
                    x2: startX + dirX * displayLength,
                    y2: startY + dirY * displayLength,
                    line: line
                });
            }
            
            if (realLines.length === 0) return;
            
            // å…¨ã¦ã®ç‚¹ã®ç¯„å›²ã‚’å–å¾—
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            
            realLines.forEach(rLine => {
                minX = Math.min(minX, rLine.x1, rLine.x2);
                minY = Math.min(minY, rLine.y1, rLine.y2);
                maxX = Math.max(maxX, rLine.x1, rLine.x2);
                maxY = Math.max(maxY, rLine.y1, rLine.y2);
            });
            
            // å›³å½¢ã®å¹…ã¨é«˜ã•
            const shapeWidth = Math.max(maxX - minX, 1); // æœ€å°å€¤1ã‚’ä¿è¨¼
            const shapeHeight = Math.max(maxY - minY, 1); // æœ€å°å€¤1ã‚’ä¿è¨¼
            
            // ãƒãƒ¼ã‚¸ãƒ³
            const margin = 60;
            const canvasWidth = resultCanvas.width - margin * 2;
            const canvasHeight = resultCanvas.height - margin * 2;
            
            // ã‚¹ã‚±ãƒ¼ãƒ«ä¿‚æ•°ã‚’è¨ˆç®—ï¼ˆã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’ç¶­æŒï¼‰
            const scaleX = canvasWidth / shapeWidth;
            const scaleY = canvasHeight / shapeHeight;
            const scale = Math.min(scaleX, scaleY);
            
            // ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨ˆç®—ï¼ˆä¸­å¤®é…ç½®ï¼‰
            const scaledWidth = shapeWidth * scale;
            const scaledHeight = shapeHeight * scale;
            const offsetX = margin + (canvasWidth - scaledWidth) / 2 - minX * scale;
            const offsetY = margin + (canvasHeight - scaledHeight) / 2 - minY * scale;
            
            // åº§æ¨™å¤‰æ›é–¢æ•°
            function transformX(x) {
                return x * scale + offsetX;
            }
            
            function transformY(y) {
                return y * scale + offsetY;
            }
            
            // ç‚¹ã‚’æç”»ã™ã‚‹é–¢æ•°
            function drawResultPoint(x, y, state) {
                const colors = {
                    'corner': '#ef4444',
                    'end': '#3b82f6',
                    'wall': '#10b981'
                };
                
                ctx.fillStyle = colors[state] || colors['end'];
                ctx.beginPath();
                ctx.arc(transformX(x), transformY(y), 6, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(transformX(x), transformY(y), 6, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // ã‚³ãƒ¼ãƒŠãƒ¼ã‚’æ¤œå‡º
            detectCorners();
            
            // ç·šã‚’æç”»ï¼ˆé»’ä¸€è‰²ã«çµ±ä¸€ï¼‰
            realLines.forEach(rLine => {
                const line = rLine.line;
                
                ctx.strokeStyle = '#1a1a1a';
                ctx.lineWidth = 5;
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                ctx.moveTo(transformX(rLine.x1), transformY(rLine.y1));
                ctx.lineTo(transformX(rLine.x2), transformY(rLine.y2));
                ctx.stroke();
                
                // è¨ˆç®—çµæœã¨èº¯ä½“å¹…ã‚’ç·šã®å¤–å´ã«è¡¨ç¤º
                const dim = dimensions[line.id];
                if (dim && dim.length) {
                    let result = dim.length;
                    
                    // å§‹ç‚¹ãŒã‚³ãƒ¼ãƒŠãƒ¼ãªã‚‰éš£æ¥ã™ã‚‹è¾ºã®å¹…ã®åŠåˆ†ã‚’å¼•ã
                    if (line.start === 'corner') {
                        const adjacentWidth = getAdjacentLineWidth(line.id, 'start');
                        if (adjacentWidth > 0) {
                            result -= adjacentWidth / 2;
                        }
                    }
                    
                    // çµ‚ç‚¹ãŒã‚³ãƒ¼ãƒŠãƒ¼ãªã‚‰éš£æ¥ã™ã‚‹è¾ºã®å¹…ã®åŠåˆ†ã‚’å¼•ã
                    if (line.end === 'corner') {
                        const adjacentWidth = getAdjacentLineWidth(line.id, 'end');
                        if (adjacentWidth > 0) {
                            result -= adjacentWidth / 2;
                        }
                    }
                    
                    // ç·šã®ä¸­ç‚¹ã¨æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—
                    const midX = (rLine.x1 + rLine.x2) / 2;
                    const midY = (rLine.y1 + rLine.y2) / 2;
                    const dx = rLine.x2 - rLine.x1;
                    const dy = rLine.y2 - rLine.y1;
                    const lineLength = Math.sqrt(dx * dx + dy * dy);
                    
                    // ç·šã®å‚ç›´æ–¹å‘ã®ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆå·¦å´ã«é…ç½®ï¼‰
                    const perpX = -dy / lineLength;
                    const perpY = dx / lineLength;
                    
                    // ãƒ†ã‚­ã‚¹ãƒˆã®ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆç·šã®å¤–å´ã€30pxé›¢ã™ï¼‰
                    const offset = 30;
                    const textX = transformX(midX + perpX * offset);
                    const textY = transformY(midY + perpY * offset);
                    
                    // èŠ¯å¯¸æ³•ï¼ˆè¨ˆç®—çµæœï¼‰ã‚’ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆã«è¡¨ç¤º
                    ctx.font = 'bold 16px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    const resultText = `${Math.floor(result)}`;
                    const resultMetrics = ctx.measureText(resultText);
                    const padding = 6;
                    
                    // é»„è‰²ã®åŠé€æ˜èƒŒæ™¯ã§ç›®ç«‹ãŸã›ã‚‹ï¼ˆç·šãŒé€ã‘ã¦è¦‹ãˆã‚‹ï¼‰
                    ctx.fillStyle = 'rgba(254, 243, 199, 0.85)';
                    ctx.fillRect(textX - resultMetrics.width/2 - padding, textY - 10, resultMetrics.width + padding*2, 20);
                    
                    // æ ç·šã‚’è¿½åŠ 
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 1.5;
                    ctx.strokeRect(textX - resultMetrics.width/2 - padding, textY - 10, resultMetrics.width + padding*2, 20);
                    
                    // æ–‡å­—ã‚’æç”»ï¼ˆæ¿ƒã„é’ã§å¼·èª¿ï¼‰
                    ctx.fillStyle = '#1e40af';
                    ctx.fillText(resultText, textX, textY);
                    
                    // èº¯ä½“å¹…ã‚’å°ã•ãè¡¨ç¤ºï¼ˆèŠ¯å¯¸æ³•ã®ä¸‹ã€èƒŒæ™¯ä»˜ãï¼‰
                    if (dim.width) {
                        ctx.font = '10px sans-serif';
                        const widthText = `å¹…:${dim.width}`;
                        const widthMetrics = ctx.measureText(widthText);
                        const widthY = textY + 16;
                        const widthPadding = 3;
                        
                        // èƒŒæ™¯ï¼ˆåŠé€æ˜ã®è–„ã„ç°è‰²ï¼‰
                        ctx.fillStyle = 'rgba(243, 244, 246, 0.85)';
                        ctx.fillRect(textX - widthMetrics.width/2 - widthPadding, widthY - 7, widthMetrics.width + widthPadding*2, 14);
                        
                        // æ–‡å­—ï¼ˆç°è‰²ï¼‰
                        ctx.fillStyle = '#6b7280';
                        ctx.fillText(widthText, textX, widthY);
                    }
                }
            });
            
            // æ—¢ã«æç”»ã—ãŸã‚³ãƒ¼ãƒŠãƒ¼ã‚’è¨˜éŒ²
            const drawnCorners = new Set();
            
            // å…ƒã®åº§æ¨™ã‹ã‚‰realLinesåº§æ¨™ã¸ã®å¯¾å¿œãƒãƒƒãƒ—ã‚’ä½œæˆ
            const coordMap = new Map();
            realLines.forEach((rLine, idx) => {
                const line = rLine.line;
                // å§‹ç‚¹ã®å¯¾å¿œ
                const startKey = `${line.x1},${line.y1}`;
                if (!coordMap.has(startKey)) {
                    coordMap.set(startKey, { x: rLine.x1, y: rLine.y1 });
                }
                // çµ‚ç‚¹ã®å¯¾å¿œ
                const endKey = `${line.x2},${line.y2}`;
                if (!coordMap.has(endKey)) {
                    coordMap.set(endKey, { x: rLine.x2, y: rLine.y2 });
                }
            });
            
            // ã‚³ãƒ¼ãƒŠãƒ¼ãƒ™ãƒ¼ã‚¹ã§ç‚¹ã‚’æç”»
            if (corners) {
                for (const cornerKey in corners) {
                    const corner = corners[cornerKey];
                    
                    if (!corner || drawnCorners.has(cornerKey)) continue;
                    drawnCorners.add(cornerKey);
                    
                    if (!corner.lines || corner.lines.length === 0) continue;
                    
                    const firstLineRef = corner.lines[0];
                    const firstLine = lines.find(l => l.id === firstLineRef.lineId);
                    if (!firstLine) continue;
                    
                    // ã‚³ãƒ¼ãƒŠãƒ¼ã®å…ƒåº§æ¨™
                    const cornerX = corner.x !== undefined ? corner.x : (firstLine[firstLineRef.point === 'start' ? 'x1' : 'x2']);
                    const cornerY = corner.y !== undefined ? corner.y : (firstLine[firstLineRef.point === 'start' ? 'y1' : 'y2']);
                    
                    // å…ƒåº§æ¨™ã‹ã‚‰realLinesåº§æ¨™ã«å¤‰æ›
                    const coordKey = `${cornerX},${cornerY}`;
                    const realCoord = coordMap.get(coordKey);
                    
                    if (!realCoord) continue;
                    
                    // æ®µå·®ãŒã‚ã‚‹å ´åˆã¯2ã¤ã®ç‚¹ã€ãªã„å ´åˆã¯1ã¤ã®ç‚¹
                    if (corner.hasStep && corner.lines.length >= 2) {
                        // 2ã¤ã®è¾ºã‹ã‚‰çŠ¶æ…‹ã‚’å–å¾—
                        const line1Ref = corner.lines[0];
                        const line2Ref = corner.lines[1];
                        const line1 = lines.find(l => l.id === line1Ref.lineId);
                        const line2 = lines.find(l => l.id === line2Ref.lineId);
                        
                        if (line1 && line2) {
                            const state1 = line1[line1Ref.point] || 'wall';
                            const state2 = line2[line2Ref.point] || 'wall';
                            
                            const offset = 20; // è§’ã‹ã‚‰ã®ãšã‚‰ã—è·é›¢
                            
                            // line1ã«å¯¾å¿œã™ã‚‹realLineã‚’è¦‹ã¤ã‘ã‚‹
                            const rLine1 = realLines.find(rl => rl.line.id === line1.id);
                            const rLine2 = realLines.find(rl => rl.line.id === line2.id);
                            
                            if (rLine1 && rLine2) {
                                // line1ã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—ï¼ˆè§’ã‹ã‚‰ç·šã«æ²¿ã£ã¦é€²ã‚€æ–¹å‘ï¼‰
                                let dx1, dy1;
                                if (line1Ref.point === 'start') {
                                    dx1 = rLine1.x2 - rLine1.x1;
                                    dy1 = rLine1.y2 - rLine1.y1;
                                } else {
                                    dx1 = rLine1.x1 - rLine1.x2;
                                    dy1 = rLine1.y1 - rLine1.y2;
                                }
                                const len1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
                                
                                // line2ã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—ï¼ˆè§’ã‹ã‚‰ç·šã«æ²¿ã£ã¦é€²ã‚€æ–¹å‘ï¼‰
                                let dx2, dy2;
                                if (line2Ref.point === 'start') {
                                    dx2 = rLine2.x2 - rLine2.x1;
                                    dy2 = rLine2.y2 - rLine2.y1;
                                } else {
                                    dx2 = rLine2.x1 - rLine2.x2;
                                    dy2 = rLine2.y1 - rLine2.y2;
                                }
                                const len2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                                
                                if (len1 > 0 && len2 > 0) {
                                    // æ­£è¦åŒ–ã•ã‚ŒãŸæ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«
                                    const dirX1 = dx1 / len1;
                                    const dirY1 = dy1 / len1;
                                    const dirX2 = dx2 / len2;
                                    const dirY2 = dy2 / len2;
                                    
                                    // å„ç·šã®æ–¹å‘ã«æ²¿ã£ã¦è§’ã‹ã‚‰ãšã‚‰ã—ãŸä½ç½®ã«ç‚¹ã‚’é…ç½®
                                    drawResultPoint(realCoord.x + dirX1 * offset, realCoord.y + dirY1 * offset, state1);
                                    drawResultPoint(realCoord.x + dirX2 * offset, realCoord.y + dirY2 * offset, state2);
                                } else {
                                    drawResultPoint(realCoord.x, realCoord.y, state1);
                                }
                            } else {
                                drawResultPoint(realCoord.x, realCoord.y, state1);
                            }
                        }
                    } else {
                        const state = firstLine[firstLineRef.point] || 'wall';
                        drawResultPoint(realCoord.x, realCoord.y, state);
                    }
                }
            }
            
            // å‡¡ä¾‹ã‚’å³ä¸‹ã«ã‚·ãƒ³ãƒ—ãƒ«ã«æç”»ï¼ˆå½±ä»˜ãæ–‡å­—ï¼‰
            const legendX = resultCanvas.width - 85;
            const legendY = resultCanvas.height - 70;
            
            // å‡¡ä¾‹ã®ã‚¿ã‚¤ãƒˆãƒ«
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'left';
            
            // ã‚¿ã‚¤ãƒˆãƒ«ã®å½±
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillText('ç‚¹ã®ç¨®é¡', legendX + 1, legendY + 1);
            ctx.fillText('ç‚¹ã®ç¨®é¡', legendX - 1, legendY - 1);
            ctx.fillText('ç‚¹ã®ç¨®é¡', legendX + 1, legendY - 1);
            ctx.fillText('ç‚¹ã®ç¨®é¡', legendX - 1, legendY + 1);
            
            // ã‚¿ã‚¤ãƒˆãƒ«æœ¬ä½“
            ctx.fillStyle = '#1f2937';
            ctx.fillText('ç‚¹ã®ç¨®é¡', legendX, legendY);
            
            // å‡¡ä¾‹ã®é …ç›®
            const legendItems = [
                { color: '#ef4444', label: 'ã‚³ãƒ¼ãƒŠãƒ¼' },
                { color: '#3b82f6', label: 'ã‚¨ãƒ³ãƒ‰' },
                { color: '#10b981', label: 'å£' }
            ];
            
            legendItems.forEach((item, index) => {
                const itemY = legendY + 22 + index * 18;
                
                // è‰²ã®ä¸¸ï¼ˆå½±ä»˜ãï¼‰
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(legendX + 6, itemY + 1, 5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = item.color;
                ctx.beginPath();
                ctx.arc(legendX + 5, itemY, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // ãƒ©ãƒ™ãƒ«ã®å½±
                ctx.font = '11px sans-serif';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillText(item.label, legendX + 16, itemY + 5);
                ctx.fillText(item.label, legendX + 14, itemY + 3);
                ctx.fillText(item.label, legendX + 16, itemY + 3);
                ctx.fillText(item.label, legendX + 14, itemY + 5);
                
                // ãƒ©ãƒ™ãƒ«æœ¬ä½“
                ctx.fillStyle = '#374151';
                ctx.fillText(item.label, legendX + 15, itemY + 4);
            });
        }
        
        // ç‚¹ã®ãƒ©ãƒ™ãƒ«ã‚’å–å¾—
        function getPointLabel(state) {
            const labels = {
                'corner': '<span style="color: #e74c3c;">â—</span>',
                'end': '<span style="color: #3498db;">â—</span>',
                'wall': '<span style="color: #2ecc71;">â—</span>'
            };
            return labels[state] || labels['end'];
        }
        
        // ã‚«ã‚¹ã‚¿ãƒ ä½œå›³
        function setupCustomDrawing() {
            // å…¥åŠ›ãƒ•ã‚©ãƒ¼ãƒ ã‚’ã‚¯ãƒªã‚¢
            document.getElementById('dimension-inputs').innerHTML = `
                <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0; color: #1976d2; font-size: 16px;">ğŸ“ ä½œå›³æ–¹æ³•</h3>
                    <p style="margin: 0; color: #555; font-size: 14px;">
                        <strong>ã‚¯ãƒªãƒƒã‚¯</strong>ã§ç‚¹ã‚’æ‰“ã¡ã€ç·šã‚’é€£ç¶šã—ã¦å¼•ã<br>
                        <strong>ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯</strong>ã¾ãŸã¯ä¸‹ã®ãƒœã‚¿ãƒ³ã§ä½œå›³çµ‚äº†
                    </p>
                    <button onclick="finishDrawing()" style="width: 100%; padding: 12px; background: #27ae60; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: bold; cursor: pointer; margin-top: 10px;">
                        âœ“ ä½œå›³çµ‚äº†
                    </button>
                    <h3 style="margin: 15px 0 10px 0; color: #1976d2; font-size: 16px;">ğŸ¨ ç‚¹ã®æ„å‘³</h3>
                    <p style="margin: 0; color: #555; font-size: 14px;">
                        <span style="color: #e74c3c;">â—</span> èµ¤ï¼šã‚³ãƒ¼ãƒŠãƒ¼ï¼ˆèº¯ä½“å¹…Ã·2ã‚’å¼•ãï¼‰<br>
                        <span style="color: #3498db;">â—</span> é’ï¼šã‚¨ãƒ³ãƒ‰ï¼ˆç«¯éƒ¨ã€å£ãªã—ï¼‰<br>
                        <span style="color: #2ecc71;">â—</span> ç·‘ï¼šå£ï¼ˆå£ã‚ã‚Šï¼‰<br>
                        <strong>ä½œå›³çµ‚äº†å¾Œã€ç‚¹ã‚’ã‚¿ãƒƒãƒ—ã§åˆ‡ã‚Šæ›¿ãˆ</strong>
                    </p>
                </div>
            `;
            
            drawingPoints = [];
            
            // æ—¢å­˜ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’ã™ã¹ã¦å‰Šé™¤
            canvas.removeEventListener('mousedown', startDrawing);
            canvas.removeEventListener('mousemove', drawing);
            canvas.removeEventListener('mouseup', endDrawing);
            canvas.removeEventListener('click', handlePointClick);
            canvas.removeEventListener('touchend', handlePointClickTouch);
            
            // ä½œå›³ç”¨ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¨­å®š
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('mousemove', handleCanvasMouseMove);
            
            canvas.addEventListener('touchstart', handleTouchDrawing);
            canvas.addEventListener('touchmove', handleTouchDrawingMove);
            
            updateDrawingControls();
        }
        
        // Canvasã‚¯ãƒªãƒƒã‚¯å‡¦ç†ï¼ˆä½œå›³ç”¨ï¼‰
        function handleCanvasClick(e) {
            // ç‚¹ã®çŠ¶æ…‹åˆ‡ã‚Šæ›¿ãˆã¨ã®ç«¶åˆã‚’é¿ã‘ã‚‹
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let x = (e.offsetX || e.clientX - rect.left) * scaleX;
            let y = (e.offsetY || e.clientY - rect.top) * scaleY;
            
            // ã‚¹ãƒŠãƒƒãƒ—å‡¦ç†ï¼ˆ2ç‚¹ç›®ä»¥é™ï¼‰
            if (drawingPoints.length > 0) {
                const lastPoint = drawingPoints[drawingPoints.length - 1];
                const snapped = snapToAxis(lastPoint.x, lastPoint.y, x, y);
                x = snapped.x;
                y = snapped.y;
            }
            
            // å§‹ç‚¹ã¸ã®å¸ç€ã¨é–‰ã˜ã‚‹ç¢ºèªï¼ˆ3ç‚¹ä»¥ä¸Šã‚ã‚‹å ´åˆï¼‰
            if (drawingPoints.length >= 3) {
                const startPoint = drawingPoints[0];
                const distToStart = Math.sqrt(Math.pow(x - startPoint.x, 2) + Math.pow(y - startPoint.y, 2));
                
                // å§‹ç‚¹ã‹ã‚‰30pxä»¥å†…ï¼ˆç›´æ¥ã‚¯ãƒªãƒƒã‚¯ã¾ãŸã¯ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³çµŒç”±ï¼‰
                if (distToStart < 30) {
                    if (confirm('å›³å½¢ã‚’é–‰ã˜ã¾ã™ã‹ï¼Ÿ\nï¼ˆå§‹ç‚¹ã¨çµ‚ç‚¹ã‚’çµåˆã—ã¾ã™ï¼‰')) {
                        // å§‹ç‚¹ã«å¸ç€
                        x = startPoint.x;
                        y = startPoint.y;
                        
                        // ç‚¹ã‚’è¿½åŠ 
                        drawingPoints.push({ x, y });
                        
                        // æœ€å¾Œã®ç·šã‚’ä½œæˆ
                        const prevPoint = drawingPoints[drawingPoints.length - 2];
                        const currPoint = drawingPoints[drawingPoints.length - 1];
                        
                        const id = String.fromCharCode(65 + lines.length);
                        lines.push({
                            id: id,
                            x1: prevPoint.x,
                            y1: prevPoint.y,
                            x2: currPoint.x,
                            y2: currPoint.y,
                            name: `è¾º${id}`,
                            start: 'wall',
                            end: 'wall'
                        });
                        
                        // ã‚³ãƒ¼ãƒŠãƒ¼ã®è‡ªå‹•è¨­å®š
                        autoSetCorners();
                        
                        // ä½œå›³çµ‚äº†
                        finishDrawing();
                        return;
                    } else {
                        // ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ãŸå ´åˆã¯ä½•ã‚‚ã—ãªã„
                        return;
                    }
                }
            }
            
            // æ—¢å­˜ã®ç‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‹åˆ¤å®šï¼ˆãŸã ã—å§‹ç‚¹ã¯é™¤ãï¼‰
            const clickRadius = 20;
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                // å§‹ç‚¹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆ3ç‚¹ä»¥ä¸Šã‚ã‚‹å ´åˆï¼‰
                let isStartPoint = false;
                if (drawingPoints.length >= 3 && i === 0) {
                    const startPoint = drawingPoints[0];
                    const distToStart = Math.sqrt(Math.pow(line.x1 - startPoint.x, 2) + Math.pow(line.y1 - startPoint.y, 2));
                    isStartPoint = distToStart < 5; // å§‹ç‚¹ã¨åŒã˜ä½ç½®ãªã‚‰
                }
                
                const distStart = Math.sqrt(Math.pow(x - line.x1, 2) + Math.pow(y - line.y1, 2));
                const distEnd = Math.sqrt(Math.pow(x - line.x2, 2) + Math.pow(y - line.y2, 2));
                
                // å§‹ç‚¹ä»¥å¤–ã®æ—¢å­˜ã®ç‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´åˆã¯ç„¡è¦–
                if (!isStartPoint && distStart < clickRadius) {
                    return;
                }
                if (distEnd < clickRadius) {
                    return;
                }
            }
            
            // ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯åˆ¤å®š
            const currentTime = new Date().getTime();
            const timeDiff = currentTime - lastClickTime;
            lastClickTime = currentTime;
            
            if (timeDiff < 500 && drawingPoints.length > 0) {
                finishDrawing();
                return;
            }
            
            // ç‚¹ã‚’è¿½åŠ 
            drawingPoints.push({ x, y });
            
            // 2ç‚¹ä»¥ä¸Šã‚ã‚Œã°ç·šã‚’ä½œæˆ
            if (drawingPoints.length >= 2) {
                const prevPoint = drawingPoints[drawingPoints.length - 2];
                const currPoint = drawingPoints[drawingPoints.length - 1];
                
                const id = String.fromCharCode(65 + lines.length);
                lines.push({
                    id: id,
                    x1: prevPoint.x,
                    y1: prevPoint.y,
                    x2: currPoint.x,
                    y2: currPoint.y,
                    name: `è¾º${id}`,
                    start: 'wall',
                    end: 'wall'
                });
                
                // ã‚³ãƒ¼ãƒŠãƒ¼ã®è‡ªå‹•è¨­å®š
                autoSetCorners();
            }
            
            drawLines();
            updateDrawingControls();
        }
        
        // ãƒã‚¦ã‚¹ç§»å‹•æ™‚ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
        function handleCanvasMouseMove(e) {
            if (drawingPoints.length === 0) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let x = (e.offsetX || e.clientX - rect.left) * scaleX;
            let y = (e.offsetY || e.clientY - rect.top) * scaleY;
            
            // ã‚¹ãƒŠãƒƒãƒ—å‡¦ç†
            const lastPoint = drawingPoints[drawingPoints.length - 1];
            const snapped = snapToAxis(lastPoint.x, lastPoint.y, x, y);
            x = snapped.x;
            y = snapped.y;
            
            drawLines();
            
            // å§‹ç‚¹ã¸ã®ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã¨å¸ç€ï¼ˆ3ç‚¹ä»¥ä¸Šã‚ã‚‹å ´åˆï¼‰
            let snapToStart = false;
            if (drawingPoints.length >= 3) {
                const startPoint = drawingPoints[0];
                const threshold = 10; // ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³è¡¨ç¤ºã®é–¾å€¤
                
                // æ°´å¹³ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ï¼ˆYåº§æ¨™ãŒå§‹ç‚¹ã¨è¿‘ã„å ´åˆï¼‰
                if (Math.abs(y - startPoint.y) < threshold) {
                    // å§‹ç‚¹ã«å‘ã‹ã£ã¦æ°´å¹³ç·šã‚’å¼•ã
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(x, startPoint.y);
                    ctx.lineTo(startPoint.x, startPoint.y);
                    ctx.stroke();
                    
                    // Yåº§æ¨™ã‚’å§‹ç‚¹ã«åˆã‚ã›ã‚‹
                    y = startPoint.y;
                    
                    // Xåº§æ¨™ã‚‚å§‹ç‚¹ã¨è¿‘ã„å ´åˆã¯å¸ç€
                    if (Math.abs(x - startPoint.x) < threshold) {
                        x = startPoint.x;
                        snapToStart = true;
                    }
                }
                
                // å‚ç›´ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ï¼ˆXåº§æ¨™ãŒå§‹ç‚¹ã¨è¿‘ã„å ´åˆï¼‰
                if (Math.abs(x - startPoint.x) < threshold) {
                    // å§‹ç‚¹ã«å‘ã‹ã£ã¦å‚ç›´ç·šã‚’å¼•ã
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(startPoint.x, y);
                    ctx.lineTo(startPoint.x, startPoint.y);
                    ctx.stroke();
                    
                    // Xåº§æ¨™ã‚’å§‹ç‚¹ã«åˆã‚ã›ã‚‹
                    x = startPoint.x;
                    
                    // Yåº§æ¨™ã‚‚å§‹ç‚¹ã¨è¿‘ã„å ´åˆã¯å¸ç€
                    if (Math.abs(y - startPoint.y) < threshold) {
                        y = startPoint.y;
                        snapToStart = true;
                    }
                }
                
                // å§‹ç‚¹ã¨åˆè‡´ã—ãŸå ´åˆã€å§‹ç‚¹ã‚’å¤§ããè¡¨ç¤º
                if (snapToStart) {
                    ctx.fillStyle = '#f59e0b';
                    ctx.beginPath();
                    ctx.arc(startPoint.x, startPoint.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ç™½ã„ç¸å–ã‚Š
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
            
            // é€šå¸¸ã®ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ï¼ˆ90åº¦ï¼‰
            if (!snapToStart) {
                // æ°´å¹³ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³
                if (Math.abs(y - lastPoint.y) < 30) {
                    ctx.strokeStyle = '#10b981';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.moveTo(0, lastPoint.y);
                    ctx.lineTo(canvas.width, lastPoint.y);
                    ctx.stroke();
                }
                
                // å‚ç›´ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³
                if (Math.abs(x - lastPoint.x) < 30) {
                    ctx.strokeStyle = '#10b981';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.moveTo(lastPoint.x, 0);
                    ctx.lineTo(lastPoint.x, canvas.height);
                    ctx.stroke();
                }
            }
            
            // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç·š
            ctx.strokeStyle = snapToStart ? '#f59e0b' : '#667eea';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(lastPoint.x, lastPoint.y);
            ctx.lineTo(x, y);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        // æ°´å¹³ãƒ»å‚ç›´ã«ã‚¹ãƒŠãƒƒãƒ—
        function snapToAxis(x1, y1, x2, y2) {
            const dx = Math.abs(x2 - x1);
            const dy = Math.abs(y2 - y1);
            const threshold = 30; // ã‚¹ãƒŠãƒƒãƒ—åˆ¤å®šã®é–¾å€¤
            
            // æ°´å¹³ã«è¿‘ã„
            if (dx > dy && dy < threshold) {
                return { x: x2, y: y1 };
            }
            // å‚ç›´ã«è¿‘ã„
            else if (dy > dx && dx < threshold) {
                return { x: x1, y: y2 };
            }
            // æ–œã‚ï¼ˆãã®ã¾ã¾ï¼‰
            return { x: x2, y: y2 };
        }
        
        // ç·šãŒæ–œã‚ã‹ã©ã†ã‹åˆ¤å®š
        function isLineDiagonal(line) {
            const dx = Math.abs(line.x2 - line.x1);
            const dy = Math.abs(line.y2 - line.y1);
            const threshold = 5;
            
            // æ°´å¹³ã§ã‚‚å‚ç›´ã§ã‚‚ãªã„å ´åˆã¯æ–œã‚
            return dx > threshold && dy > threshold;
        }
        
        // ç·šã®è§’åº¦ã‚’è¨ˆç®—ï¼ˆåº¦ï¼‰
        function getLineAngle(line) {
            const dx = line.x2 - line.x1;
            const dy = line.y2 - line.y1;
            const radians = Math.atan2(dy, dx);
            return radians * (180 / Math.PI);
        }
        
        // ã‚¿ãƒƒãƒæç”»å‡¦ç†
        function handleTouchDrawing(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let x = (touch.clientX - rect.left) * scaleX;
            let y = (touch.clientY - rect.top) * scaleY;
            
            // ã‚¹ãƒŠãƒƒãƒ—å‡¦ç†ï¼ˆ2ç‚¹ç›®ä»¥é™ï¼‰
            if (drawingPoints.length > 0) {
                const lastPoint = drawingPoints[drawingPoints.length - 1];
                const snapped = snapToAxis(lastPoint.x, lastPoint.y, x, y);
                x = snapped.x;
                y = snapped.y;
            }
            
            // å§‹ç‚¹ã¸ã®å¸ç€ã¨é–‰ã˜ã‚‹ç¢ºèªï¼ˆ3ç‚¹ä»¥ä¸Šã‚ã‚‹å ´åˆï¼‰
            if (drawingPoints.length >= 3) {
                const startPoint = drawingPoints[0];
                const distToStart = Math.sqrt(Math.pow(x - startPoint.x, 2) + Math.pow(y - startPoint.y, 2));
                
                // å§‹ç‚¹ã‹ã‚‰40pxä»¥å†…ï¼ˆã‚¿ãƒƒãƒæ“ä½œã¯åºƒã‚ã«ï¼‰
                if (distToStart < 40) {
                    if (confirm('å›³å½¢ã‚’é–‰ã˜ã¾ã™ã‹ï¼Ÿ\nï¼ˆå§‹ç‚¹ã¨çµ‚ç‚¹ã‚’çµåˆã—ã¾ã™ï¼‰')) {
                        // å§‹ç‚¹ã«å¸ç€
                        x = startPoint.x;
                        y = startPoint.y;
                        
                        // ç‚¹ã‚’è¿½åŠ 
                        drawingPoints.push({ x, y });
                        
                        // æœ€å¾Œã®ç·šã‚’ä½œæˆ
                        const prevPoint = drawingPoints[drawingPoints.length - 2];
                        const currPoint = drawingPoints[drawingPoints.length - 1];
                        
                        const id = String.fromCharCode(65 + lines.length);
                        lines.push({
                            id: id,
                            x1: prevPoint.x,
                            y1: prevPoint.y,
                            x2: currPoint.x,
                            y2: currPoint.y,
                            name: `è¾º${id}`,
                            start: 'wall',
                            end: 'wall'
                        });
                        
                        // ã‚³ãƒ¼ãƒŠãƒ¼ã®è‡ªå‹•è¨­å®š
                        autoSetCorners();
                        
                        // ä½œå›³çµ‚äº†
                        finishDrawing();
                        return;
                    } else {
                        // ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ãŸå ´åˆã¯ä½•ã‚‚ã—ãªã„
                        return;
                    }
                }
            }
            
            // æ—¢å­˜ã®ç‚¹ã‚’ã‚¿ãƒƒãƒ—ã—ãŸã‹åˆ¤å®šï¼ˆãŸã ã—å§‹ç‚¹ã¯é™¤ãï¼‰
            const clickRadius = 25;
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                // å§‹ç‚¹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆ3ç‚¹ä»¥ä¸Šã‚ã‚‹å ´åˆï¼‰
                let isStartPoint = false;
                if (drawingPoints.length >= 3 && i === 0) {
                    const startPoint = drawingPoints[0];
                    const distToStart = Math.sqrt(Math.pow(line.x1 - startPoint.x, 2) + Math.pow(line.y1 - startPoint.y, 2));
                    isStartPoint = distToStart < 5; // å§‹ç‚¹ã¨åŒã˜ä½ç½®ãªã‚‰
                }
                
                const distStart = Math.sqrt(Math.pow(x - line.x1, 2) + Math.pow(y - line.y1, 2));
                const distEnd = Math.sqrt(Math.pow(x - line.x2, 2) + Math.pow(y - line.y2, 2));
                
                // å§‹ç‚¹ä»¥å¤–ã®æ—¢å­˜ã®ç‚¹ã‚’ã‚¿ãƒƒãƒ—ã—ãŸå ´åˆã¯ç„¡è¦–
                if (!isStartPoint && distStart < clickRadius) {
                    return;
                }
                if (distEnd < clickRadius) {
                    return;
                }
            }
            
            // ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—åˆ¤å®š
            const currentTime = new Date().getTime();
            const timeDiff = currentTime - lastTapTime;
            lastTapTime = currentTime;
            
            if (timeDiff < 500 && drawingPoints.length > 0) {
                finishDrawing();
                return;
            }
            
            // ç‚¹ã‚’è¿½åŠ 
            drawingPoints.push({ x, y });
            
            // 2ç‚¹ä»¥ä¸Šã‚ã‚Œã°ç·šã‚’ä½œæˆ
            if (drawingPoints.length >= 2) {
                const prevPoint = drawingPoints[drawingPoints.length - 2];
                const currPoint = drawingPoints[drawingPoints.length - 1];
                
                const id = String.fromCharCode(65 + lines.length);
                lines.push({
                    id: id,
                    x1: prevPoint.x,
                    y1: prevPoint.y,
                    x2: currPoint.x,
                    y2: currPoint.y,
                    name: `è¾º${id}`,
                    start: 'wall',
                    end: 'wall'
                });
                
                // ã‚³ãƒ¼ãƒŠãƒ¼ã®è‡ªå‹•è¨­å®š
                autoSetCorners();
            }
            
            drawLines();
            updateDrawingControls();
        }
        
        // ã‚¿ãƒƒãƒç§»å‹•æ™‚ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
        function handleTouchDrawingMove(e) {
            if (drawingPoints.length === 0) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let x = (touch.clientX - rect.left) * scaleX;
            let y = (touch.clientY - rect.top) * scaleY;
            
            // ã‚¹ãƒŠãƒƒãƒ—å‡¦ç†
            const lastPoint = drawingPoints[drawingPoints.length - 1];
            const snapped = snapToAxis(lastPoint.x, lastPoint.y, x, y);
            x = snapped.x;
            y = snapped.y;
            
            drawLines();
            
            // å§‹ç‚¹ã¸ã®ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã¨å¸ç€ï¼ˆ3ç‚¹ä»¥ä¸Šã‚ã‚‹å ´åˆï¼‰
            let snapToStart = false;
            if (drawingPoints.length >= 3) {
                const startPoint = drawingPoints[0];
                const threshold = 15; // ã‚¿ãƒƒãƒæ“ä½œã¯å°‘ã—åºƒã‚ã«
                
                // æ°´å¹³ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ï¼ˆYåº§æ¨™ãŒå§‹ç‚¹ã¨è¿‘ã„å ´åˆï¼‰
                if (Math.abs(y - startPoint.y) < threshold) {
                    // å§‹ç‚¹ã«å‘ã‹ã£ã¦æ°´å¹³ç·šã‚’å¼•ã
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(x, startPoint.y);
                    ctx.lineTo(startPoint.x, startPoint.y);
                    ctx.stroke();
                    
                    // Yåº§æ¨™ã‚’å§‹ç‚¹ã«åˆã‚ã›ã‚‹
                    y = startPoint.y;
                    
                    // Xåº§æ¨™ã‚‚å§‹ç‚¹ã¨è¿‘ã„å ´åˆã¯å¸ç€
                    if (Math.abs(x - startPoint.x) < threshold) {
                        x = startPoint.x;
                        snapToStart = true;
                    }
                }
                
                // å‚ç›´ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ï¼ˆXåº§æ¨™ãŒå§‹ç‚¹ã¨è¿‘ã„å ´åˆï¼‰
                if (Math.abs(x - startPoint.x) < threshold) {
                    // å§‹ç‚¹ã«å‘ã‹ã£ã¦å‚ç›´ç·šã‚’å¼•ã
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(startPoint.x, y);
                    ctx.lineTo(startPoint.x, startPoint.y);
                    ctx.stroke();
                    
                    // Xåº§æ¨™ã‚’å§‹ç‚¹ã«åˆã‚ã›ã‚‹
                    x = startPoint.x;
                    
                    // Yåº§æ¨™ã‚‚å§‹ç‚¹ã¨è¿‘ã„å ´åˆã¯å¸ç€
                    if (Math.abs(y - startPoint.y) < threshold) {
                        y = startPoint.y;
                        snapToStart = true;
                    }
                }
                
                // å§‹ç‚¹ã¨åˆè‡´ã—ãŸå ´åˆã€å§‹ç‚¹ã‚’å¤§ããè¡¨ç¤º
                if (snapToStart) {
                    ctx.fillStyle = '#f59e0b';
                    ctx.beginPath();
                    ctx.arc(startPoint.x, startPoint.y, 10, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ç™½ã„ç¸å–ã‚Š
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
            
            // é€šå¸¸ã®ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ï¼ˆ90åº¦ï¼‰
            if (!snapToStart) {
                // æ°´å¹³ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³
                if (Math.abs(y - lastPoint.y) < 30) {
                    ctx.strokeStyle = '#10b981';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.moveTo(0, lastPoint.y);
                    ctx.lineTo(canvas.width, lastPoint.y);
                    ctx.stroke();
                }
                
                // å‚ç›´ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³
                if (Math.abs(x - lastPoint.x) < 30) {
                    ctx.strokeStyle = '#10b981';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.moveTo(lastPoint.x, 0);
                    ctx.lineTo(lastPoint.x, canvas.height);
                    ctx.stroke();
                }
            }
            
            // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç·š
            ctx.strokeStyle = snapToStart ? '#f59e0b' : '#667eea';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(lastPoint.x, lastPoint.y);
            ctx.lineTo(x, y);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        // ä½œå›³çµ‚äº†
        function finishDrawing() {
            drawingPoints = [];
            drawLines();
            
            // ä½œå›³ç”¨ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤
            canvas.removeEventListener('click', handleCanvasClick);
            canvas.removeEventListener('mousemove', handleCanvasMouseMove);
            canvas.removeEventListener('touchstart', handleTouchDrawing);
            canvas.removeEventListener('touchmove', handleTouchDrawingMove);
            
            // ç‚¹ã‚¯ãƒªãƒƒã‚¯ç”¨ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¨­å®š
            canvas.addEventListener('click', handlePointClick);
            canvas.addEventListener('touchend', handlePointClickTouch);
            
            if (lines.length > 0) {
                createInputs();
            }
            
            updateDrawingControls();
        }
        
        // ç‚¹ã®ã‚¯ãƒªãƒƒã‚¯å‡¦ç†
        function handlePointClick(e) {
            if (isDrawing || isDragging) return;
            if (drawingPoints.length > 0) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.offsetX || e.clientX - rect.left) * scaleX;
            const y = (e.offsetY || e.clientY - rect.top) * scaleY;
            
            const clickRadius = 20;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                const distStart = Math.sqrt(Math.pow(x - line.x1, 2) + Math.pow(y - line.y1, 2));
                if (distStart < clickRadius) {
                    // å…¥åŠ›æ¬„ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«&ãƒã‚¤ãƒ©ã‚¤ãƒˆã®ã¿ï¼ˆçŠ¶æ…‹å¤‰æ›´ã—ãªã„ï¼‰
                    scrollToInput(line.id);
                    return;
                }
                
                const distEnd = Math.sqrt(Math.pow(x - line.x2, 2) + Math.pow(y - line.y2, 2));
                if (distEnd < clickRadius) {
                    // å…¥åŠ›æ¬„ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«&ãƒã‚¤ãƒ©ã‚¤ãƒˆã®ã¿ï¼ˆçŠ¶æ…‹å¤‰æ›´ã—ãªã„ï¼‰
                    scrollToInput(line.id);
                    return;
                }
                
                // ç·šã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‹ãƒã‚§ãƒƒã‚¯
                const distToLine = distanceToLineSegment(x, y, line.x1, line.y1, line.x2, line.y2);
                if (distToLine < 10) {
                    // å…¥åŠ›æ¬„ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«&ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                    scrollToInput(line.id);
                    return;
                }
            }
        }
        
        // ç‚¹ã‹ã‚‰ç·šåˆ†ã¸ã®æœ€çŸ­è·é›¢ã‚’è¨ˆç®—
        function distanceToLineSegment(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const lengthSquared = dx * dx + dy * dy;
            
            if (lengthSquared === 0) {
                return Math.sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1));
            }
            
            let t = ((px - x1) * dx + (py - y1) * dy) / lengthSquared;
            t = Math.max(0, Math.min(1, t));
            
            const nearestX = x1 + t * dx;
            const nearestY = y1 + t * dy;
            
            return Math.sqrt((px - nearestX) * (px - nearestX) + (py - nearestY) * (py - nearestY));
        }
        
        // å…¥åŠ›æ¬„ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«&ãƒã‚¤ãƒ©ã‚¤ãƒˆ
        function scrollToInput(lineId) {
            // DOMã®æ›´æ–°ã‚’å¾…ã¤
            setTimeout(() => {
                const inputGroup = document.querySelector(`[data-line-id="${lineId}"]`);
                if (inputGroup) {
                    // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
                    inputGroup.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    
                    // ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼ˆ2ç§’é–“ï¼‰
                    inputGroup.style.transition = 'background-color 0.3s';
                    inputGroup.style.backgroundColor = '#fef3c7';
                    
                    setTimeout(() => {
                        inputGroup.style.backgroundColor = '';
                    }, 2000);
                }
            }, 100);
        }
        
        // ã‚³ãƒ¼ãƒŠãƒ¼ã‚’è‡ªå‹•è¨­å®š
        function autoSetCorners() {
            const tolerance = 5; // åŒã˜ä½ç½®ã¨åˆ¤å®šã™ã‚‹è·é›¢
            
            // å›³å½¢ãŒé–‰ã˜ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆæœ€åˆã®ç·šã®å§‹ç‚¹ã¨æœ€å¾Œã®ç·šã®çµ‚ç‚¹ãŒåŒã˜ä½ç½®ï¼‰
            const isClosed = lines.length > 0 && 
                Math.abs(lines[0].x1 - lines[lines.length - 1].x2) < tolerance && 
                Math.abs(lines[0].y1 - lines[lines.length - 1].y2) < tolerance;
            
            // å…¨ã¦ã®ç‚¹ã‚’ãƒã‚§ãƒƒã‚¯
            for (let i = 0; i < lines.length; i++) {
                for (let j = i + 1; j < lines.length; j++) {
                    const line1 = lines[i];
                    const line2 = lines[j];
                    
                    // line1ã®å§‹ç‚¹ã¨line2ã®å§‹ç‚¹ãŒåŒã˜ä½ç½®
                    if (Math.abs(line1.x1 - line2.x1) < tolerance && Math.abs(line1.y1 - line2.y1) < tolerance) {
                        // 90åº¦ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯
                        if (is90Degrees(line1, line2, 'start', 'start')) {
                            // æœ€åˆã®ç·šã®å§‹ç‚¹ã¯ã‚³ãƒ¼ãƒŠãƒ¼ã«ã—ãªã„ï¼ˆé–‰ã˜ã¦ã„ã‚‹å ´åˆã¯é™¤ãï¼‰
                            if (i !== 0 || isClosed) line1.start = 'corner';
                            if (j !== 0 || isClosed) line2.start = 'corner';
                        } else {
                            // 90åº¦ã§ãªã„å ´åˆã¯é€šå¸¸ã®é€£å‹•
                            if ((i !== 0 || isClosed) && line1.start === 'corner') line2.start = 'corner';
                            if ((j !== 0 || isClosed) && line2.start === 'corner') line1.start = 'corner';
                        }
                    }
                    
                    // line1ã®å§‹ç‚¹ã¨line2ã®çµ‚ç‚¹ãŒåŒã˜ä½ç½®
                    if (Math.abs(line1.x1 - line2.x2) < tolerance && Math.abs(line1.y1 - line2.y2) < tolerance) {
                        // 90åº¦ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯
                        if (is90Degrees(line1, line2, 'start', 'end')) {
                            if (i !== 0 || isClosed) line1.start = 'corner';
                            // æœ€å¾Œã®ç·šã®çµ‚ç‚¹ã¯ã‚³ãƒ¼ãƒŠãƒ¼ã«ã—ãªã„ï¼ˆé–‰ã˜ã¦ã„ã‚‹å ´åˆã¯é™¤ãï¼‰
                            if (j !== lines.length - 1 || isClosed) line2.end = 'corner';
                        } else {
                            if ((i !== 0 || isClosed) && line1.start === 'corner') line2.end = 'corner';
                            if ((j !== lines.length - 1 || isClosed) && line2.end === 'corner') line1.start = 'corner';
                        }
                    }
                    
                    // line1ã®çµ‚ç‚¹ã¨line2ã®å§‹ç‚¹ãŒåŒã˜ä½ç½®
                    if (Math.abs(line1.x2 - line2.x1) < tolerance && Math.abs(line1.y2 - line2.y1) < tolerance) {
                        // 90åº¦ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯
                        if (is90Degrees(line1, line2, 'end', 'start')) {
                            // æœ€å¾Œã®ç·šã®çµ‚ç‚¹ã¯ã‚³ãƒ¼ãƒŠãƒ¼ã«ã—ãªã„ï¼ˆé–‰ã˜ã¦ã„ã‚‹å ´åˆã¯é™¤ãï¼‰
                            if (i !== lines.length - 1 || isClosed) line1.end = 'corner';
                            if (j !== 0 || isClosed) line2.start = 'corner';
                        } else {
                            if ((i !== lines.length - 1 || isClosed) && line1.end === 'corner') line2.start = 'corner';
                            if ((j !== 0 || isClosed) && line2.start === 'corner') line1.end = 'corner';
                        }
                    }
                    
                    // line1ã®çµ‚ç‚¹ã¨line2ã®çµ‚ç‚¹ãŒåŒã˜ä½ç½®
                    if (Math.abs(line1.x2 - line2.x2) < tolerance && Math.abs(line1.y2 - line2.y2) < tolerance) {
                        // 90åº¦ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯
                        if (is90Degrees(line1, line2, 'end', 'end')) {
                            // æœ€å¾Œã®ç·šã®çµ‚ç‚¹ã¯ã‚³ãƒ¼ãƒŠãƒ¼ã«ã—ãªã„ï¼ˆé–‰ã˜ã¦ã„ã‚‹å ´åˆã¯é™¤ãï¼‰
                            if (i !== lines.length - 1 || isClosed) line1.end = 'corner';
                            if (j !== lines.length - 1 || isClosed) line2.end = 'corner';
                        } else {
                            if ((i !== lines.length - 1 || isClosed) && line1.end === 'corner') line2.end = 'corner';
                            if ((j !== lines.length - 1 || isClosed) && line2.end === 'corner') line1.end = 'corner';
                        }
                    }
                }
            }
        }
        
        // 2ã¤ã®ç·šãŒ90åº¦ã‹ã©ã†ã‹åˆ¤å®š
        function is90Degrees(line1, line2, point1, point2) {
            // ç·š1ã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«
            const dx1 = line1.x2 - line1.x1;
            const dy1 = line1.y2 - line1.y1;
            
            // ç·š2ã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«
            const dx2 = line2.x2 - line2.x1;
            const dy2 = line2.y2 - line2.y1;
            
            // å†…ç©ã‚’è¨ˆç®—ï¼ˆ90åº¦ãªã‚‰0ã«è¿‘ã„ï¼‰
            const dotProduct = dx1 * dx2 + dy1 * dy2;
            const magnitude1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
            const magnitude2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
            
            if (magnitude1 === 0 || magnitude2 === 0) return false;
            
            const cosAngle = dotProduct / (magnitude1 * magnitude2);
            
            // 90åº¦ã®å ´åˆã€cosã¯0ã«è¿‘ã„ï¼ˆè¨±å®¹èª¤å·®0.1ï¼‰
            return Math.abs(cosAngle) < 0.1;
        }
        
        // ç‚¹ã®çŠ¶æ…‹ã‚’åˆ‡ã‚Šæ›¿ãˆ
        function togglePointState(lineIndex, point) {
            const line = lines[lineIndex];
            
            // ã“ã®ç‚¹ã®ã‚³ãƒ¼ãƒŠãƒ¼ã‚­ãƒ¼ã‚’å–å¾—
            const x = point === 'start' ? line.x1 : line.x2;
            const y = point === 'start' ? line.y1 : line.y2;
            const cornerKey = findCornerKey(x, y, 5);
            const corner = corners[cornerKey];
            
            // å›³å½¢ãŒé–‰ã˜ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆæœ€åˆã®ç·šã®å§‹ç‚¹ã¨æœ€å¾Œã®ç·šã®çµ‚ç‚¹ãŒåŒã˜ä½ç½®ï¼‰
            const isClosed = lines.length > 0 && 
                Math.abs(lines[0].x1 - lines[lines.length - 1].x2) < 5 && 
                Math.abs(lines[0].y1 - lines[lines.length - 1].y2) < 5;
            
            // æœ€åˆã®ç·šã®å§‹ç‚¹ã¯ã‚³ãƒ¼ãƒŠãƒ¼ã«ãªã‚Œãªã„ï¼ˆé–‰ã˜ã¦ã„ã‚‹å ´åˆã¯é™¤ãï¼‰
            const isFirstLineStart = (lineIndex === 0 && point === 'start' && !isClosed);
            
            // æœ€å¾Œã®ç·šã®çµ‚ç‚¹ã¯ã‚³ãƒ¼ãƒŠãƒ¼ã«ãªã‚Œãªã„ï¼ˆé–‰ã˜ã¦ã„ã‚‹å ´åˆã¯é™¤ãï¼‰
            const isLastLineEnd = (lineIndex === lines.length - 1 && point === 'end' && !isClosed);
            
            // æ®µå·®ãŒã‚ã‚‹ã‚³ãƒ¼ãƒŠãƒ¼ã®å ´åˆã¯ã€ã‚³ãƒ¼ãƒŠãƒ¼é¸æŠã‚’é™¤å¤–
            const hasStepAtCorner = corner && corner.hasStep;
            
            // é¸æŠå¯èƒ½ãªçŠ¶æ…‹ã‚’æ±ºå®š
            let states;
            if (isFirstLineStart || isLastLineEnd || hasStepAtCorner) {
                states = ['end', 'wall'];
            } else {
                states = ['corner', 'end', 'wall'];
            }
            
            const currentState = lines[lineIndex][point] || 'wall';
            const currentIndex = states.indexOf(currentState);
            const nextIndex = (currentIndex + 1) % states.length;
            lines[lineIndex][point] = states[nextIndex];
            
            // ã‚³ãƒ¼ãƒŠãƒ¼ã«å¤‰æ›´ã—ãŸå ´åˆã€åŒã˜ä½ç½®ã®ç‚¹ã‚‚é€£å‹•
            if (lines[lineIndex][point] === 'corner') {
                autoSetCorners();
            }
            
            // æ®µå·®ãŒã‚ã‚‹ã‚³ãƒ¼ãƒŠãƒ¼ã§çŠ¶æ…‹ã‚’å¤‰æ›´ã—ãŸå ´åˆã€æ¥ç¶šã—ã¦ã„ã‚‹è¾ºã®çŠ¶æ…‹ã‚’è‡ªå‹•èª¿æ•´
            if (corner && corner.hasStep && corner.lines.length >= 2) {
                syncCornerStatesWithStep(cornerKey, line.id, point, lines[lineIndex][point]);
            }
        }
        
        
        function handleTouch(e) {
            e.preventDefault();
            const touch = e.touches[0] || e.changedTouches[0];
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (touch.clientX - rect.left) * scaleX;
            const y = (touch.clientY - rect.top) * scaleY;
            
            if (e.type === 'touchstart') {
                startDrawing({ offsetX: x, offsetY: y });
            } else if (e.type === 'touchmove') {
                drawing({ offsetX: x, offsetY: y });
            } else if (e.type === 'touchend') {
                endDrawing({ offsetX: x, offsetY: y });
            }
        }
        
        function startDrawing(e) {
            isDrawing = true;
            isDragging = false; // ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹æ™‚ã¯false
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            startPoint = { 
                x: (e.offsetX || e.clientX - rect.left) * scaleX, 
                y: (e.offsetY || e.clientY - rect.top) * scaleY 
            };
        }
        
        function drawing(e) {
            if (!isDrawing) return;
            
            isDragging = true; // ãƒã‚¦ã‚¹ç§»å‹•ã—ãŸã‚‰ãƒ‰ãƒ©ãƒƒã‚°ä¸­
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.offsetX || e.clientX - rect.left) * scaleX;
            const y = (e.offsetY || e.clientY - rect.top) * scaleY;
            
            // æ—¢å­˜ã®ç·šã‚’æç”»
            drawLines();
            
            // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç·šã‚’æç”»
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(startPoint.x, startPoint.y);
            ctx.lineTo(x, y);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        function endDrawing(e) {
            if (!isDrawing) return;
            
            // ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ã„ãŸå ´åˆã®ã¿ç·šã‚’å¼•ã
            if (isDragging) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.offsetX || e.clientX - rect.left) * scaleX;
                const y = (e.offsetY || e.clientY - rect.top) * scaleY;
                
                const id = String.fromCharCode(65 + lines.length);
                lines.push({
                    id: id,
                    x1: startPoint.x,
                    y1: startPoint.y,
                    x2: x,
                    y2: y,
                    name: `è¾º${id}`,
                    start: 'wall', // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯å£
                    end: 'wall'    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯å£
                });
                
                drawLines();
                createInputs(); // ç·šã‚’å¼•ã„ãŸå¾Œã«å…¥åŠ›ãƒ•ã‚©ãƒ¼ãƒ ã‚’ä½œæˆ
            }
            
            isDrawing = false;
            isDragging = false;
        }
        
        // ãƒ‘ã‚¿ãƒ¼ãƒ³ä¿å­˜
        function savePattern() {
            const name = prompt('ãƒ‘ã‚¿ãƒ¼ãƒ³åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:');
            if (!name) return;
            
            const savedPatterns = JSON.parse(localStorage.getItem('savedPatterns') || '{}');
            savedPatterns[name] = {
                lines: lines,
                dimensions: dimensions
            };
            localStorage.setItem('savedPatterns', JSON.stringify(savedPatterns));
            
            alert('ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä¿å­˜ã—ã¾ã—ãŸ');
        }
        
        // ä¿å­˜æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³èª­ã¿è¾¼ã¿
        function loadSavedPatterns() {
            const savedPatterns = JSON.parse(localStorage.getItem('savedPatterns') || '{}');
            const keys = Object.keys(savedPatterns);
            
            if (keys.length === 0) return;
            
            document.getElementById('saved-patterns-section').style.display = 'block';
            const grid = document.getElementById('saved-patterns-grid');
            grid.innerHTML = '';
            
            keys.forEach(name => {
                const btn = document.createElement('button');
                btn.className = 'pattern-btn';
                btn.innerHTML = `
                    ${name}
                    <span class="delete-btn" onclick="event.stopPropagation(); deletePattern('${name}')">Ã—</span>
                `;
                btn.onclick = () => selectPattern(name);
                grid.appendChild(btn);
            });
        }
        
        // ã‚«ã‚¹ã‚¿ãƒ ãƒ‘ã‚¿ãƒ¼ãƒ³èª­ã¿è¾¼ã¿
        function loadCustomPattern(name) {
            const savedPatterns = JSON.parse(localStorage.getItem('savedPatterns') || '{}');
            const pattern = savedPatterns[name];
            
            if (!pattern) return;
            
            document.getElementById('pattern-title').textContent = name;
            lines = pattern.lines;
            dimensions = pattern.dimensions || {};
            
            drawLines();
            createInputs();
        }
        
        // ãƒ‘ã‚¿ãƒ¼ãƒ³å‰Šé™¤
        function deletePattern(name) {
            if (!confirm(`ã€Œ${name}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`)) return;
            
            const savedPatterns = JSON.parse(localStorage.getItem('savedPatterns') || '{}');
            delete savedPatterns[name];
            localStorage.setItem('savedPatterns', JSON.stringify(savedPatterns));
            
            loadSavedPatterns();
        }
        
        // ã‚¯ãƒªã‚¢ï¼ˆå…¨å‰Šé™¤ï¼‰
        // ã‚¯ãƒªã‚¢ï¼ˆå…¨å‰Šé™¤ï¼‰
        
        // æœ€å¾Œã®ç·šã‚’å‰Šé™¤
        function undoLastLine() {
            if (lines.length === 0) return;
            
            // ä½œå›³çµ‚äº†å¾Œï¼ˆdrawingPointsãŒç©ºï¼‰ã®å ´åˆã¯ã€drawingPointsã‚’å¾©å…ƒã—ã¦ã‹ã‚‰å‰Šé™¤
            if (drawingPoints.length === 0 && lines.length > 0) {
                // å…¨ã¦ã®ç‚¹ã‚’drawingPointsã«å¾©å…ƒ
                drawingPoints = [];
                
                // æœ€åˆã®ç·šã®å§‹ç‚¹ã‚’è¿½åŠ 
                drawingPoints.push({ x: lines[0].x1, y: lines[0].y1 });
                
                // å…¨ã¦ã®ç·šã®çµ‚ç‚¹ã‚’è¿½åŠ 
                for (let i = 0; i < lines.length; i++) {
                    drawingPoints.push({ x: lines[i].x2, y: lines[i].y2 });
                }
                
                // ç‚¹ã‚¯ãƒªãƒƒã‚¯ç”¨ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤
                canvas.removeEventListener('click', handlePointClick);
                canvas.removeEventListener('touchend', handlePointClickTouch);
                
                // ä½œå›³ç”¨ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å†è¨­å®š
                canvas.addEventListener('click', handleCanvasClick);
                canvas.addEventListener('mousemove', handleCanvasMouseMove);
                canvas.addEventListener('touchstart', handleTouchDrawing);
                canvas.addEventListener('touchmove', handleTouchDrawingMove);
            }
            
            // æœ€å¾Œã®ç·šã‚’å‰Šé™¤
            const lastLineId = lines[lines.length - 1].id;
            lines.pop();
            delete dimensions[lastLineId];
            
            // drawingPointsã‹ã‚‰æœ€å¾Œã®ç‚¹ã‚’å‰Šé™¤ï¼ˆ1ã¤å‰ã®ç‚¹ã‹ã‚‰å†é–‹ã§ãã‚‹ã‚ˆã†ã«ï¼‰
            if (drawingPoints.length > 1) {
                drawingPoints.pop();
            }
            
            drawLines();
            createInputs();
            calculate();
            updateDrawingControls();
        }
        
        // ã‚¯ãƒªã‚¢ï¼ˆã™ã¹ã¦ãƒªã‚»ãƒƒãƒˆï¼‰
        function clearDrawing() {
            // ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’è¡¨ç¤º
            if (lines.length > 0 && !confirm('ã™ã¹ã¦ã®ä½œå›³ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã‹ï¼Ÿ')) {
                return;
            }
            
            // ã™ã¹ã¦ã‚’ãƒªã‚»ãƒƒãƒˆ
            lines = [];
            dimensions = {};
            drawingPoints = [];
            corners = {};
            commonWidth = null;
            
            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚¯ãƒªã‚¢
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // å…¥åŠ›ãƒ•ã‚©ãƒ¼ãƒ ã‚’ã‚¯ãƒªã‚¢
            document.getElementById('dimension-inputs').innerHTML = '';
            
            // è¨ˆç®—çµæœã‚’ã‚¯ãƒªã‚¢
            document.getElementById('results-content').innerHTML = '<p style="color: #999; text-align: center;">å¯¸æ³•ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„</p>';
            
            // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚’éè¡¨ç¤º
            updateDrawingControls();
            
            // è‡ªç”±ä½œå›³ã®å ´åˆã¯ã€ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å†è¨­å®š
            if (currentPattern === 'custom') {
                // æ—¢å­˜ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’ã™ã¹ã¦å‰Šé™¤
                canvas.removeEventListener('click', handlePointClick);
                canvas.removeEventListener('touchend', handlePointClickTouch);
                
                // ä½œå›³ç”¨ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å†è¨­å®š
                canvas.addEventListener('click', handleCanvasClick);
                canvas.addEventListener('mousemove', handleCanvasMouseMove);
                canvas.addEventListener('touchstart', handleTouchDrawing);
                canvas.addEventListener('touchmove', handleTouchDrawingMove);
            } else {
                // åŸºæœ¬ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å ´åˆã¯ã€ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å†ä½œæˆ
                selectPattern(currentPattern);
            }
        }
        
        // æç”»ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã®è¡¨ç¤ºãƒ»éè¡¨ç¤º
        function updateDrawingControls() {
            const controls = document.getElementById('drawing-controls');
            if (controls) {
                controls.style.display = (drawingPoints.length > 0 || currentPattern === 'custom') ? 'flex' : 'none';
            }
        }
        
        // æˆ»ã‚‹
        function backToSelect() {
            document.getElementById('pattern-select-screen').style.display = 'block';
            document.getElementById('measurement-screen').style.display = 'none';
            loadSavedPatterns();
        }
        
        // ã‚¯ãƒªã‚¢æ©Ÿèƒ½
        function clearAll() {
            // ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°
            if (!confirm('ã™ã¹ã¦ã®ä½œå›³ã¨å…¥åŠ›å†…å®¹ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã‹ï¼Ÿ')) {
                return;
            }
            
            // ç·šã‚’ã‚¯ãƒªã‚¢
            lines = [];
            
            // å¯¸æ³•å…¥åŠ›ã‚’ã‚¯ãƒªã‚¢
            dimensions = {};
            
            // ä½œå›³ç‚¹ã‚’ã‚¯ãƒªã‚¢
            drawingPoints = [];
            
            // ã‚³ãƒ¼ãƒŠãƒ¼ã‚’ã‚¯ãƒªã‚¢
            corners = {};
            
            // å…±é€šå¹…ã‚’ã‚¯ãƒªã‚¢
            commonWidth = null;
            
            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚¯ãƒªã‚¢
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // å…¥åŠ›ãƒ•ã‚©ãƒ¼ãƒ ã‚’ã‚¯ãƒªã‚¢
            document.getElementById('dimension-inputs').innerHTML = '';
            
            // è¨ˆç®—çµæœã‚’ã‚¯ãƒªã‚¢
            document.getElementById('results-content').innerHTML = '<p style="color: #999; text-align: center;">å¯¸æ³•ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„</p>';
            
            // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒœã‚¿ãƒ³ã‚’éè¡¨ç¤º
            updateDrawingControls();
            
            // ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å†ä½œæˆ
            if (currentPattern === 'Iå­—') {
                createIPattern();
            } else if (currentPattern === 'å·¦Lå­—') {
                createLPatternLeft();
            } else if (currentPattern === 'å³Lå­—') {
                createLPatternRight();
            } else if (currentPattern === 'ã‚³ã®å­—') {
                createUPattern();
            } else if (currentPattern === 'custom') {
                setupCustomDrawing();
            }
        }
        
        // ==============================================
        // ä¿å­˜ãƒ»å…±æœ‰æ©Ÿèƒ½
        // ==============================================
        
        // ä¿å­˜ãƒ¢ãƒ¼ãƒ‰ã®åˆ‡ã‚Šæ›¿ãˆ
        // ãƒ•ã‚¡ã‚¤ãƒ«åã‚’å–å¾—ï¼ˆæ—¥ä»˜ã®ã¿ï¼‰
        function getFilename() {
            const date = new Date().toISOString().slice(0, 10);
            return `kutai-keisoku_${date}`;
        }
        
        // PDFã¨ã—ã¦ä¿å­˜
        async function downloadAsPDF() {
            const measurementScreen = document.getElementById('measurement-screen');
            if (!measurementScreen || measurementScreen.style.display === 'none') {
                alert('è¨ˆç®—çµæœãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }
            
            try {
                let canvas, titleText;
                
                // ãƒšãƒ¼ã‚¸å…¨ä½“ï¼šcontainerã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£
                const container = measurementScreen.querySelector('.container');
                if (!container) {
                    canvas = await html2canvas(measurementScreen, {
                        scale: 2,
                        backgroundColor: '#ffffff',
                        logging: false
                    });
                } else {
                    canvas = await html2canvas(container, {
                        scale: 2,
                        backgroundColor: '#ffffff',
                        logging: false
                    });
                }
                titleText = 'èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ ';
                
                // jsPDFã‚’ä½¿ç”¨ã—ã¦PDFã‚’ä½œæˆ
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF({
                    orientation: 'portrait',
                    unit: 'mm',
                    format: 'a4'
                });
                
                // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ç”»åƒã¨ã—ã¦å–å¾—
                const imgData = canvas.toDataURL('image/png');
                
                // A4ã‚µã‚¤ã‚ºã«åˆã‚ã›ã¦ç”»åƒã‚’é…ç½®
                const pageWidth = 210; // A4å¹…
                const pageHeight = 297; // A4é«˜ã•
                const margin = 10;
                const imgWidth = pageWidth - margin * 2; // ä¸¡å´ãƒãƒ¼ã‚¸ãƒ³
                const imgHeight = (canvas.height * imgWidth) / canvas.width;
                const maxHeight = pageHeight - margin * 2 - 25; // ãƒãƒ¼ã‚¸ãƒ³ + ãƒ˜ãƒƒãƒ€ãƒ¼åˆ†
                
                // ã‚¿ã‚¤ãƒˆãƒ«ã‚’è¿½åŠ 
                pdf.setFontSize(16);
                pdf.text(titleText, pageWidth / 2, 15, { align: 'center' });
                
                // æ—¥ä»˜ã‚’è¿½åŠ 
                const date = new Date().toLocaleDateString('ja-JP');
                pdf.setFontSize(10);
                pdf.text(date, pageWidth / 2, 22, { align: 'center' });
                
                // PDFã‚’1ãƒšãƒ¼ã‚¸ã«åã‚ã‚‹ã‚ˆã†ã«ç¸®å°
                let finalImgWidth, finalImgHeight;
                
                if (imgHeight <= maxHeight) {
                    // ãã®ã¾ã¾ã®ã‚µã‚¤ã‚ºã§åã¾ã‚‹
                    finalImgWidth = imgWidth;
                    finalImgHeight = imgHeight;
                } else {
                    // ç¸®å°ã—ã¦1ãƒšãƒ¼ã‚¸ã«åã‚ã‚‹
                    finalImgHeight = maxHeight;
                    finalImgWidth = (canvas.width * finalImgHeight) / canvas.height;
                    
                    // å¹…ãŒã¯ã¿å‡ºã‚‹å ´åˆã¯ã€å¹…åŸºæº–ã§ç¸®å°
                    if (finalImgWidth > imgWidth) {
                        finalImgWidth = imgWidth;
                        finalImgHeight = (canvas.height * finalImgWidth) / canvas.width;
                    }
                }
                
                // ä¸­å¤®é…ç½®
                const xOffset = margin + (imgWidth - finalImgWidth) / 2;
                pdf.addImage(imgData, 'PNG', xOffset, 30, finalImgWidth, finalImgHeight);
                
                // ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç”Ÿæˆ
                const filename = getFilename() + '.pdf';
                
                // PDFã‚’ä¿å­˜
                pdf.save(filename);
                
            } catch (error) {
                console.error('PDFä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
                alert('PDFã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ');
            }
        }
        
        // PNGã¨ã—ã¦ä¿å­˜
        async function downloadAsPNG() {
            const measurementScreen = document.getElementById('measurement-screen');
            if (!measurementScreen || measurementScreen.style.display === 'none') {
                alert('è¨ˆç®—çµæœãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }
            
            try {
                let canvas;
                
                // ãƒšãƒ¼ã‚¸å…¨ä½“ï¼šcontainerã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£
                const container = measurementScreen.querySelector('.container');
                if (!container) {
                    canvas = await html2canvas(measurementScreen, {
                        scale: 2,
                        backgroundColor: '#ffffff',
                        logging: false
                    });
                } else {
                    canvas = await html2canvas(container, {
                        scale: 2,
                        backgroundColor: '#ffffff',
                        logging: false
                    });
                }
                
                // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ç”»åƒã¨ã—ã¦å–å¾—
                const imgData = canvas.toDataURL('image/png');
                
                // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒªãƒ³ã‚¯ã‚’ä½œæˆ
                const link = document.createElement('a');
                link.download = getFilename() + '.png';
                link.href = imgData;
                link.click();
                
            } catch (error) {
                console.error('PNGä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
                alert('ç”»åƒã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ');
            }
        }
        
        // å…±æœ‰æ©Ÿèƒ½ï¼ˆWeb Share APIä½¿ç”¨ï¼‰
        async function shareResult() {
            const measurementScreen = document.getElementById('measurement-screen');
            if (!measurementScreen || measurementScreen.style.display === 'none') {
                alert('è¨ˆç®—çµæœãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }
            
            try {
                // Web Share APIãŒåˆ©ç”¨å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
                if (!navigator.share && !navigator.canShare) {
                    // Web Share APIãŒä½¿ãˆãªã„å ´åˆã€PNGãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œ
                    alert('ã“ã®ç«¯æœ«ã§ã¯å…±æœ‰æ©Ÿèƒ½ãŒä½¿ãˆã¾ã›ã‚“ã€‚ç”»åƒã¨ã—ã¦ä¿å­˜ã—ã¾ã™ã€‚');
                    downloadAsPNG();
                    return;
                }
                
                let canvas;
                
                // ãƒšãƒ¼ã‚¸å…¨ä½“ï¼šcontainerã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£
                const container = measurementScreen.querySelector('.container');
                if (!container) {
                    canvas = await html2canvas(measurementScreen, {
                        scale: 2,
                        backgroundColor: '#ffffff',
                        logging: false
                    });
                } else {
                    canvas = await html2canvas(container, {
                        scale: 2,
                        backgroundColor: '#ffffff',
                        logging: false
                    });
                }
                
                // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’Blobã«å¤‰æ›
                canvas.toBlob(async (blob) => {
                    try {
                        const file = new File([blob], getFilename() + '.png', { type: 'image/png' });
                        
                        const shareData = {
                            title: 'èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ ',
                            text: 'èº¯ä½“æ¡å¯¸ã®ä½œå›³ã¨è¨ˆç®—çµæœã§ã™',
                            files: [file]
                        };
                        
                        // å…±æœ‰å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
                        if (navigator.canShare && !navigator.canShare(shareData)) {
                            // ãƒ•ã‚¡ã‚¤ãƒ«å…±æœ‰ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„å ´åˆã€ãƒ†ã‚­ã‚¹ãƒˆã®ã¿å…±æœ‰
                            await navigator.share({
                                title: shareData.title,
                                text: shareData.text,
                                url: window.location.href
                            });
                        } else {
                            // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å«ã‚ã¦å…±æœ‰
                            await navigator.share(shareData);
                        }
                        
                    } catch (shareError) {
                        if (shareError.name !== 'AbortError') {
                            console.error('å…±æœ‰ã‚¨ãƒ©ãƒ¼:', shareError);
                            alert('å…±æœ‰ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ç”»åƒã¨ã—ã¦ä¿å­˜ã—ã¾ã™ã€‚');
                            downloadAsPNG();
                        }
                    }
                }, 'image/png');
                
            } catch (error) {
                console.error('å…±æœ‰ã‚¨ãƒ©ãƒ¼:', error);
                alert('å…±æœ‰ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ç”»åƒã¨ã—ã¦ä¿å­˜ã—ã¾ã™ã€‚');
                downloadAsPNG();
            }
        }
        
        // ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
        function openManual() {
            document.getElementById('manual-modal').style.display = 'block';
            document.body.style.overflow = 'hidden'; // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ç„¡åŠ¹åŒ–
        }
        
        // ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
        function closeManual() {
            document.getElementById('manual-modal').style.display = 'none';
            document.body.style.overflow = 'auto'; // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æœ‰åŠ¹åŒ–
        }
        
        // ãƒ¢ãƒ¼ãƒ€ãƒ«å¤–ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‚‰é–‰ã˜ã‚‹
        window.onclick = function(event) {
            const modal = document.getElementById('manual-modal');
            if (event.target === modal) {
                closeManual();
            }
        }
    </script>
    
    <!-- ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="manual-modal" class="manual-modal">
        <div class="manual-content">
            <button class="manual-close" onclick="closeManual()">Ã—</button>
            
            <h1>ğŸ“± èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ  ä½¿ã„æ–¹ãƒãƒ‹ãƒ¥ã‚¢ãƒ«</h1>
            
            <h2>ğŸ¯ ã“ã®ã‚·ã‚¹ãƒ†ãƒ ã«ã¤ã„ã¦</h2>
            <p><strong>å¤–æ³•å¯¸æ³•ã‹ã‚‰èº¯ä½“èŠ¯å¯¸æ³•ã‚’è‡ªå‹•è¨ˆç®—ã—ã¾ã™ã€‚</strong></p>
            <p>ç¾å ´ã§æ¸¬ã£ãŸå¯¸æ³•ã‚’å…¥åŠ›ã™ã‚‹ã¨ã€æ–½å·¥ã«å¿…è¦ãªèŠ¯å¯¸æ³•ãŒè‡ªå‹•ã§è¨ˆç®—ã•ã‚Œã¾ã™ã€‚</p>
            
            <h2>ğŸ“ åŸºæœ¬çš„ãªæµã‚Œ</h2>
            <ol>
                <li><strong>ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’é¸ã¶</strong> - Iå­—ã€Lå­—ã€ã‚³ã®å­—ã€ã¾ãŸã¯è‡ªç”±ä½œå›³</li>
                <li><strong>å¯¸æ³•ã‚’å…¥åŠ›ã™ã‚‹</strong> - å¤–æ³•å¯¸æ³•ã€èº¯ä½“å¹…ã€èº¯ä½“é«˜ã•</li>
                <li><strong>è¨ˆç®—çµæœã‚’ç¢ºèªã™ã‚‹</strong> - èº¯ä½“èŠ¯å¯¸æ³•ãŒè‡ªå‹•è¨ˆç®—ã•ã‚Œã‚‹</li>
                <li><strong>ä¿å­˜ãƒ»å…±æœ‰ã™ã‚‹</strong> - PDFã€ç”»åƒã€ã¾ãŸã¯LINEãªã©ã§å…±æœ‰</li>
            </ol>
            
            <h2>âœï¸ å¯¸æ³•ã®å…¥åŠ›æ–¹æ³•</h2>
            
            <h3>å¤–æ³•å¯¸æ³•</h3>
            <ul>
                <li>å„è¾ºã®é•·ã•ã‚’å…¥åŠ›ï¼ˆmmå˜ä½ï¼‰</li>
                <li>å®Ÿéš›ã«æ¸¬ã£ãŸå¯¸æ³•ã‚’ãã®ã¾ã¾å…¥åŠ›</li>
            </ul>
            
            <h3>èº¯ä½“å¹…</h3>
            <ul>
                <li>å…¨ã¦ã®è¾ºã«å…±é€šã®å¹…ã‚’è¨­å®š</li>
                <li>ã¾ãŸã¯ã€Œè¾ºã”ã¨ã«èº¯ä½“å¹…ã‚’è¨­å®šã€ã«ãƒã‚§ãƒƒã‚¯ã—ã¦å€‹åˆ¥è¨­å®š</li>
            </ul>
            
            <h3>èº¯ä½“é«˜ã•</h3>
            <ul>
                <li>å…¨ä½“ã®é«˜ã•ã‚’å…¥åŠ›ï¼ˆmmå˜ä½ï¼‰</li>
            </ul>
            
            <h2>âœï¸ è‡ªç”±ä½œå›³ã®ä½¿ã„æ–¹</h2>
            
            <h3>ç·šã®å¼•ãæ–¹</h3>
            <ol>
                <li><strong>æœ€åˆã®ç‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯</strong> - ç·šã®å§‹ç‚¹ãŒé…ç½®ã•ã‚Œã‚‹ï¼ˆç·‘ã®ç‚¹ï¼‰</li>
                <li><strong>æ¬¡ã®ç‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯</strong> - å‰ã®ç‚¹ã‹ã‚‰ç·šãŒå¼•ã‹ã‚Œã‚‹ï¼ˆç·‘ã®ç‚¹ï¼‰</li>
                <li><strong>ã•ã‚‰ã«ç‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯</strong> - ç¶šã‘ã¦ç·šã‚’å¼•ã‘ã‚‹</li>
                <li><strong>ã€Œâœ“ ä½œå›³çµ‚äº†ã€ã‚’ã‚¯ãƒªãƒƒã‚¯</strong> - ä½œå›³ã‚’å®Œäº†</li>
            </ol>
            
            <h3>ãƒœã‚¿ãƒ³ã®èª¬æ˜</h3>
            <ul>
                <li><strong>â†¶ æˆ»ã‚‹</strong> - æœ€å¾Œã«å¼•ã„ãŸç·šã‚’å‰Šé™¤ï¼ˆä½•åº¦ã§ã‚‚æˆ»ã‚Œã‚‹ï¼‰</li>
                <li><strong>ğŸ—‘ï¸ ã‚¯ãƒªã‚¢</strong> - å…¨ã¦ã®ç·šã‚’å‰Šé™¤ã—ã¦ã‚„ã‚Šç›´ã™</li>
                <li><strong>âœ“ ä½œå›³çµ‚äº†</strong> - ç·šã‚’å¼•ãçµ‚ã‚ã£ãŸã‚‰å¿…ãšã‚¯ãƒªãƒƒã‚¯</li>
            </ul>
            
            <h3>ã‚³ãƒ„</h3>
            <ul>
                <li>é–“é•ãˆãŸã‚‰ã€Œâ†¶ æˆ»ã‚‹ã€ã§1ã¤ãšã¤æ¶ˆã›ã‚‹</li>
                <li>å…¨éƒ¨ã‚„ã‚Šç›´ã—ãŸã„ã¨ãã¯ã€ŒğŸ—‘ï¸ ã‚¯ãƒªã‚¢ã€</li>
                <li>ä½œå›³ãŒçµ‚ã‚ã£ãŸã‚‰å¿…ãšã€Œâœ“ ä½œå›³çµ‚äº†ã€ã‚’ã‚¯ãƒªãƒƒã‚¯</li>
                <li>ä½œå›³çµ‚äº†å¾Œã€å¯¸æ³•å…¥åŠ›ç”»é¢ã«åˆ‡ã‚Šæ›¿ã‚ã‚‹</li>
            </ul>
            
            <h2>ğŸ”´ ç‚¹ã®ç¨®é¡ã«ã¤ã„ã¦ï¼ˆé‡è¦ï¼‰</h2>
            <p>è¨ˆç®—çµæœã¯ç‚¹ã®ç¨®é¡ã«ã‚ˆã£ã¦å¤‰ã‚ã‚Šã¾ã™ï¼š</p>
            
            <h3>ğŸ”´ èµ¤ï¼ˆã‚³ãƒ¼ãƒŠãƒ¼ï¼‰</h3>
            <ul>
                <li>2ã¤ã®è¾ºãŒæ¥ç¶šã™ã‚‹è§’</li>
                <li><strong>ä¸¡å´ã®è¾ºã®å¹…ã®åŠåˆ†ãšã¤ã‚’å¼•ã</strong></li>
                <li>ä¾‹ï¼šLå­—ã®è§’ã€ã‚³ã®å­—ã®è§’</li>
            </ul>
            
            <h3>ğŸ”µ é’ï¼ˆã‚¨ãƒ³ãƒ‰ï¼‰</h3>
            <ul>
                <li>è¾ºã®ç«¯ç‚¹ï¼ˆå£ãªã—ï¼‰</li>
                <li><strong>éš£æ¥ã™ã‚‹è¾ºã®å¹…ã‚’å¼•ã‹ãªã„</strong></li>
                <li>æ®µå·®ãŒã‚ã‚‹å ´åˆã«ä½¿ç”¨</li>
            </ul>
            
            <h3>ğŸŸ¢ ç·‘ï¼ˆå£ï¼‰</h3>
            <ul>
                <li>å£ã‚„æ®µå·®ã«æ¥ã™ã‚‹ç‚¹</li>
                <li><strong>éš£æ¥ã™ã‚‹è¾ºã®å¹…ã‚’å¼•ã‹ãªã„</strong></li>
            </ul>
            
            <h3>ç‚¹ã®å¤‰æ›´æ–¹æ³•</h3>
            <p>ä½œå›³ç”»é¢ã®ç‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨ã€èµ¤ â†’ é’ â†’ ç·‘ â†’ èµ¤...ã¨å¾ªç’°ã—ã¦å¤‰æ›´ã§ãã¾ã™ã€‚</p>
            
            <h2>ğŸ“ æ®µå·®ã®è¨­å®šæ–¹æ³•</h2>
            
            <h3>æ®µå·®ãŒã‚ã‚‹å ´åˆ</h3>
            <ol>
                <li><strong>ã€Œæ®µå·®ã‚ã‚Šã€ã«ãƒã‚§ãƒƒã‚¯</strong></li>
                <li>ç‚¹ã®ç¨®é¡ãŒè‡ªå‹•çš„ã«å¤‰ã‚ã‚‹ï¼ˆ1ã¤ç›®ï¼šé’ã€2ã¤ç›®ï¼šç·‘ï¼‰</li>
                <li><strong>æ·±ã•ã‚’å…¥åŠ›</strong>ï¼ˆmmå˜ä½ï¼‰</li>
                <li>ãƒã‚§ãƒƒã‚¯ã‚’å¤–ã™ã¨èµ¤ï¼ˆã‚³ãƒ¼ãƒŠãƒ¼ï¼‰ã«æˆ»ã‚‹</li>
            </ol>
            
            <h2>ğŸ“Š è¨ˆç®—çµæœã®è¦‹æ–¹</h2>
            
            <h3>èŠ¯å¯¸æ³•ï¼ˆè¨ˆç®—çµæœï¼‰</h3>
            <ul>
                <li>å¤–æ³•å¯¸æ³•ã‹ã‚‰èº¯ä½“å¹…ã‚’å¼•ã„ãŸå€¤</li>
                <li>ç‚¹ã®ç¨®é¡ã«ã‚ˆã£ã¦è¨ˆç®—æ–¹æ³•ãŒç•°ãªã‚‹</li>
                <li>å®Ÿéš›ã®æ–½å·¥ã§ä½¿ã†å¯¸æ³•</li>
            </ul>
            
            <h3>è¡¨ç¤ºå†…å®¹</h3>
            <pre>è¾ºA ç·‘â”èµ¤    4710 mm
è¾ºB èµ¤â”ç·‘    3429 mm</pre>
            <ul>
                <li><strong>ç·‘â”èµ¤</strong>ï¼šå§‹ç‚¹ãŒç·‘ï¼ˆå£ï¼‰ã€çµ‚ç‚¹ãŒèµ¤ï¼ˆã‚³ãƒ¼ãƒŠãƒ¼ï¼‰</li>
                <li><strong>4710 mm</strong>ï¼šè¨ˆç®—ã•ã‚ŒãŸèŠ¯å¯¸æ³•</li>
            </ul>
            
            <h3>è¨ˆç®—çµæœã®å›³</h3>
            <ul>
                <li>å®Ÿå¯¸æ³•ã®æ¯”ç‡ã§å›³å½¢ã‚’è¡¨ç¤º</li>
                <li>ç‚¹ã®è‰²ã§ç¨®é¡ã‚’ç¢ºèª</li>
                <li>å¯¸æ³•ãŒé»„è‰²ã„æ ã§è¡¨ç¤º</li>
            </ul>
            
            <h2>ğŸ’¾ ä¿å­˜ãƒ»å…±æœ‰æ–¹æ³•</h2>
            
            <h3>ğŸ“„ PDFã§ä¿å­˜</h3>
            <ul>
                <li>ä½œå›³ + å…¥åŠ› + è¨ˆç®—çµæœã‚’PDFã§ä¿å­˜</li>
                <li>å°åˆ·ã‚„è¨˜éŒ²ã«ä¾¿åˆ©</li>
            </ul>
            
            <h3>ğŸ–¼ï¸ ç”»åƒã§ä¿å­˜</h3>
            <ul>
                <li>PNGå½¢å¼ã§ç”»åƒã¨ã—ã¦ä¿å­˜</li>
                <li>ã‚¹ãƒãƒ›ã®ã‚«ãƒ¡ãƒ©ãƒ­ãƒ¼ãƒ«ã«ä¿å­˜ã•ã‚Œã‚‹</li>
            </ul>
            
            <h3>ğŸ“¤ å…±æœ‰</h3>
            <ul>
                <li>LINEã‚„ãƒ¡ãƒ¼ãƒ«ã§ç›´æ¥å…±æœ‰</li>
                <li>ç¾å ´ã®åŒåƒšã‚„ä¸Šå¸ã«é€ã‚Œã‚‹</li>
            </ul>
            
            <h2>ğŸ”„ ã‚„ã‚Šç›´ã—ãƒ»ã‚¯ãƒªã‚¢</h2>
            
            <h3>â†¶ æˆ»ã‚‹</h3>
            <ul>
                <li>æœ€å¾Œã«å¼•ã„ãŸç·šã‚’å‰Šé™¤</li>
                <li>ä½•åº¦ã§ã‚‚æˆ»ã‚Œã‚‹</li>
            </ul>
            
            <h3>ğŸ—‘ï¸ ã‚¯ãƒªã‚¢</h3>
            <ul>
                <li>å…¨ã¦ã®ä½œå›³ã‚’ã‚¯ãƒªã‚¢</li>
                <li>ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ãŒè¡¨ç¤ºã•ã‚Œã‚‹</li>
            </ul>
            
            <h3>âœ“ ä½œå›³çµ‚äº†</h3>
            <ul>
                <li>è‡ªç”±ä½œå›³ã®å ´åˆã®ã¿è¡¨ç¤º</li>
                <li>ä½œå›³ã‚’å®Œäº†ã—ã¦å¯¸æ³•å…¥åŠ›ã¸é€²ã‚€</li>
            </ul>
            
            <h2>âš ï¸ ã‚ˆãã‚ã‚‹è³ªå•</h2>
            
            <h3>Q1: ç‚¹ã®è‰²ãŒå¤‰ã‚ã‚‰ãªã„</h3>
            <p><strong>A:</strong> ä½œå›³ç”»é¢ã®ç‚¹ã‚’ç›´æ¥ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚æ®µå·®ã‚ã‚Šã®ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã¨ã¯åˆ¥ã§ã™ã€‚</p>
            
            <h3>Q2: è¨ˆç®—çµæœãŒè¡¨ç¤ºã•ã‚Œãªã„</h3>
            <p><strong>A:</strong> ä»¥ä¸‹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ï¼š</p>
            <ul>
                <li>å¤–æ³•å¯¸æ³•ãŒå…¥åŠ›ã•ã‚Œã¦ã„ã‚‹ã‹</li>
                <li>èº¯ä½“å¹…ãŒå…¥åŠ›ã•ã‚Œã¦ã„ã‚‹ã‹</li>
                <li>èº¯ä½“é«˜ã•ãŒå…¥åŠ›ã•ã‚Œã¦ã„ã‚‹ã‹</li>
                <li>æ®µå·®ã‚ã‚Šã«ãƒã‚§ãƒƒã‚¯ã—ãŸå ´åˆã€æ·±ã•ãŒå…¥åŠ›ã•ã‚Œã¦ã„ã‚‹ã‹</li>
            </ul>
            
            <h3>Q3: å…±æœ‰ãŒã§ããªã„</h3>
            <p><strong>A:</strong> ãƒ–ãƒ©ã‚¦ã‚¶ã«ã‚ˆã£ã¦å‹•ä½œãŒç•°ãªã‚Šã¾ã™ã€‚PCãƒ–ãƒ©ã‚¦ã‚¶ã®å ´åˆã¯ã€Œç”»åƒã§ä¿å­˜ã€ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚</p>
            
            <h3>Q4: ä½œå›³ã—ãŸç·šã‚’å‰Šé™¤ã—ãŸã„</h3>
            <p><strong>A:</strong> ã€Œâ†¶ æˆ»ã‚‹ã€ãƒœã‚¿ãƒ³ã§æœ€å¾Œã®ç·šã‹ã‚‰é †ç•ªã«å‰Šé™¤ã§ãã¾ã™ã€‚å…¨éƒ¨æ¶ˆã—ãŸã„å ´åˆã¯ã€ŒğŸ—‘ï¸ ã‚¯ãƒªã‚¢ã€ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚</p>
            
            <h3>Q5: è‡ªç”±ä½œå›³ã§ç·šã‚’å¼•ãæ–¹æ³•ã¯ï¼Ÿ</h3>
            <p><strong>A:</strong> ä¸Šè¨˜ã®ã€Œâœï¸ è‡ªç”±ä½œå›³ã®ä½¿ã„æ–¹ã€ã‚’ã”è¦§ãã ã•ã„ã€‚</p>
            
            <h3>Q6: è¨ˆç®—çµæœã®å€¤ãŒåˆã‚ãªã„</h3>
            <p><strong>A:</strong> ç‚¹ã®ç¨®é¡ã‚’ç¢ºèªã—ã¦ãã ã•ã„ï¼š</p>
            <ul>
                <li><strong>èµ¤ï¼ˆã‚³ãƒ¼ãƒŠãƒ¼ï¼‰</strong>ï¼šéš£æ¥ã™ã‚‹è¾ºã®å¹…ã®åŠåˆ†ã‚’å¼•ã</li>
                <li><strong>é’ï¼ˆã‚¨ãƒ³ãƒ‰ï¼‰</strong>ï¼šä½•ã‚‚å¼•ã‹ãªã„</li>
                <li><strong>ç·‘ï¼ˆå£ï¼‰</strong>ï¼šä½•ã‚‚å¼•ã‹ãªã„</li>
            </ul>
            <p>ã‚³ãƒ¼ãƒŠãƒ¼ã®å ´åˆã€ä¸¡å´ã®è¾ºã®å¹…ã®åŠåˆ†ãšã¤å¼•ã‹ã‚Œã‚‹ãŸã‚ã€äºˆæƒ³ã‚ˆã‚Šå°ã•ããªã‚Šã¾ã™ã€‚</p>
            
            <hr style="margin: 30px 0; border: none; border-top: 2px solid #e5e7eb;">
            
            <p style="text-align: center; color: #6b7280; margin-top: 30px;">ä½¿ã„æ–¹ã§å›°ã£ãŸã“ã¨ãŒã‚ã‚Œã°ã€ã“ã®ç”»é¢ã‚’è¦‹è¿”ã—ã¦ãã ã•ã„ã€‚</p>
        </div>
    </div>
</body>
</html>
