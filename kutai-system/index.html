<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- ã‚­ãƒ£ãƒƒã‚·ãƒ¥å¯¾ç­– -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
    <title>èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ </title>
    <!--
    ========================================
    èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ 
    ========================================
    ãƒãƒ¼ã‚¸ãƒ§ãƒ³: 1.17.5
    æœ€çµ‚æ›´æ–°: 2025-02-09
    
    [æ›´æ–°å±¥æ­´]
    v1.17.5 (2025-02-09)
    - è¨ˆç®—çµæœå›³(drawResultDiagram)ã‚’æ ¹æœ¬ä¿®æ­£
    - å…ƒã®ä½œå›³åº§æ¨™ã‚’ãã®ã¾ã¾ä½¿ç”¨ã™ã‚‹æ–¹å¼ã«å¤‰æ›´
    - ç¸åˆ‡ã‚Šå¾Œã®åˆ†é›¢ã—ãŸç·šã‚°ãƒ«ãƒ¼ãƒ—ãŒæ­£ã—ãè¡¨ç¤ºã•ã‚Œã‚‹ã‚ˆã†ã«
    - æ—§æ–¹å¼(å¯¸æ³•å€¤ã‹ã‚‰åº§æ¨™å†æ§‹ç¯‰)ã‚’å»ƒæ­¢
    
    v1.17.4 (2024-12-28)
    - æ®µå·®æ™‚ã®ç‚¹ã®é–“éš”ã‚’æ‹¡å¤§ï¼ˆé‡ãªã‚Šé˜²æ­¢ï¼‰
    - ä½œå›³ç”»é¢: 20px â†’ 32px
    - è¨ˆç®—çµæœ: 20px â†’ 30px
    
    v1.17.3 (2024-12-28)
    - ç‚¹ã®å½¢çŠ¶ï¼ˆâ–¼â– â˜…ï¼‰ã‚’ç´„1.4å€ã«æ‹¡å¤§
    - ä½œå›³ç”»é¢ã€è¨ˆç®—çµæœã®ä¸¡æ–¹ã§æ‹¡å¤§
    - ã‚ˆã‚Šè¦–èªæ€§ãŒå‘ä¸Š
    
    v1.17.2 (2024-12-28)
    - ç‚¹ã®å½¢çŠ¶ã‚’æœ€çµ‚èª¿æ•´
      ã‚³ãƒ¼ãƒŠãƒ¼: èµ¤â–¼ï¼ˆä¸‹å‘ãä¸‰è§’ï¼‰ãã®ã¾ã¾
      å£: ç·‘â– ï¼ˆæ­£æ–¹å½¢ï¼‰ã«å¤‰æ›´
      ã‚¨ãƒ³ãƒ‰: é’â˜…ï¼ˆæ˜Ÿï¼‰ã«å¤‰æ›´
    - ã‚ˆã‚Šè¦–è¦šçš„ã«è­˜åˆ¥ã—ã‚„ã™ãæ”¹å–„
    
    v1.17.1 (2024-12-28)
    - ç‚¹ã®å½¢çŠ¶ã‚’å¤‰æ›´ã—ã¦è­˜åˆ¥ã—ã‚„ã™ãæ”¹å–„
      ã‚³ãƒ¼ãƒŠãƒ¼: èµ¤â–¼ï¼ˆä¸‹å‘ãä¸‰è§’ï¼‰
      å£: ç·‘â—†ï¼ˆã²ã—å½¢ï¼‰
      ã‚¨ãƒ³ãƒ‰: é’â—ï¼ˆä¸¸ï¼‰
    
    v1.17.0 (2024-12-28)
    - è‡ªç”±ä½œå›³ã«ã€Œâœ‚ï¸ ç¸åˆ‡ã‚Šã€æ©Ÿèƒ½ã‚’è¿½åŠ 
    - ç‹¬ç«‹ã—ãŸè¤‡æ•°ã®ç·šã‚’å¼•ã‘ã‚‹ã‚ˆã†ã«ãªã£ãŸ
    - ç·šã¨ç·šã‚’ã‚³ãƒ¼ãƒŠãƒ¼ã§æ¥ç¶šã™ã‚‹ã‹ã€ç‹¬ç«‹ã•ã›ã‚‹ã‹ã‚’é¸æŠå¯èƒ½
    - ã‚¢ãƒ©ãƒ¼ãƒˆè¡¨ç¤ºæ©Ÿèƒ½ã‚’è¿½åŠ ï¼ˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€šçŸ¥ï¼‰
    ========================================
    -->
    <!-- jsPDF ãƒ©ã‚¤ãƒ–ãƒ©ãƒªï¼ˆPDFä¿å­˜ç”¨ï¼‰ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- html2canvas ãƒ©ã‚¤ãƒ–ãƒ©ãƒªï¼ˆãƒšãƒ¼ã‚¸å…¨ä½“ã‚­ãƒ£ãƒ—ãƒãƒ£ç”¨ï¼‰ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, 'Hiragino Kaku Gothic ProN', sans-serif;
            background: #f5f7fa;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 700px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            padding: 40px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }
        
        h1 {
            text-align: center;
            color: #1a1a1a;
            margin-bottom: 40px;
            font-size: 28px;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        
        h2 {
            color: #1a1a1a;
            margin: 30px 0 20px;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            opacity: 0.6;
        }
        
        .pattern-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }
        
        .pattern-btn {
            background: white;
            color: #1a1a1a;
            border: 2px solid #e5e7eb;
            padding: 24px 16px;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            min-height: 110px;
        }
        
        .pattern-btn svg {
            width: 50px;
            height: 50px;
        }
        
        .pattern-btn:hover {
            border-color: #3b82f6;
            background: #f0f9ff;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.15);
        }
        
        .pattern-btn:active {
            transform: translateY(0);
        }
        
        .pattern-btn.custom {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
            grid-column: 1 / -1;
        }
        
        .pattern-btn.custom:hover {
            background: #2563eb;
            border-color: #2563eb;
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.25);
        }
        
        .pattern-btn .delete-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .pattern-btn .delete-btn:hover {
            background: #dc2626;
            transform: scale(1.1);
        }
        
        .measurement-screen {
            display: none;
        }
        
        .back-btn {
            background: #f3f4f6;
            color: #1a1a1a;
            border: 1px solid #e5e7eb;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 20px;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        
        .back-btn:hover {
            background: #e5e7eb;
            border-color: #d1d5db;
        }
        
        .drawing-area {
            position: relative;
            width: 100%;
            height: 400px;
            background: #f9fafb;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            margin: 20px 0;
            overflow: hidden;
            touch-action: none;
        }
        
        canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }
        
        .dimension-inputs {
            margin: 20px 0;
        }
        
        .dimension-item {
            background: #f9fafb;
            padding: 16px;
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            margin-bottom: 12px;
        }
        
        .dimension-item label {
            display: block;
            color: #1a1a1a;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .dimension-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .dimension-row input {
            padding: 10px 12px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            font-size: 15px;
            transition: all 0.2s ease;
        }
        
        .dimension-row input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        .results {
            background: #f9fafb;
            padding: 20px;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            margin-top: 20px;
        }
        
        .result-item {
            padding: 12px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .result-label {
            color: #555;
            font-weight: bold;
        }
        
        .result-value {
            color: #667eea;
            font-weight: bold;
            font-size: 18px;
        }
        
        .save-pattern-btn {
            width: 100%;
            background: #10b981;
            color: white;
            border: none;
            padding: 14px;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.2s ease;
        }
        
        .save-pattern-btn:hover {
            background: #059669;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.25);
        }
        
        .alert {
            background: #fff3cd;
            color: #856404;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #ffc107;
        }
        
        .success {
            background: #d4edda;
            color: #155724;
            border-left-color: #28a745;
        }
        
        .manual-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            overflow-y: auto;
        }
        
        .manual-content {
            background: white;
            max-width: 800px;
            margin: 20px auto;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        
        .manual-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #ef4444;
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .manual-close:hover {
            background: #dc2626;
            transform: scale(1.1);
        }
        
        .manual-content h1 {
            color: #1e40af;
            border-bottom: 3px solid #3b82f6;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        
        .manual-content h2 {
            color: #2563eb;
            margin-top: 30px;
            margin-bottom: 15px;
        }
        
        .manual-content h3 {
            color: #3b82f6;
            margin-top: 20px;
            margin-bottom: 10px;
        }
        
        .manual-content pre {
            background: #f3f4f6;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            border-left: 4px solid #3b82f6;
        }
        
        .manual-content ul, .manual-content ol {
            padding-left: 25px;
            line-height: 1.8;
        }
        
        .manual-content li {
            margin-bottom: 8px;
        }
        
        .manual-content strong {
            color: #1e40af;
        }
        
        .saved-data-item:hover {
            border-color: #3b82f6 !important;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
            transform: translateY(-2px);
        }
        
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠç”»é¢ -->
        <div id="pattern-select-screen">
            <h1>èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ </h1>
            
            <div style="margin-bottom: 20px; text-align: center; display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                <button onclick="window.location.href='https://as9source.github.io/'" 
                   style="display: inline-block; padding: 10px 20px; background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%); color: white; border: none; border-radius: 8px; font-weight: bold; font-size: 14px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); cursor: pointer;">
                    â† ç›®æ¬¡ã«æˆ»ã‚‹
                </button>
                <button onclick="showSavedDataList()" 
                   style="display: inline-block; padding: 10px 20px; background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; border: none; border-radius: 8px; font-weight: bold; font-size: 14px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); cursor: pointer;">
                    ğŸ“‚ ä¿å­˜ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰é–‹ã
                </button>
                <button onclick="openManual()" 
                   style="display: inline-block; padding: 10px 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; font-weight: bold; font-size: 14px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); cursor: pointer;">
                    â“ ä½¿ã„æ–¹
                </button>
            </div>
            
            <h2>åŸºæœ¬ãƒ‘ã‚¿ãƒ¼ãƒ³</h2>
            <div class="pattern-grid">
                <button class="pattern-btn" onclick="selectPattern('i')">
                    <svg viewBox="0 0 60 60">
                        <line x1="10" y1="30" x2="50" y2="30" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                    </svg>
                    Iå­—
                </button>
                <button class="pattern-btn" onclick="selectPattern('l-left')">
                    <svg viewBox="0 0 60 60">
                        <line x1="15" y1="10" x2="15" y2="50" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                        <line x1="15" y1="10" x2="45" y2="10" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                    </svg>
                    å·¦Lå­—
                </button>
                <button class="pattern-btn" onclick="selectPattern('l-right')">
                    <svg viewBox="0 0 60 60">
                        <line x1="45" y1="10" x2="45" y2="50" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                        <line x1="15" y1="10" x2="45" y2="10" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                    </svg>
                    å³Lå­—
                </button>
                <button class="pattern-btn" onclick="selectPattern('u')">
                    <svg viewBox="0 0 60 60">
                        <line x1="15" y1="50" x2="15" y2="10" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                        <line x1="15" y1="10" x2="45" y2="10" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                        <line x1="45" y1="10" x2="45" y2="50" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                    </svg>
                    ã‚³ã®å­—
                </button>
            </div>
            
            <div id="saved-patterns-section" style="display: none;">
                <h2>ä¿å­˜æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³</h2>
                <div class="pattern-grid" id="saved-patterns-grid"></div>
            </div>
            
            <h2>ã‚«ã‚¹ã‚¿ãƒ ä½œå›³</h2>
            <div class="pattern-grid">
                <button class="pattern-btn custom" onclick="selectPattern('custom')">è‡ªç”±ã«ç·šã‚’å¼•ã</button>
            </div>
            
            <div style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #e5e7eb; text-align: center; color: #6b7280; font-size: 13px;">
                <div style="margin-bottom: 5px;">èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ  v1.17.5</div>
                <div>æœ€çµ‚æ›´æ–°: 2025-02-09</div>
            </div>
        </div>
        
        <!-- ä¿å­˜ãƒ‡ãƒ¼ã‚¿ãƒªã‚¹ãƒˆç”»é¢ -->
        <div id="saved-data-screen" style="display: none;">
            <h1>ğŸ“‚ ä¿å­˜ãƒ‡ãƒ¼ã‚¿</h1>
            
            <button onclick="backToSelectFromSaved()" 
                style="margin-bottom: 20px; padding: 12px 24px; background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%); color: white; border: none; border-radius: 8px; font-weight: bold; font-size: 14px; cursor: pointer;">
                â† ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠã«æˆ»ã‚‹
            </button>
            
            <div style="margin-bottom: 20px; background: #f3f4f6; padding: 15px; border-radius: 8px;">
                <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 10px;">
                    <input type="text" id="search-site-name" placeholder="ğŸ” ç¾å ´åã§æ¤œç´¢" 
                           oninput="filterSavedData()"
                           style="padding: 10px; border: 2px solid #d1d5db; border-radius: 8px; font-size: 14px;">
                    <select id="search-color" onchange="filterSavedData()"
                            style="padding: 10px; border: 2px solid #d1d5db; border-radius: 8px; font-size: 14px; background: white;">
                        <option value="">ã™ã¹ã¦ã®è‰²</option>
                        <option value="B7">B7</option>
                        <option value="B1">B1</option>
                        <option value="YW">YW</option>
                        <option value="H2">H2</option>
                        <option value="S1">S1</option>
                        <option value="ãã®ä»–">ãã®ä»–</option>
                    </select>
                </div>
            </div>
            
            <div id="saved-data-list"></div>
            
            <div id="no-saved-data" style="display: none; text-align: center; padding: 40px; color: #9ca3af;">
                <div style="font-size: 48px; margin-bottom: 16px;">ğŸ“­</div>
                <div style="font-size: 18px; font-weight: bold; margin-bottom: 8px;">ä¿å­˜ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“</div>
                <div style="font-size: 14px;">æ¡å¯¸ç”»é¢ã§ã€Œä¿å­˜ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã¨ãƒ‡ãƒ¼ã‚¿ãŒä¿å­˜ã•ã‚Œã¾ã™</div>
            </div>
        </div>
        
        <!-- æ¡å¯¸ç”»é¢ -->
        <div id="measurement-screen" class="measurement-screen">
            <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                <button onclick="backToSelect()" 
                   style="flex: 1; display: flex; align-items: center; justify-content: center; padding: 12px; background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%); color: white; border: none; border-radius: 8px; font-weight: bold; font-size: 14px; cursor: pointer; white-space: nowrap;">
                    â† ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠã«æˆ»ã‚‹
                </button>
                <button onclick="savePattern()" 
                   style="flex: 1; display: flex; align-items: center; justify-content: center; padding: 12px; background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: white; border: none; border-radius: 8px; font-weight: bold; font-size: 14px; cursor: pointer; white-space: nowrap;">
                    ğŸ“‹ ãƒ‘ã‚¿ãƒ¼ãƒ³ä¿å­˜
                </button>
                <button onclick="openManual()" 
                   style="flex: 1; display: flex; align-items: center; justify-content: center; padding: 12px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; font-weight: bold; font-size: 14px; cursor: pointer; white-space: nowrap;">
                    â“ ä½¿ã„æ–¹
                </button>
            </div>
            
            <h1 id="pattern-title">æ¡å¯¸å…¥åŠ›</h1>
            
            <div style="background: #fff3cd; padding: 15px; border-radius: 8px; margin-bottom: 15px; border: 2px solid #ffc107;">
                <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 10px;">
                    <div>
                        <label style="display: block; color: #856404; font-weight: bold; margin-bottom: 8px; font-size: 14px;">
                            ğŸ“ ç¾å ´å <span style="color: #dc2626;">*å¿…é ˆ</span>
                        </label>
                        <input type="text" id="site-name" placeholder="ä¾‹: ã€‡ã€‡æ§˜é‚¸" 
                               oninput="checkRequiredFields()"
                               style="width: 100%; padding: 12px; border: 2px solid #ffc107; border-radius: 8px; font-size: 16px;">
                    </div>
                    <div>
                        <label style="display: block; color: #856404; font-weight: bold; margin-bottom: 8px; font-size: 14px;">
                            ğŸ¨ è‰² <span style="color: #dc2626;">*å¿…é ˆ</span>
                        </label>
                        <select id="sash-color" onchange="checkRequiredFields()"
                                style="width: 100%; padding: 12px; border: 2px solid #ffc107; border-radius: 8px; font-size: 16px; background: white; cursor: pointer;">
                            <option value="">é¸æŠã—ã¦ãã ã•ã„</option>
                            <option value="B7">B7</option>
                            <option value="B1">B1</option>
                            <option value="YW">YW</option>
                            <option value="H2">H2</option>
                            <option value="S1">S1</option>
                            <option value="ãã®ä»–">ãã®ä»–</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <div id="alert" class="alert" style="display: none;"></div>
            
            <div class="drawing-area">
                <canvas id="canvas"></canvas>
            </div>
            
            <div id="drawing-controls" style="display: none; margin-top: 10px; display: flex; gap: 10px; flex-wrap: wrap;">
                <button onclick="clearDrawing()" style="flex: 1; min-width: 110px; padding: 12px; background: #ef4444; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s ease;">ğŸ—‘ï¸ ã‚¯ãƒªã‚¢</button>
                <button onclick="undoLastLine()" style="flex: 1; min-width: 110px; padding: 12px; background: #f59e0b; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s ease;">â†¶ æˆ»ã‚‹</button>
                <button onclick="cutEdge()" style="flex: 1; min-width: 110px; padding: 12px; background: #8b5cf6; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s ease;">âœ‚ï¸ ç¸åˆ‡ã‚Š</button>
                <button onclick="finishDrawing()" style="flex: 1; min-width: 110px; padding: 12px; background: #10b981; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s ease;">âœ“ ä½œå›³çµ‚äº†</button>
            </div>
            
            <div class="dimension-inputs" id="dimension-inputs"></div>
            
            <div class="results">
                <h2>è¨ˆç®—çµæœ</h2>
                <div id="results-content">
                    <p style="color: #999; text-align: center;">å¯¸æ³•ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„</p>
                </div>
            </div>
            
            <div style="display: flex; gap: 10px; margin-top: 20px; padding-top: 20px; border-top: 2px solid #e5e7eb;">
                <button onclick="saveCurrentData()" 
                   style="flex: 1; display: flex; align-items: center; justify-content: center; padding: 14px; background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; border: none; border-radius: 8px; font-weight: bold; font-size: 15px; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    ğŸ’¾ ç¾å ´ã‚’ä¿å­˜
                </button>
                <button onclick="backToSelect()" 
                   style="flex: 1; display: flex; align-items: center; justify-content: center; padding: 14px; background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%); color: white; border: none; border-radius: 8px; font-weight: bold; font-size: 15px; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    â† ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠã«æˆ»ã‚‹
                </button>
            </div>
        </div>
    </div>
    
    <!-- ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="manual-modal" class="manual-modal">
        <div class="manual-content">
            <button class="manual-close" onclick="closeManual()">Ã—</button>
            
            <h1>ğŸ“± èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ  ä½¿ã„æ–¹ãƒãƒ‹ãƒ¥ã‚¢ãƒ«</h1>
            
            <h2>ğŸ¯ ã“ã®ã‚·ã‚¹ãƒ†ãƒ ã«ã¤ã„ã¦</h2>
            <p><strong>å¤–æ³•å¯¸æ³•ã‹ã‚‰èº¯ä½“èŠ¯å¯¸æ³•ã‚’è‡ªå‹•è¨ˆç®—ã—ã¾ã™ã€‚</strong></p>
            <p>ç¾å ´ã§æ¸¬ã£ãŸå¯¸æ³•ã‚’å…¥åŠ›ã™ã‚‹ã¨ã€æ–½å·¥ã«å¿…è¦ãªèŠ¯å¯¸æ³•ãŒè‡ªå‹•ã§è¨ˆç®—ã•ã‚Œã¾ã™ã€‚</p>
            
            <h2>ğŸ“ åŸºæœ¬çš„ãªæµã‚Œ</h2>
            <ol>
                <li><strong>ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’é¸ã¶</strong> - Iå­—ã€Lå­—ã€ã‚³ã®å­—ã€ã¾ãŸã¯è‡ªç”±ä½œå›³</li>
                <li><strong>å¯¸æ³•ã‚’å…¥åŠ›ã™ã‚‹</strong> - å¤–æ³•å¯¸æ³•ã€èº¯ä½“å¹…ã€èº¯ä½“é«˜ã•</li>
                <li><strong>è¨ˆç®—çµæœã‚’ç¢ºèªã™ã‚‹</strong> - èº¯ä½“èŠ¯å¯¸æ³•ãŒè‡ªå‹•è¨ˆç®—ã•ã‚Œã‚‹</li>
                <li><strong>ä¿å­˜ãƒ»å…±æœ‰ã™ã‚‹</strong> - PDFã€ç”»åƒã€ã¾ãŸã¯LINEãªã©ã§å…±æœ‰</li>
            </ol>
            
            <h2>ğŸ”´ ç‚¹ã®ç¨®é¡ã«ã¤ã„ã¦ï¼ˆé‡è¦ï¼‰</h2>
            <p>è¨ˆç®—çµæœã¯ç‚¹ã®ç¨®é¡ã«ã‚ˆã£ã¦å¤‰ã‚ã‚Šã¾ã™ï¼š</p>
            
            <h3>ğŸ”» èµ¤â–¼ï¼ˆã‚³ãƒ¼ãƒŠãƒ¼ï¼‰</h3>
            <ul>
                <li>2ã¤ã®è¾ºãŒæ¥ç¶šã™ã‚‹è§’</li>
                <li><strong>ä¸¡å´ã®è¾ºã®å¹…ã®åŠåˆ†ãšã¤ã‚’å¼•ã</strong></li>
            </ul>
            
            <h3>â­ é’â˜…ï¼ˆã‚¨ãƒ³ãƒ‰ï¼‰</h3>
            <ul>
                <li>è¾ºã®ç«¯ç‚¹ï¼ˆå£ãªã—ï¼‰</li>
                <li><strong>éš£æ¥ã™ã‚‹è¾ºã®å¹…ã‚’å¼•ã‹ãªã„</strong></li>
            </ul>
            
            <h3>ğŸŸ© ç·‘â– ï¼ˆå£ï¼‰</h3>
            <ul>
                <li>å£ã‚„æ®µå·®ã«æ¥ã™ã‚‹ç‚¹</li>
                <li><strong>éš£æ¥ã™ã‚‹è¾ºã®å¹…ã‚’å¼•ã‹ãªã„</strong></li>
            </ul>
            
            <h2>âš ï¸ ã‚ˆãã‚ã‚‹è³ªå•</h2>
            
            <h3>Q1: ç‚¹ã®è‰²ãŒå¤‰ã‚ã‚‰ãªã„</h3>
            <p><strong>A:</strong> ä½œå›³ç”»é¢ã®ç‚¹ã‚’ç›´æ¥ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚</p>
            
            <h3>Q2: è¨ˆç®—çµæœãŒè¡¨ç¤ºã•ã‚Œãªã„</h3>
            <p><strong>A:</strong> å¤–æ³•å¯¸æ³•ã€èº¯ä½“å¹…ã€èº¯ä½“é«˜ã•ãŒã™ã¹ã¦å…¥åŠ›ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚</p>
            
            <hr style="margin: 30px 0; border: none; border-top: 2px solid #e5e7eb;">
            
            <p style="text-align: center; color: #6b7280; margin-top: 30px;">ä½¿ã„æ–¹ã§å›°ã£ãŸã“ã¨ãŒã‚ã‚Œã°ã€ã“ã®ç”»é¢ã‚’è¦‹è¿”ã—ã¦ãã ã•ã„ã€‚</p>
        </div>
    </div>
    
    <script>
        let currentPattern = null;
        let lines = [];
        let dimensions = {};
        let isDrawing = false;
        let isDragging = false;
        let startPoint = null;
        let canvas, ctx;
        let drawingPoints = [];
        let lastClickTime = 0;
        let lastTapTime = 0;
        let commonWidth = null;
        let useIndividualWidth = false;
        let commonHeight = null;
        let corners = {};
        let isAfterCut = false;
        
        function detectCorners() {
            if (!corners) corners = {};
            if (!lines || lines.length === 0) { corners = {}; return; }
            
            const newCorners = {};
            const tolerance = 5;
            
            lines.forEach((line, idx) => {
                if (!line) return;
                
                const startKey = findCornerKeyForDetection(line.x1, line.y1, tolerance, newCorners);
                if (!newCorners[startKey]) {
                    const oldCorner = corners[startKey];
                    newCorners[startKey] = { 
                        x: line.x1, y: line.y1, 
                        hasStep: oldCorner ? oldCorner.hasStep : false, 
                        depth: oldCorner ? oldCorner.depth : null,
                        angle: oldCorner ? oldCorner.angle : null,
                        lines: [] 
                    };
                }
                newCorners[startKey].lines.push({ lineId: line.id, point: 'start' });
                
                const endKey = findCornerKeyForDetection(line.x2, line.y2, tolerance, newCorners);
                if (!newCorners[endKey]) {
                    const oldCorner = corners[endKey];
                    newCorners[endKey] = { 
                        x: line.x2, y: line.y2, 
                        hasStep: oldCorner ? oldCorner.hasStep : false, 
                        depth: oldCorner ? oldCorner.depth : null,
                        angle: oldCorner ? oldCorner.angle : null,
                        lines: [] 
                    };
                }
                newCorners[endKey].lines.push({ lineId: line.id, point: 'end' });
            });
            
            corners = newCorners;
        }
        
        function findCornerKeyForDetection(x, y, tolerance, cornersObj) {
            for (const key in cornersObj) {
                const corner = cornersObj[key];
                const dist = Math.sqrt(Math.pow(x - corner.x, 2) + Math.pow(y - corner.y, 2));
                if (dist < tolerance) return key;
            }
            return `${Math.round(x)},${Math.round(y)}`;
        }
        
        function findCornerKey(x, y, tolerance) {
            if (!corners) return `${Math.round(x)},${Math.round(y)}`;
            for (const key in corners) {
                const corner = corners[key];
                const dist = Math.sqrt(Math.pow(x - corner.x, 2) + Math.pow(y - corner.y, 2));
                if (dist < tolerance) return key;
            }
            return `${Math.round(x)},${Math.round(y)}`;
        }
        
        window.onload = function() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            resizeCanvas();
            loadSavedPatterns();
        };
        
        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            const width = rect.width || canvas.parentElement?.clientWidth || 800;
            const height = rect.height || canvas.parentElement?.clientHeight || 600;
            canvas.width = width;
            canvas.height = height;
            if (lines.length > 0) drawLines();
        }
        
        function selectPattern(type) {
            currentPattern = type;
            document.getElementById('pattern-select-screen').style.display = 'none';
            document.getElementById('measurement-screen').style.display = 'block';
            
            lines = [];
            dimensions = {};
            drawingPoints = [];
            commonWidth = null;
            commonHeight = null;
            useIndividualWidth = false;
            currentSaveId = null;
            
            document.getElementById('site-name').value = '';
            document.getElementById('sash-color').value = '';
            
            setTimeout(() => {
                resizeCanvas();
                setTimeout(() => {
                    if (type === 'i') {
                        document.getElementById('pattern-title').textContent = 'Iå­—å‹ æ¡å¯¸';
                        createIPattern();
                    } else if (type === 'l-left') {
                        document.getElementById('pattern-title').textContent = 'å·¦Lå­—å‹ æ¡å¯¸';
                        createLPatternLeft();
                    } else if (type === 'l-right') {
                        document.getElementById('pattern-title').textContent = 'å³Lå­—å‹ æ¡å¯¸';
                        createLPatternRight();
                    } else if (type === 'u') {
                        document.getElementById('pattern-title').textContent = 'ã‚³ã®å­—å‹ æ¡å¯¸';
                        createUPattern();
                    } else if (type === 'custom') {
                        document.getElementById('pattern-title').textContent = 'è‡ªç”±ä½œå›³';
                        setupCustomDrawing();
                    } else {
                        loadCustomPattern(type);
                    }
                }, 50);
            }, 10);
        }
        
        function createIPattern() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const lineLength = Math.min(canvas.width, canvas.height) * 0.6;
            lines = [{ id: 'A', x1: centerX - lineLength/2, y1: centerY, x2: centerX + lineLength/2, y2: centerY, name: 'è¾ºA', start: 'wall', end: 'wall' }];
            drawLines(); createInputs(); setupPointClickListener();
        }
        
        function createLPatternLeft() {
            const size = Math.min(canvas.width, canvas.height) * 0.5;
            const margin = Math.min(canvas.width, canvas.height) * 0.2;
            lines = [
                { id: 'A', x1: margin, y1: margin, x2: margin, y2: margin + size, name: 'è¾ºAï¼ˆç¸¦ï¼‰', start: 'corner', end: 'wall' },
                { id: 'B', x1: margin, y1: margin, x2: margin + size, y2: margin, name: 'è¾ºBï¼ˆæ¨ªï¼‰', start: 'corner', end: 'wall' }
            ];
            drawLines(); createInputs(); setupPointClickListener();
        }
        
        function createLPatternRight() {
            const size = Math.min(canvas.width, canvas.height) * 0.5;
            const margin = Math.min(canvas.width, canvas.height) * 0.2;
            lines = [
                { id: 'A', x1: margin, y1: margin, x2: margin + size, y2: margin, name: 'è¾ºAï¼ˆæ¨ªï¼‰', start: 'wall', end: 'corner' },
                { id: 'B', x1: margin + size, y1: margin, x2: margin + size, y2: margin + size, name: 'è¾ºBï¼ˆç¸¦ï¼‰', start: 'corner', end: 'wall' }
            ];
            drawLines(); createInputs(); setupPointClickListener();
        }
        
        function createUPattern() {
            const width = Math.min(canvas.width, canvas.height) * 0.5;
            const height = Math.min(canvas.width, canvas.height) * 0.4;
            const margin = Math.min(canvas.width, canvas.height) * 0.2;
            lines = [
                { id: 'A', x1: margin, y1: margin + height, x2: margin, y2: margin, name: 'è¾ºA', start: 'wall', end: 'corner' },
                { id: 'B', x1: margin, y1: margin, x2: margin + width, y2: margin, name: 'è¾ºB', start: 'corner', end: 'corner' },
                { id: 'C', x1: margin + width, y1: margin, x2: margin + width, y2: margin + height, name: 'è¾ºC', start: 'corner', end: 'wall' }
            ];
            drawLines(); createInputs(); setupPointClickListener();
        }
        
        function setupPointClickListener() {
            canvas.removeEventListener('click', handlePointClick);
            canvas.removeEventListener('touchend', handlePointClickTouch);
            canvas.addEventListener('click', handlePointClick);
            canvas.addEventListener('touchend', handlePointClickTouch);
        }
        
        function handlePointClickTouch(e) {
            if (isDrawing || isDragging) return;
            if (drawingPoints.length > 0) return;
            e.preventDefault();
            const touch = e.changedTouches[0];
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (touch.clientX - rect.left) * scaleX;
            const y = (touch.clientY - rect.top) * scaleY;
            const clickRadius = 25;
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (Math.sqrt(Math.pow(x - line.x1, 2) + Math.pow(y - line.y1, 2)) < clickRadius) { scrollToInput(line.id); return; }
                if (Math.sqrt(Math.pow(x - line.x2, 2) + Math.pow(y - line.y2, 2)) < clickRadius) { scrollToInput(line.id); return; }
                if (distanceToLineSegment(x, y, line.x1, line.y1, line.x2, line.y2) < 15) { scrollToInput(line.id); return; }
            }
        }
        
        function drawLines() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            detectCorners();
            if (lines.length === 0) return;
            
            const shouldTransform = currentPattern !== 'custom';
            let transform = (x, y) => ({ x, y });
            
            if (shouldTransform) {
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                lines.forEach(line => {
                    minX = Math.min(minX, line.x1, line.x2);
                    minY = Math.min(minY, line.y1, line.y2);
                    maxX = Math.max(maxX, line.x1, line.x2);
                    maxY = Math.max(maxY, line.y1, line.y2);
                });
                let shapeWidth = maxX - minX;
                let shapeHeight = maxY - minY;
                if (shapeWidth < 1) shapeWidth = 100;
                if (shapeHeight < 1) shapeHeight = 100;
                const margin = 50;
                const canvasWidth = canvas.width - margin * 2;
                const canvasHeight = canvas.height - margin * 2;
                const scaleX = canvasWidth / shapeWidth;
                const scaleY = canvasHeight / shapeHeight;
                const scale = Math.min(scaleX, scaleY, 1);
                const scaledWidth = shapeWidth * scale;
                const scaledHeight = shapeHeight * scale;
                const offsetX = margin + (canvasWidth - scaledWidth) / 2 - minX * scale;
                const offsetY = margin + (canvasHeight - scaledHeight) / 2 - minY * scale;
                transform = (x, y) => ({ x: x * scale + offsetX, y: y * scale + offsetY });
            }
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 5;
            ctx.lineCap = 'round';
            
            lines.forEach((line, index) => {
                const p1 = transform(line.x1, line.y1);
                const p2 = transform(line.x2, line.y2);
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
                
                const midX = (p1.x + p2.x) / 2;
                const midY = (p1.y + p2.y) / 2;
                
                const dim = dimensions[line.id];
                if (dim && dim.length) {
                    ctx.font = 'bold 18px sans-serif';
                    ctx.fillStyle = '#3b82f6';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const text = `${dim.length}`;
                    const metrics = ctx.measureText(text);
                    const padding = 8;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.fillRect(midX - metrics.width/2 - padding, midY - 12, metrics.width + padding*2, 24);
                    ctx.fillStyle = '#3b82f6';
                    ctx.fillText(text, midX, midY);
                }
                
                ctx.font = 'bold 13px sans-serif';
                const textWidth = ctx.measureText(line.name).width;
                const padding = 8;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.fillRect(midX - (textWidth + padding*2)/2, midY - 10 - 35, textWidth + padding*2, 20);
                ctx.fillStyle = '#333';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(line.name, midX, midY - 35);
            });
            
            const drawnCorners = new Set();
            if (corners) {
                for (const cornerKey in corners) {
                    const corner = corners[cornerKey];
                    if (!corner || drawnCorners.has(cornerKey)) continue;
                    drawnCorners.add(cornerKey);
                    if (!corner.lines || corner.lines.length === 0) continue;
                    
                    const firstLineRef = corner.lines[0];
                    const firstLine = lines.find(l => l.id === firstLineRef.lineId);
                    if (!firstLine) continue;
                    
                    const cornerX = corner.x !== undefined ? corner.x : (firstLine[firstLineRef.point === 'start' ? 'x1' : 'x2']);
                    const cornerY = corner.y !== undefined ? corner.y : (firstLine[firstLineRef.point === 'start' ? 'y1' : 'y2']);
                    
                    if (corner.hasStep && corner.lines.length >= 2) {
                        const line1Ref = corner.lines[0];
                        const line2Ref = corner.lines[1];
                        const line1 = lines.find(l => l.id === line1Ref.lineId);
                        const line2 = lines.find(l => l.id === line2Ref.lineId);
                        
                        if (line1 && line2) {
                            const state1 = line1[line1Ref.point] || 'wall';
                            const state2 = line2[line2Ref.point] || 'wall';
                            const offset = 32;
                            
                            let dx1, dy1;
                            if (line1Ref.point === 'start') { dx1 = line1.x2 - line1.x1; dy1 = line1.y2 - line1.y1; }
                            else { dx1 = line1.x1 - line1.x2; dy1 = line1.y1 - line1.y2; }
                            const len1 = Math.sqrt(dx1*dx1 + dy1*dy1);
                            
                            let dx2, dy2;
                            if (line2Ref.point === 'start') { dx2 = line2.x2 - line2.x1; dy2 = line2.y2 - line2.y1; }
                            else { dx2 = line2.x1 - line2.x2; dy2 = line2.y1 - line2.y2; }
                            const len2 = Math.sqrt(dx2*dx2 + dy2*dy2);
                            
                            if (len1 > 0 && len2 > 0) {
                                const p1 = transform(cornerX + (dx1/len1)*offset, cornerY + (dy1/len1)*offset);
                                const p2 = transform(cornerX + (dx2/len2)*offset, cornerY + (dy2/len2)*offset);
                                drawPoint(p1.x, p1.y, state1);
                                drawPoint(p2.x, p2.y, state2);
                            } else {
                                const p = transform(cornerX, cornerY);
                                drawPoint(p.x, p.y, state1);
                            }
                        }
                    } else {
                        const state = firstLine[firstLineRef.point] || 'wall';
                        const p = transform(cornerX, cornerY);
                        drawPoint(p.x, p.y, state);
                    }
                }
            }
            
            drawingPoints.forEach((point) => {
                ctx.fillStyle = '#f39c12';
                ctx.beginPath();
                ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }
        
        function drawPoint(x, y, state) {
            const colors = { 'corner': '#e74c3c', 'end': '#3498db', 'wall': '#2ecc71', 'cut': '#f59e0b' };
            const color = colors[state] || colors['end'];
            ctx.save();
            
            if (state === 'corner') {
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(x, y + 14); ctx.lineTo(x - 14, y - 11); ctx.lineTo(x + 14, y - 11);
                ctx.closePath(); ctx.fill();
                ctx.strokeStyle = 'white'; ctx.lineWidth = 4; ctx.stroke();
            } else if (state === 'wall') {
                ctx.fillStyle = color;
                ctx.fillRect(x - 14, y - 14, 28, 28);
                ctx.strokeStyle = 'white'; ctx.lineWidth = 4;
                ctx.strokeRect(x - 14, y - 14, 28, 28);
            } else {
                ctx.fillStyle = color;
                ctx.beginPath();
                const outerRadius = 17, innerRadius = 7, spikes = 5;
                for (let i = 0; i < spikes * 2; i++) {
                    const angle = (i * Math.PI) / spikes - Math.PI / 2;
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    const px = x + Math.cos(angle) * radius;
                    const py = y + Math.sin(angle) * radius;
                    if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                }
                ctx.closePath(); ctx.fill();
                ctx.strokeStyle = 'white'; ctx.lineWidth = 4; ctx.stroke();
            }
            ctx.restore();
        }
        
        function is90Degrees(line1, line2, point1, point2) {
            const dx1 = line1.x2 - line1.x1, dy1 = line1.y2 - line1.y1;
            const dx2 = line2.x2 - line2.x1, dy2 = line2.y2 - line2.y1;
            const dotProduct = dx1 * dx2 + dy1 * dy2;
            const magnitude1 = Math.sqrt(dx1*dx1 + dy1*dy1);
            const magnitude2 = Math.sqrt(dx2*dx2 + dy2*dy2);
            if (magnitude1 === 0 || magnitude2 === 0) return false;
            return Math.abs(dotProduct / (magnitude1 * magnitude2)) < 0.1;
        }
        
        function isDiagonalCorner(line1, line2, point1, point2) {
            if (is90Degrees(line1, line2, point1, point2)) return false;
            return isLineDiagonal(line1) || isLineDiagonal(line2);
        }
        
        function getCornerAngle(line1, line2) {
            const angle1 = Math.atan2(line1.y2 - line1.y1, line1.x2 - line1.x1) * (180 / Math.PI);
            const angle2 = Math.atan2(line2.y2 - line2.y1, line2.x2 - line2.x1) * (180 / Math.PI);
            let angleDiff = angle2 - angle1;
            while (angleDiff > 180) angleDiff -= 360;
            while (angleDiff < -180) angleDiff += 360;
            return Math.abs(angleDiff);
        }
        
        function getCornerAngleFromRefs(line1, line1Point, line2, line2Point) {
            const corner1X = line1Point === 'start' ? line1.x1 : line1.x2;
            const corner1Y = line1Point === 'start' ? line1.y1 : line1.y2;
            const other1X = line1Point === 'start' ? line1.x2 : line1.x1;
            const other1Y = line1Point === 'start' ? line1.y2 : line1.y1;
            const corner2X = line2Point === 'start' ? line2.x1 : line2.x2;
            const corner2Y = line2Point === 'start' ? line2.y1 : line2.y2;
            const other2X = line2Point === 'start' ? line2.x2 : line2.x1;
            const other2Y = line2Point === 'start' ? line2.y2 : line2.y1;
            const dx1 = other1X - corner1X, dy1 = other1Y - corner1Y;
            const dx2 = other2X - corner2X, dy2 = other2Y - corner2Y;
            const dot = dx1*dx2 + dy1*dy2;
            const len1 = Math.sqrt(dx1*dx1 + dy1*dy1);
            const len2 = Math.sqrt(dx2*dx2 + dy2*dy2);
            if (len1 === 0 || len2 === 0) return 0;
            return Math.acos(Math.max(-1, Math.min(1, dot / (len1 * len2)))) * (180 / Math.PI);
        }
        
        function isLineDiagonal(line) {
            return Math.abs(line.x2 - line.x1) > 5 && Math.abs(line.y2 - line.y1) > 5;
        }
        function isLineHorizontal(line) { return Math.abs(line.y2 - line.y1) < 5; }
        function isLineVertical(line) { return Math.abs(line.x2 - line.x1) < 5; }
        function getLineAngle(line) { return Math.atan2(line.y2 - line.y1, line.x2 - line.x1) * (180 / Math.PI); }
        
        function calculateAngleFromIntersection(diagonalLine) {
            if (!isLineDiagonal(diagonalLine)) return null;
            const horizontalLines = [], verticalLines = [];
            lines.forEach(line => {
                if (line.id === diagonalLine.id) return;
                if (isLineHorizontal(line)) horizontalLines.push(line);
                if (isLineVertical(line)) verticalLines.push(line);
            });
            if (horizontalLines.length === 0 || verticalLines.length === 0) return null;
            const candidates = [];
            const sp = { x: diagonalLine.x1, y: diagonalLine.y1 };
            const sr = findBestIntersection(sp, horizontalLines, verticalLines);
            if (sr) candidates.push(sr);
            const ep = { x: diagonalLine.x2, y: diagonalLine.y2 };
            const er = findBestIntersection(ep, horizontalLines, verticalLines);
            if (er) candidates.push(er);
            if (candidates.length === 0) return null;
            let bestAngle = null;
            for (const c of candidates) {
                if (c.angle >= 0 && c.angle <= 90) {
                    if (bestAngle === null || Math.abs(c.angle - 45) < Math.abs(bestAngle - 45)) bestAngle = c.angle;
                }
            }
            return bestAngle;
        }
        
        function findBestIntersection(point, horizontalLines, verticalLines) {
            let bestResult = null, minDistance = Infinity;
            horizontalLines.forEach(hLine => {
                verticalLines.forEach(vLine => {
                    const ix = vLine.x1, iy = hLine.y1;
                    const dx = Math.abs(point.x - ix), dy = Math.abs(point.y - iy);
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    if (distance < 10) return;
                    if (dx === 0 || dy === 0) return;
                    const angleDeg = Math.abs(Math.atan2(dy, dx) * (180 / Math.PI));
                    if (distance < minDistance) {
                        minDistance = distance;
                        bestResult = { intersection: {x:ix,y:iy}, distance, angle: angleDeg, horizontalLine: hLine, verticalLine: vLine };
                    }
                });
            });
            return bestResult;
        }
        
        function createInputs() {
            const container = document.getElementById('dimension-inputs');
            container.innerHTML = '';
            detectCorners();
            
            const infoDiv = document.createElement('div');
            infoDiv.style.cssText = 'background: #e3f2fd; padding: 12px; border-radius: 8px; margin-bottom: 15px;';
            infoDiv.innerHTML = `<p style="margin: 0; color: #555; font-size: 14px; line-height: 1.6;">
                <span style="color: #e74c3c; font-size: 16px;">â–¼</span> <strong>èµ¤ã„ä¸‰è§’ï¼ã‚³ãƒ¼ãƒŠãƒ¼</strong>ï¼ˆèº¯ä½“å¹…Ã·2ã‚’å¼•ãï¼‰ã€€
                <span style="color: #3498db; font-size: 16px;">â˜…</span> <strong>é’ã„æ˜Ÿï¼ã‚¨ãƒ³ãƒ‰</strong>ï¼ˆå£ãªã—ï¼‰ã€€
                <span style="color: #2ecc71; font-size: 16px;">â– </span> <strong>ç·‘ã®å››è§’ï¼å£</strong>ï¼ˆå£ã‚ã‚Šï¼‰
            </p>`;
            container.appendChild(infoDiv);
            
            const widthDiv = document.createElement('div');
            widthDiv.style.cssText = 'background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px;';
            widthDiv.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                    <div>
                        <label style="display: block; color: #555; font-weight: bold; margin-bottom: 8px;">èº¯ä½“å¹… (mm)</label>
                        <input type="number" id="common-width" placeholder="ä¾‹: 180" value="${commonWidth || ''}" 
                               oninput="updateCommonWidth(this.value)" 
                               style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px;">
                    </div>
                    <div>
                        <label style="display: block; color: #555; font-weight: bold; margin-bottom: 8px;">èº¯ä½“é«˜ã• (mm)</label>
                        <input type="number" id="common-height" placeholder="ä¾‹: 1100" value="${commonHeight || ''}" 
                               oninput="updateCommonHeight(this.value)" 
                               style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px;">
                    </div>
                </div>
                <div>
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="individual-width-check" ${useIndividualWidth ? 'checked' : ''} 
                               onchange="toggleIndividualWidth(this.checked)"
                               style="width: 18px; height: 18px; margin-right: 8px; cursor: pointer;">
                        <span style="color: #555; font-size: 14px;">è¾ºã”ã¨ã«èº¯ä½“å¹…ã‚’è¨­å®š</span>
                    </label>
                </div>`;
            container.appendChild(widthDiv);
            
            lines.forEach((line, lineIndex) => {
                const div = document.createElement('div');
                div.className = 'dimension-item';
                div.setAttribute('data-line-id', line.id);
                
                const startKey = findCornerKey(line.x1, line.y1, 5);
                const endKey = findCornerKey(line.x2, line.y2, 5);
                const startCorner = corners[startKey];
                const endCorner = corners[endKey];
                let startState = line.start || 'wall';
                let endState = line.end || 'wall';
                const isDiagonal = isLineDiagonal(line);
                
                const widthInput = useIndividualWidth ? `<input type="number" placeholder="èº¯ä½“å¹… (mm)" oninput="updateDimension('${line.id}', 'width', this.value)" value="${dimensions[line.id]?.width || ''}" style="padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 16px;">` : '';
                
                const pointButtons = `<div style="display: flex; gap: 8px;">
                    <button onclick="changePointState('${line.id}', 'start')" style="padding: 6px 12px; background: ${getStateColor(startState)}; color: white; border: none; border-radius: 6px; font-size: 12px; font-weight: bold; cursor: pointer;">å§‹ç‚¹: ${getStateLabel(startState)}</button>
                    <button onclick="changePointState('${line.id}', 'end')" style="padding: 6px 12px; background: ${getStateColor(endState)}; color: white; border: none; border-radius: 6px; font-size: 12px; font-weight: bold; cursor: pointer;">çµ‚ç‚¹: ${getStateLabel(endState)}</button>
                </div>`;
                
                let diagonalCornerWarning = '';
                if (startCorner && startCorner.lines && startCorner.lines.length >= 2) {
                    for (let ref of startCorner.lines) {
                        if (ref.lineId !== line.id) {
                            const adjacentLine = lines.find(l => l.id === ref.lineId);
                            if (adjacentLine && isDiagonalCorner(line, adjacentLine, 'start', ref.point)) {
                                const cornerAngle = getCornerAngle(line, adjacentLine);
                                diagonalCornerWarning += `<div style="margin-top: 10px; padding: 12px; background: #fee; border: 2px solid #e74c3c; border-radius: 8px;"><p style="margin: 0; color: #c0392b; font-weight: bold; font-size: 14px;">âš ï¸ å§‹ç‚¹ã¯æ–œã‚ã‚³ãƒ¼ãƒŠãƒ¼ã§ã™ï¼ˆè§’åº¦: ${cornerAngle.toFixed(1)}Â°ï¼‰</p><p style="margin: 5px 0 0 0; color: #c0392b; font-size: 13px;">å¤–æ³•å¯¸æ³•ã‹ã‚‰èŠ¯å¯¸æ³•ã‚’è¨ˆç®—ã§ãã¾ã›ã‚“ã€‚<br><strong>ç¾åœ°ã§èŠ¯å¯¸æ³•ã‚’ç›´æ¥æ¸¬å®šã—ã¦ãã ã•ã„ã€‚</strong></p></div>`;
                                break;
                            }
                        }
                    }
                }
                if (endCorner && endCorner.lines && endCorner.lines.length >= 2) {
                    for (let ref of endCorner.lines) {
                        if (ref.lineId !== line.id) {
                            const adjacentLine = lines.find(l => l.id === ref.lineId);
                            if (adjacentLine && isDiagonalCorner(line, adjacentLine, 'end', ref.point)) {
                                const cornerAngle = getCornerAngle(line, adjacentLine);
                                diagonalCornerWarning += `<div style="margin-top: 10px; padding: 12px; background: #fee; border: 2px solid #e74c3c; border-radius: 8px;"><p style="margin: 0; color: #c0392b; font-weight: bold; font-size: 14px;">âš ï¸ çµ‚ç‚¹ã¯æ–œã‚ã‚³ãƒ¼ãƒŠãƒ¼ã§ã™ï¼ˆè§’åº¦: ${cornerAngle.toFixed(1)}Â°ï¼‰</p><p style="margin: 5px 0 0 0; color: #c0392b; font-size: 13px;">å¤–æ³•å¯¸æ³•ã‹ã‚‰èŠ¯å¯¸æ³•ã‚’è¨ˆç®—ã§ãã¾ã›ã‚“ã€‚<br><strong>ç¾åœ°ã§èŠ¯å¯¸æ³•ã‚’ç›´æ¥æ¸¬å®šã—ã¦ãã ã•ã„ã€‚</strong></p></div>`;
                                break;
                            }
                        }
                    }
                }
                
                div.innerHTML = `
                    <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <span style="font-weight: bold; color: #667eea;">${line.name}${isDiagonal ? ' <span style="color: #ff9800;">ğŸ“æ–œã‚</span>' : ''}</span>
                        ${pointButtons}
                    </label>
                    ${diagonalCornerWarning}
                    <div class="dimension-row" style="display: grid; grid-template-columns: ${useIndividualWidth ? '1fr 1fr' : '1fr'}; gap: 10px;">
                        <input type="number" placeholder="${isDiagonal ? 'èŠ¯å¯¸æ³• (mm)' : 'å¤–æ³•å¯¸æ³• (mm)'}" 
                               oninput="updateDimension('${line.id}', 'length', this.value)"
                               value="${dimensions[line.id]?.length || ''}"
                               style="padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 16px;">
                        ${widthInput}
                    </div>`;
                container.appendChild(div);
                
                if (!dimensions[line.id]) dimensions[line.id] = { length: null, width: null };
                
                if (endCorner && endCorner.lines.length >= 2 && lineIndex < lines.length - 1) {
                    const cornerDiv = document.createElement('div');
                    cornerDiv.style.cssText = 'margin: 10px 0 20px 0; padding: 12px; background: #e8f5e9; border-radius: 6px; border: 2px solid #4caf50;';
                    const nextLine = lines[lineIndex + 1];
                    const cornerLabel = `${line.name}â”${nextLine.name}`;
                    const is90 = is90Degrees(line, nextLine, 'end', 'start');
                    const storedAngle = corners[endKey]?.angle;
                    const angleValue = storedAngle !== undefined && storedAngle !== null ? storedAngle.toFixed(1) : '';
                    
                    const angleInputSection = !is90 ? `<div style="margin-bottom: 12px;"><label style="display: block; color: #2e7d32; font-weight: bold; margin-bottom: 5px; font-size: 13px;">ğŸ“ ${cornerLabel} ã‚³ãƒ¼ãƒŠãƒ¼ã®è§’åº¦ï¼ˆåº¦ï¼‰</label><input type="number" id="corner-angle-${endKey}" placeholder="ç¾å ´ã§æ¸¬å®šã—ãŸè§’åº¦ã‚’å…¥åŠ›" value="${angleValue}" oninput="updateCornerAngle('${endKey}', this.value)" style="width: 100%; padding: 10px; border: 2px solid #4caf50; border-radius: 6px; font-size: 16px;"><p style="margin: 5px 0 0 0; font-size: 12px; color: #2e7d32;">â„¹ï¸ ç¾å ´ã§æ¸¬å®šã—ãŸè§’åº¦ã‚’æ‰‹å‹•ã§å…¥åŠ›ã—ã¦ãã ã•ã„</p></div>` : '';
                    
                    cornerDiv.innerHTML = `${angleInputSection}
                        <label style="display: flex; align-items: center; cursor: pointer; margin-bottom: 8px;">
                            <input type="checkbox" ${endCorner.hasStep ? 'checked' : ''} onchange="toggleCornerStep('${endKey}', this.checked)" style="width: 18px; height: 18px; margin-right: 8px; cursor: pointer;">
                            <span style="color: #2e7d32; font-weight: bold; font-size: 14px;">ğŸ“ ${cornerLabel} ã«æ®µå·®ã‚ã‚Š</span>
                        </label>
                        ${endCorner.hasStep ? `<input type="number" placeholder="æ·±ã• (mm)" value="${endCorner.depth || ''}" oninput="updateCornerDepth('${endKey}', this.value)" style="width: 100%; padding: 8px; border: 2px solid #4caf50; border-radius: 6px; font-size: 14px;">` : ''}`;
                    container.appendChild(cornerDiv);
                }
            });
        }
        
        function updateLineAngle(lineId, angleDegrees) {
            const lineIndex = lines.findIndex(line => line.id === lineId);
            if (lineIndex === -1) return;
            const line = lines[lineIndex];
            const angle = parseFloat(angleDegrees);
            if (isNaN(angle)) return;
            const dx = line.x2 - line.x1, dy = line.y2 - line.y1;
            const length = Math.sqrt(dx*dx + dy*dy);
            const radians = angle * (Math.PI / 180);
            line.x2 = line.x1 + length * Math.cos(radians);
            line.y2 = line.y1 + length * Math.sin(radians);
            drawLines(); createInputs();
        }
        
        function updateCommonWidth(value) {
            commonWidth = value ? parseFloat(value) : null;
            if (!useIndividualWidth) {
                lines.forEach(line => { if (dimensions[line.id]) dimensions[line.id].width = commonWidth; });
                drawLines(); calculate();
            }
        }
        
        function updateCommonHeight(value) {
            commonHeight = value ? parseFloat(value) : null;
            drawLines(); calculate();
        }
        
        function toggleCornerStep(cornerKey, hasStep) {
            if (!corners[cornerKey]) return;
            corners[cornerKey].hasStep = hasStep;
            const corner = corners[cornerKey];
            if (!hasStep) {
                corners[cornerKey].depth = null;
                corner.lines.forEach(lineRef => { const line = lines.find(l => l.id === lineRef.lineId); if (line) line[lineRef.point] = 'corner'; });
            } else {
                corner.lines.forEach((lineRef, index) => { const line = lines.find(l => l.id === lineRef.lineId); if (line) line[lineRef.point] = index === 0 ? 'end' : 'wall'; });
            }
            drawLines(); createInputs();
        }
        
        function updateCornerDepth(cornerKey, depth) { if (!corners[cornerKey]) return; corners[cornerKey].depth = depth ? parseFloat(depth) : null; }
        function updateCornerAngle(cornerKey, angle) { if (!corners[cornerKey]) return; corners[cornerKey].angle = angle ? parseFloat(angle) : null; calculate(); }
        
        function toggleIndividualWidth(checked) {
            useIndividualWidth = checked;
            if (!checked && commonWidth) lines.forEach(line => { if (dimensions[line.id]) dimensions[line.id].width = commonWidth; });
            createInputs(); drawLines(); calculate();
        }
        
        function getStateColor(state) { return { 'corner': '#e74c3c', 'end': '#3498db', 'wall': '#2ecc71' }[state] || '#3498db'; }
        function getStateLabel(state) { return { 'corner': 'ã‚³ãƒ¼ãƒŠãƒ¼', 'end': 'ã‚¨ãƒ³ãƒ‰', 'wall': 'å£' }[state] || 'ã‚¨ãƒ³ãƒ‰'; }
        
        function changePointState(lineId, point) {
            const lineIndex = lines.findIndex(line => line.id === lineId);
            if (lineIndex === -1) return;
            const line = lines[lineIndex];
            const x = point === 'start' ? line.x1 : line.x2;
            const y = point === 'start' ? line.y1 : line.y2;
            const cornerKey = findCornerKey(x, y, 5);
            const corner = corners[cornerKey];
            const isClosed = lines.length > 0 && Math.abs(lines[0].x1 - lines[lines.length-1].x2) < 5 && Math.abs(lines[0].y1 - lines[lines.length-1].y2) < 5;
            const isFirstLineStart = (lineIndex === 0 && point === 'start' && !isClosed);
            const isLastLineEnd = (lineIndex === lines.length-1 && point === 'end' && !isClosed);
            const hasStepAtCorner = corner && corner.hasStep;
            
            let states = (isFirstLineStart || isLastLineEnd || hasStepAtCorner) ? ['end', 'wall'] : ['corner', 'end', 'wall'];
            const currentState = lines[lineIndex][point] || 'wall';
            const currentIndex = states.indexOf(currentState);
            lines[lineIndex][point] = states[(currentIndex + 1) % states.length];
            if (lines[lineIndex][point] === 'corner') autoSetCorners();
            if (corner && corner.hasStep && corner.lines.length >= 2) syncCornerStatesWithStep(cornerKey, lineId, point, lines[lineIndex][point]);
            drawLines(); createInputs(); calculate();
        }
        
        function syncCornerStatesWithStep(cornerKey, changedLineId, changedPoint, newState) {
            const corner = corners[cornerKey];
            if (!corner) return;
            corner.lines.forEach(lineRef => {
                const line = lines.find(l => l.id === lineRef.lineId);
                if (!line || line.id === changedLineId) return;
                if (newState === 'end') line[lineRef.point] = 'wall';
            });
        }
        
        function updateDimension(id, type, value) {
            if (!dimensions[id]) dimensions[id] = { length: null, width: null };
            dimensions[id][type] = value ? parseFloat(value) : null;
            drawLines(); calculate();
        }
        
        // ========================================
        // ä¿å­˜ãƒ‡ãƒ¼ã‚¿ç®¡ç†
        // ========================================
        let currentSaveId = null;
        
        function saveCurrentData() {
            const siteName = document.getElementById('site-name')?.value || '';
            const sashColor = document.getElementById('sash-color')?.value || '';
            if (!siteName) { alert('ç¾å ´åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'); return; }
            if (!sashColor) { alert('è‰²ã‚’é¸æŠã—ã¦ãã ã•ã„'); return; }
            
            const saveData = {
                id: currentSaveId || Date.now().toString(),
                siteName, sashColor, pattern: currentPattern,
                lines: JSON.parse(JSON.stringify(lines)),
                dimensions: JSON.parse(JSON.stringify(dimensions)),
                commonWidth, commonHeight, useIndividualWidth,
                corners: JSON.parse(JSON.stringify(corners || {})),
                savedAt: new Date().toISOString(),
                updatedAt: new Date().toISOString()
            };
            
            let savedDataList = JSON.parse(localStorage.getItem('kutai_saved_data') || '[]');
            const existingIndex = savedDataList.findIndex(data => data.id === saveData.id);
            if (existingIndex >= 0) {
                saveData.savedAt = savedDataList[existingIndex].savedAt;
                savedDataList[existingIndex] = saveData;
                alert('ãƒ‡ãƒ¼ã‚¿ã‚’ä¸Šæ›¸ãä¿å­˜ã—ã¾ã—ãŸ');
            } else {
                savedDataList.push(saveData);
                currentSaveId = saveData.id;
                alert('ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã—ã¾ã—ãŸ');
            }
            localStorage.setItem('kutai_saved_data', JSON.stringify(savedDataList));
        }
        
        function showSavedDataList() {
            document.getElementById('pattern-select-screen').style.display = 'none';
            document.getElementById('measurement-screen').style.display = 'none';
            document.getElementById('saved-data-screen').style.display = 'block';
            displaySavedDataList();
        }
        
        function displaySavedDataList() {
            const savedDataList = JSON.parse(localStorage.getItem('kutai_saved_data') || '[]');
            const listElement = document.getElementById('saved-data-list');
            const noDataElement = document.getElementById('no-saved-data');
            if (savedDataList.length === 0) { listElement.style.display = 'none'; noDataElement.style.display = 'block'; return; }
            listElement.style.display = 'block'; noDataElement.style.display = 'none';
            savedDataList.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
            let html = '<div style="display: flex; flex-direction: column; gap: 12px;">';
            savedDataList.forEach(data => {
                const updatedDate = new Date(data.updatedAt).toLocaleDateString('ja-JP', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' });
                html += `<div class="saved-data-item" data-id="${data.id}" style="background: white; border: 2px solid #e5e7eb; border-radius: 8px; padding: 16px; cursor: pointer; transition: all 0.2s;"><div style="display: flex; justify-content: space-between; align-items: start;"><div onclick="loadSavedData('${data.id}')" style="flex: 1;"><div style="font-size: 18px; font-weight: bold; color: #1f2937; margin-bottom: 8px;">ğŸ“ ${data.siteName} ï¼ ğŸ¨ ${data.sashColor}</div><div style="font-size: 13px; color: #6b7280;">æ›´æ–°: ${updatedDate}</div></div><button onclick="event.stopPropagation(); deleteSavedData('${data.id}')" style="padding: 8px 16px; background: #ef4444; color: white; border: none; border-radius: 6px; font-size: 13px; cursor: pointer;">ğŸ—‘ï¸ å‰Šé™¤</button></div></div>`;
            });
            html += '</div>';
            listElement.innerHTML = html;
        }
        
        function loadSavedData(id) {
            const savedDataList = JSON.parse(localStorage.getItem('kutai_saved_data') || '[]');
            const data = savedDataList.find(d => d.id === id);
            if (!data) { alert('ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'); return; }
            currentSaveId = id;
            currentPattern = data.pattern;
            document.getElementById('saved-data-screen').style.display = 'none';
            document.getElementById('measurement-screen').style.display = 'block';
            lines = JSON.parse(JSON.stringify(data.lines));
            dimensions = JSON.parse(JSON.stringify(data.dimensions));
            commonWidth = data.commonWidth; commonHeight = data.commonHeight;
            useIndividualWidth = data.useIndividualWidth;
            corners = JSON.parse(JSON.stringify(data.corners || {}));
            document.getElementById('site-name').value = data.siteName;
            document.getElementById('sash-color').value = data.sashColor;
            const patternTitles = { 'i': 'Iå­—å‹ æ¡å¯¸', 'l-left': 'å·¦Lå­—å‹ æ¡å¯¸', 'l-right': 'å³Lå­—å‹ æ¡å¯¸', 'u': 'ã‚³ã®å­—å‹ æ¡å¯¸', 'custom': 'è‡ªç”±ä½œå›³' };
            document.getElementById('pattern-title').textContent = patternTitles[currentPattern] || 'æ¡å¯¸å…¥åŠ›';
            setTimeout(() => { resizeCanvas(); setTimeout(() => { drawLines(); createInputs(); calculate(); }, 50); }, 10);
        }
        
        function deleteSavedData(id) {
            if (!confirm('ã“ã®ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¦ã‚‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ')) return;
            let savedDataList = JSON.parse(localStorage.getItem('kutai_saved_data') || '[]');
            savedDataList = savedDataList.filter(data => data.id !== id);
            localStorage.setItem('kutai_saved_data', JSON.stringify(savedDataList));
            if (currentSaveId === id) currentSaveId = null;
            displaySavedDataList();
            alert('ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã—ãŸ');
        }
        
        function filterSavedData() {
            const searchName = document.getElementById('search-site-name').value.toLowerCase();
            const searchColor = document.getElementById('search-color').value;
            const savedDataList = JSON.parse(localStorage.getItem('kutai_saved_data') || '[]');
            let filteredList = savedDataList;
            if (searchName) filteredList = filteredList.filter(data => data.siteName.toLowerCase().includes(searchName));
            if (searchColor) filteredList = filteredList.filter(data => data.sashColor === searchColor);
            const listElement = document.getElementById('saved-data-list');
            const noDataElement = document.getElementById('no-saved-data');
            if (filteredList.length === 0) {
                listElement.style.display = 'none'; noDataElement.style.display = 'block';
                noDataElement.innerHTML = `<div style="text-align: center; padding: 40px; color: #9ca3af;"><div style="font-size: 48px; margin-bottom: 16px;">ğŸ”</div><div style="font-size: 18px; font-weight: bold; margin-bottom: 8px;">æ¤œç´¢çµæœãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“</div><div style="font-size: 14px;">åˆ¥ã®æ¤œç´¢æ¡ä»¶ã‚’ãŠè©¦ã—ãã ã•ã„</div></div>`;
                return;
            }
            listElement.style.display = 'block'; noDataElement.style.display = 'none';
            filteredList.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
            let html = '<div style="display: flex; flex-direction: column; gap: 12px;">';
            filteredList.forEach(data => {
                const updatedDate = new Date(data.updatedAt).toLocaleDateString('ja-JP', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' });
                html += `<div class="saved-data-item" data-id="${data.id}" style="background: white; border: 2px solid #e5e7eb; border-radius: 8px; padding: 16px; cursor: pointer; transition: all 0.2s;"><div style="display: flex; justify-content: space-between; align-items: start;"><div onclick="loadSavedData('${data.id}')" style="flex: 1;"><div style="font-size: 18px; font-weight: bold; color: #1f2937; margin-bottom: 8px;">ğŸ“ ${data.siteName} ï¼ ğŸ¨ ${data.sashColor}</div><div style="font-size: 13px; color: #6b7280;">æ›´æ–°: ${updatedDate}</div></div><button onclick="event.stopPropagation(); deleteSavedData('${data.id}')" style="padding: 8px 16px; background: #ef4444; color: white; border: none; border-radius: 6px; font-size: 13px; cursor: pointer;">ğŸ—‘ï¸ å‰Šé™¤</button></div></div>`;
            });
            html += '</div>';
            listElement.innerHTML = html;
        }
        
        function backToSelectFromSaved() {
            document.getElementById('saved-data-screen').style.display = 'none';
            document.getElementById('pattern-select-screen').style.display = 'block';
            document.getElementById('search-site-name').value = '';
            document.getElementById('search-color').value = '';
        }
        
        function checkRequiredFields() { calculate(); }
        
        function calculate() {
            const resultsContent = document.getElementById('results-content');
            let html = '';
            let hasAll = true;
            let missingItems = [];
            
            const siteName = document.getElementById('site-name')?.value || '';
            const sashColor = document.getElementById('sash-color')?.value || '';
            if (!siteName) { hasAll = false; missingItems.push('ç¾å ´å'); }
            if (!sashColor) { hasAll = false; missingItems.push('ã‚µãƒƒã‚·è‰²'); }
            
            detectCorners();
            
            lines.forEach(line => {
                const dim = dimensions[line.id];
                if (!dim || !dim.length) { hasAll = false; missingItems.push(`${line.name}ã®å¤–æ³•å¯¸æ³•`); }
                const hasWidth = useIndividualWidth ? (dim && dim.width) : commonWidth;
                if (!hasWidth) {
                    hasAll = false;
                    if (useIndividualWidth) missingItems.push(`${line.name}ã®èº¯ä½“å¹…`);
                    else if (!commonWidth && !missingItems.includes('èº¯ä½“å¹…')) missingItems.push('èº¯ä½“å¹…');
                }
            });
            
            if (!commonHeight) { hasAll = false; missingItems.push('èº¯ä½“é«˜ã•'); }
            
            if (corners) {
                for (const cornerKey in corners) {
                    const corner = corners[cornerKey];
                    if (corner && corner.hasStep && !corner.depth) {
                        hasAll = false;
                        if (corner.lines && corner.lines.length >= 2) {
                            const l1 = lines.find(l => l.id === corner.lines[0].lineId);
                            const l2 = lines.find(l => l.id === corner.lines[1].lineId);
                            missingItems.push(l1 && l2 ? `${l1.name}â”${l2.name}ã®æ®µå·®å¯¸æ³•` : 'æ®µå·®å¯¸æ³•');
                        } else missingItems.push('æ®µå·®å¯¸æ³•');
                    }
                }
            }
            
            if (hasAll) {
                lines.forEach(line => {
                    const dim = dimensions[line.id];
                    let result = dim.length;
                    if (line.start === 'corner') { const w = getAdjacentLineWidth(line.id, 'start'); if (w > 0) result -= w / 2; }
                    if (line.end === 'corner') { const w = getAdjacentLineWidth(line.id, 'end'); if (w > 0) result -= w / 2; }
                    const startLabel = getPointLabel(line.start);
                    const endLabel = getPointLabel(line.end);
                    html += `<div class="result-item"><span class="result-label">${line.name} ${startLabel}â”${endLabel}</span><span class="result-value">${Math.floor(result)} mm</span></div>`;
                });
                
                html = `
                    <div style="margin-bottom: 20px;">
                        <canvas id="result-canvas" width="500" height="400" style="width: 100%; border-radius: 10px;"></canvas>
                    </div>
                    <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
                        <button onclick="downloadAsPDF()" style="flex: 1; min-width: 140px; padding: 12px 20px; background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">ğŸ“„ PDFã§ä¿å­˜</button>
                        <button onclick="downloadAsPNG()" style="flex: 1; min-width: 140px; padding: 12px 20px; background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">ğŸ–¼ï¸ ç”»åƒã§ä¿å­˜</button>
                        <button onclick="shareResult()" style="flex: 1; min-width: 140px; padding: 12px 20px; background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">ğŸ“¤ å…±æœ‰</button>
                    </div>` + html;
                
                resultsContent.innerHTML = html;
                drawResultDiagram();
            } else {
                resultsContent.innerHTML = `<div style="background: #fee; border: 2px solid #e74c3c; border-radius: 10px; padding: 20px; text-align: center;"><div style="color: #e74c3c; font-size: 20px; font-weight: bold; margin-bottom: 15px;">âš ï¸ å…¥åŠ›ãŒå®Œäº†ã—ã¦ã„ã¾ã›ã‚“</div><div style="color: #c0392b; font-size: 16px; line-height: 1.8;">ä»¥ä¸‹ã®é …ç›®ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼š<br><strong>${missingItems.join('ã€')}</strong></div></div>`;
            }
        }
        
        function getAdjacentLineWidth(lineId, point) {
            const currentLine = lines.find(l => l.id === lineId);
            if (!currentLine) return 0;
            const x = point === 'start' ? currentLine.x1 : currentLine.x2;
            const y = point === 'start' ? currentLine.y1 : currentLine.y2;
            const cornerKey = findCornerKey(x, y, 5);
            if (!corners || !corners[cornerKey]) return 0;
            const corner = corners[cornerKey];
            for (const lineRef of corner.lines) {
                if (lineRef.lineId !== lineId) {
                    const adjacentLine = lines.find(l => l.id === lineRef.lineId);
                    if (adjacentLine) {
                        const adjacentDim = dimensions[lineRef.lineId];
                        if (adjacentDim && adjacentDim.width) return adjacentDim.width;
                    }
                }
            }
            return 0;
        }
        
        // ========================================
        // è¨ˆç®—çµæœå›³ï¼ˆv1.17.5 æ ¹æœ¬ä¿®æ­£ï¼‰
        // å…ƒã®ä½œå›³åº§æ¨™ã‚’ãã®ã¾ã¾ä½¿ç”¨ã—ã€ç¸åˆ‡ã‚Šå¾Œã‚‚æ­£ã—ãè¡¨ç¤º
        // ========================================
        function drawResultDiagram() {
            const resultCanvas = document.getElementById('result-canvas');
            if (!resultCanvas) return;
            const rctx = resultCanvas.getContext('2d');
            rctx.fillStyle = '#f0f9ff';
            rctx.fillRect(0, 0, resultCanvas.width, resultCanvas.height);
            if (lines.length === 0) return;
            
            // å…ƒã®åº§æ¨™ã‹ã‚‰ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã‚’è¨ˆç®—
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            lines.forEach(line => {
                minX = Math.min(minX, line.x1, line.x2);
                minY = Math.min(minY, line.y1, line.y2);
                maxX = Math.max(maxX, line.x1, line.x2);
                maxY = Math.max(maxY, line.y1, line.y2);
            });
            let shapeW = maxX - minX, shapeH = maxY - minY;
            if (shapeW < 1) shapeW = 100;
            if (shapeH < 1) shapeH = 100;
            
            const mg = 60;
            const cw = resultCanvas.width - mg*2, ch = resultCanvas.height - mg*2;
            const sc = Math.min(cw / shapeW, ch / shapeH);
            const ox = mg + (cw - shapeW*sc)/2 - minX*sc;
            const oy = mg + (ch - shapeH*sc)/2 - minY*sc;
            
            function tX(x) { return x*sc + ox; }
            function tY(y) { return y*sc + oy; }
            
            function drawRPoint(rx, ry, state) {
                const colors = { 'corner': '#ef4444', 'end': '#3b82f6', 'wall': '#10b981' };
                const color = colors[state] || colors['end'];
                const px = tX(rx), py = tY(ry);
                rctx.save();
                if (state === 'corner') {
                    rctx.fillStyle = color;
                    rctx.beginPath(); rctx.moveTo(px,py+12); rctx.lineTo(px-12,py-9); rctx.lineTo(px+12,py-9); rctx.closePath(); rctx.fill();
                    rctx.strokeStyle='white'; rctx.lineWidth=2.5; rctx.stroke();
                } else if (state === 'wall') {
                    rctx.fillStyle = color; rctx.fillRect(px-12,py-12,24,24);
                    rctx.strokeStyle='white'; rctx.lineWidth=2.5; rctx.strokeRect(px-12,py-12,24,24);
                } else {
                    rctx.fillStyle = color; rctx.beginPath();
                    const oR=15,iR=6,sp=5;
                    for(let i=0;i<sp*2;i++){const a=(i*Math.PI)/sp-Math.PI/2;const r=i%2===0?oR:iR;const sx=px+Math.cos(a)*r,sy=py+Math.sin(a)*r;if(i===0)rctx.moveTo(sx,sy);else rctx.lineTo(sx,sy);}
                    rctx.closePath(); rctx.fill(); rctx.strokeStyle='white'; rctx.lineWidth=2.5; rctx.stroke();
                }
                rctx.restore();
            }
            
            detectCorners();
            
            // ç·šã‚’æç”»ï¼ˆå…ƒã®åº§æ¨™ã‚’å¤‰æ›ã—ã¦ä½¿ç”¨ï¼‰
            lines.forEach(line => {
                const dim = dimensions[line.id];
                rctx.strokeStyle = '#1a1a1a'; rctx.lineWidth = 5; rctx.lineCap = 'round';
                rctx.beginPath(); rctx.moveTo(tX(line.x1),tY(line.y1)); rctx.lineTo(tX(line.x2),tY(line.y2)); rctx.stroke();
                
                if (dim && dim.length) {
                    let result = dim.length;
                    if (line.start==='corner'){const w=getAdjacentLineWidth(line.id,'start');if(w>0)result-=w/2;}
                    if (line.end==='corner'){const w=getAdjacentLineWidth(line.id,'end');if(w>0)result-=w/2;}
                    
                    const midX=(line.x1+line.x2)/2, midY=(line.y1+line.y2)/2;
                    const dx=line.x2-line.x1, dy=line.y2-line.y1;
                    const lineLen=Math.sqrt(dx*dx+dy*dy);
                    if(lineLen>0){
                        const perpX=-dy/lineLen, perpY=dx/lineLen;
                        const textX=tX(midX)+perpX*30, textY=tY(midY)+perpY*30;
                        
                        rctx.font='bold 16px sans-serif'; rctx.textAlign='center'; rctx.textBaseline='middle';
                        const rt=String(Math.floor(result)); const rm=rctx.measureText(rt); const pd=6;
                        rctx.fillStyle='rgba(254,243,199,0.85)'; rctx.fillRect(textX-rm.width/2-pd,textY-10,rm.width+pd*2,20);
                        rctx.strokeStyle='#f59e0b'; rctx.lineWidth=1.5; rctx.strokeRect(textX-rm.width/2-pd,textY-10,rm.width+pd*2,20);
                        rctx.fillStyle='#1e40af'; rctx.fillText(rt,textX,textY);
                        
                        // è¾ºå
                        rctx.font='bold 13px sans-serif';
                        const nm=rctx.measureText(line.name); const np=8;
                        const nX=tX(midX), nY=tY(midY)-25;
                        rctx.fillStyle='rgba(255,255,255,0.95)'; rctx.fillRect(nX-nm.width/2-np,nY-10,nm.width+np*2,20);
                        rctx.fillStyle='#333'; rctx.fillText(line.name,nX,nY);
                        
                        if(dim.width){
                            rctx.font='10px sans-serif';const wt='å¹…:'+dim.width;const wm=rctx.measureText(wt);const wY=textY+16;
                            rctx.fillStyle='rgba(243,244,246,0.85)';rctx.fillRect(textX-wm.width/2-3,wY-7,wm.width+6,14);
                            rctx.fillStyle='#6b7280';rctx.fillText(wt,textX,wY);
                        }
                    }
                }
            });
            
            // ç‚¹ã‚’æç”»
            const drawnCorners = new Set();
            if(corners){
                for(const ck in corners){
                    const c=corners[ck];
                    if(!c||drawnCorners.has(ck))continue; drawnCorners.add(ck);
                    if(!c.lines||c.lines.length===0)continue;
                    const flr=c.lines[0]; const fl=lines.find(l=>l.id===flr.lineId); if(!fl)continue;
                    const cX=c.x!==undefined?c.x:(fl[flr.point==='start'?'x1':'x2']);
                    const cY=c.y!==undefined?c.y:(fl[flr.point==='start'?'y1':'y2']);
                    
                    if(c.hasStep&&c.lines.length>=2){
                        const r1=c.lines[0],r2=c.lines[1];
                        const l1=lines.find(l=>l.id===r1.lineId),l2=lines.find(l=>l.id===r2.lineId);
                        if(l1&&l2){
                            const s1=l1[r1.point]||'wall',s2=l2[r2.point]||'wall';const so=30;
                            let d1x,d1y;if(r1.point==='start'){d1x=l1.x2-l1.x1;d1y=l1.y2-l1.y1;}else{d1x=l1.x1-l1.x2;d1y=l1.y1-l1.y2;}
                            const ln1=Math.sqrt(d1x*d1x+d1y*d1y);
                            let d2x,d2y;if(r2.point==='start'){d2x=l2.x2-l2.x1;d2y=l2.y2-l2.y1;}else{d2x=l2.x1-l2.x2;d2y=l2.y1-l2.y2;}
                            const ln2=Math.sqrt(d2x*d2x+d2y*d2y);
                            if(ln1>0&&ln2>0){drawRPoint(cX+(d1x/ln1)*so,cY+(d1y/ln1)*so,s1);drawRPoint(cX+(d2x/ln2)*so,cY+(d2y/ln2)*so,s2);}
                            else drawRPoint(cX,cY,s1);
                        }
                    } else { drawRPoint(cX,cY,fl[flr.point]||'wall'); }
                }
            }
            
            // å‡¡ä¾‹
            const lx=resultCanvas.width-85, ly=resultCanvas.height-70;
            rctx.font='bold 12px sans-serif'; rctx.textAlign='left';
            rctx.fillStyle='rgba(255,255,255,0.9)';
            rctx.fillText('ç‚¹ã®ç¨®é¡',lx+1,ly+1);rctx.fillText('ç‚¹ã®ç¨®é¡',lx-1,ly-1);
            rctx.fillText('ç‚¹ã®ç¨®é¡',lx+1,ly-1);rctx.fillText('ç‚¹ã®ç¨®é¡',lx-1,ly+1);
            rctx.fillStyle='#1f2937';rctx.fillText('ç‚¹ã®ç¨®é¡',lx,ly);
            [{c:'#ef4444',l:'ã‚³ãƒ¼ãƒŠãƒ¼',s:'corner'},{c:'#3b82f6',l:'ã‚¨ãƒ³ãƒ‰',s:'end'},{c:'#10b981',l:'å£',s:'wall'}].forEach((item,idx)=>{
                const iy=ly+22+idx*18,ix=lx+6;
                rctx.save();
                if(item.s==='corner'){rctx.fillStyle='rgba(0,0,0,0.3)';rctx.beginPath();rctx.moveTo(ix,iy+6);rctx.lineTo(ix-5,iy-4);rctx.lineTo(ix+5,iy-4);rctx.closePath();rctx.fill();rctx.fillStyle=item.c;rctx.beginPath();rctx.moveTo(ix-1,iy+5);rctx.lineTo(ix-6,iy-5);rctx.lineTo(ix+4,iy-5);rctx.closePath();rctx.fill();}
                else if(item.s==='wall'){rctx.fillStyle='rgba(0,0,0,0.3)';rctx.fillRect(ix-4,iy-4,9,9);rctx.fillStyle=item.c;rctx.fillRect(ix-5,iy-5,9,9);}
                else{rctx.fillStyle='rgba(0,0,0,0.3)';rctx.beginPath();for(let i=0;i<10;i++){const a=(i*Math.PI)/5-Math.PI/2;const r=i%2===0?6:2.5;if(i===0)rctx.moveTo(ix+1+Math.cos(a)*r,iy+1+Math.sin(a)*r);else rctx.lineTo(ix+1+Math.cos(a)*r,iy+1+Math.sin(a)*r);}rctx.closePath();rctx.fill();rctx.fillStyle=item.c;rctx.beginPath();for(let i=0;i<10;i++){const a=(i*Math.PI)/5-Math.PI/2;const r=i%2===0?6:2.5;if(i===0)rctx.moveTo(ix+Math.cos(a)*r,iy+Math.sin(a)*r);else rctx.lineTo(ix+Math.cos(a)*r,iy+Math.sin(a)*r);}rctx.closePath();rctx.fill();}
                rctx.restore();
                rctx.font='11px sans-serif';rctx.fillStyle='rgba(255,255,255,0.9)';
                rctx.fillText(item.l,lx+16,iy+5);rctx.fillText(item.l,lx+14,iy+3);rctx.fillText(item.l,lx+16,iy+3);rctx.fillText(item.l,lx+14,iy+5);
                rctx.fillStyle='#374151';rctx.fillText(item.l,lx+15,iy+4);
            });
        }
        
        function getPointLabel(state) {
            return { 'corner': '<span style="color: #e74c3c;">â–¼</span>', 'end': '<span style="color: #3498db;">â˜…</span>', 'wall': '<span style="color: #2ecc71;">â– </span>' }[state] || '<span style="color: #3498db;">â˜…</span>';
        }
        
        function setupCustomDrawing() {
            document.getElementById('dimension-inputs').innerHTML = `
                <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0; color: #1976d2; font-size: 16px;">ğŸ“ ä½œå›³æ–¹æ³•</h3>
                    <p style="margin: 0; color: #555; font-size: 14px;"><strong>ã‚¯ãƒªãƒƒã‚¯</strong>ã§ç‚¹ã‚’æ‰“ã¡ã€ç·šã‚’é€£ç¶šã—ã¦å¼•ã<br><strong>ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯</strong>ã¾ãŸã¯ä¸‹ã®ãƒœã‚¿ãƒ³ã§ä½œå›³çµ‚äº†</p>
                    <button onclick="finishDrawing()" style="width: 100%; padding: 12px; background: #27ae60; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: bold; cursor: pointer; margin-top: 10px;">âœ“ ä½œå›³çµ‚äº†</button>
                    <h3 style="margin: 15px 0 10px 0; color: #1976d2; font-size: 16px;">ğŸ¨ ç‚¹ã®æ„å‘³</h3>
                    <p style="margin: 0; color: #555; font-size: 14px;">
                        <span style="color: #e74c3c;">â–¼</span> èµ¤ï¼šã‚³ãƒ¼ãƒŠãƒ¼ï¼ˆèº¯ä½“å¹…Ã·2ã‚’å¼•ãï¼‰<br>
                        <span style="color: #3498db;">â˜…</span> é’ï¼šã‚¨ãƒ³ãƒ‰ï¼ˆç«¯éƒ¨ã€å£ãªã—ï¼‰<br>
                        <span style="color: #2ecc71;">â– </span> ç·‘ï¼šå£ï¼ˆå£ã‚ã‚Šï¼‰<br>
                        <strong>ä½œå›³çµ‚äº†å¾Œã€ç‚¹ã‚’ã‚¿ãƒƒãƒ—ã§åˆ‡ã‚Šæ›¿ãˆ</strong>
                    </p>
                </div>`;
            drawingPoints = [];
            canvas.removeEventListener('mousedown', startDrawing);
            canvas.removeEventListener('mousemove', drawing);
            canvas.removeEventListener('mouseup', endDrawing);
            canvas.removeEventListener('click', handlePointClick);
            canvas.removeEventListener('touchend', handlePointClickTouch);
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('mousemove', handleCanvasMouseMove);
            canvas.addEventListener('touchstart', handleTouchDrawing);
            canvas.addEventListener('touchmove', handleTouchDrawingMove);
            updateDrawingControls();
        }
        
        function handleCanvasClick(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width, scaleY = canvas.height / rect.height;
            let x = (e.offsetX || e.clientX - rect.left) * scaleX;
            let y = (e.offsetY || e.clientY - rect.top) * scaleY;
            if (drawingPoints.length > 0) { const lp = drawingPoints[drawingPoints.length-1]; const s = snapToAxis(lp.x,lp.y,x,y); x=s.x; y=s.y; }
            
            if (drawingPoints.length >= 3) {
                const sp = drawingPoints[0];
                if (Math.sqrt(Math.pow(x-sp.x,2)+Math.pow(y-sp.y,2)) < 30) {
                    if (confirm('å›³å½¢ã‚’é–‰ã˜ã¾ã™ã‹ï¼Ÿ\nï¼ˆå§‹ç‚¹ã¨çµ‚ç‚¹ã‚’çµåˆã—ã¾ã™ï¼‰')) {
                        x=sp.x; y=sp.y; drawingPoints.push({x,y});
                        const pp=drawingPoints[drawingPoints.length-2], cp=drawingPoints[drawingPoints.length-1];
                        const id=String.fromCharCode(65+lines.length);
                        lines.push({id,x1:pp.x,y1:pp.y,x2:cp.x,y2:cp.y,name:`è¾º${id}`,start:'wall',end:'wall'});
                        autoSetCorners(); finishDrawing(); return;
                    } else return;
                }
            }
            
            const clickRadius = 20;
            for (let i=0;i<lines.length;i++) {
                const line=lines[i]; let isStart=false;
                if(drawingPoints.length>=3&&i===0){const sp=drawingPoints[0];isStart=Math.sqrt(Math.pow(line.x1-sp.x,2)+Math.pow(line.y1-sp.y,2))<5;}
                if(!isStart&&Math.sqrt(Math.pow(x-line.x1,2)+Math.pow(y-line.y1,2))<clickRadius)return;
                if(Math.sqrt(Math.pow(x-line.x2,2)+Math.pow(y-line.y2,2))<clickRadius)return;
            }
            
            const ct=new Date().getTime(); if(ct-lastClickTime<500&&drawingPoints.length>0){finishDrawing();return;} lastClickTime=ct;
            drawingPoints.push({x,y});
            if(drawingPoints.length>=2){
                const pp=drawingPoints[drawingPoints.length-2],cp=drawingPoints[drawingPoints.length-1];
                const id=String.fromCharCode(65+lines.length);
                lines.push({id,x1:pp.x,y1:pp.y,x2:cp.x,y2:cp.y,name:`è¾º${id}`,start:'wall',end:'wall'});
                autoSetCorners();
            }
            drawLines(); updateDrawingControls();
        }
        
        function handleCanvasMouseMove(e) {
            if(drawingPoints.length===0)return;
            const rect=canvas.getBoundingClientRect();const scaleX=canvas.width/rect.width,scaleY=canvas.height/rect.height;
            let x=(e.offsetX||e.clientX-rect.left)*scaleX,y=(e.offsetY||e.clientY-rect.top)*scaleY;
            const lp=drawingPoints[drawingPoints.length-1];const s=snapToAxis(lp.x,lp.y,x,y);x=s.x;y=s.y;
            drawLines();
            let snap=false;
            if(drawingPoints.length>=3){
                const sp=drawingPoints[0];const th=10;
                if(Math.abs(y-sp.y)<th){ctx.strokeStyle='#f59e0b';ctx.lineWidth=1;ctx.setLineDash([4,4]);ctx.beginPath();ctx.moveTo(x,sp.y);ctx.lineTo(sp.x,sp.y);ctx.stroke();y=sp.y;if(Math.abs(x-sp.x)<th){x=sp.x;snap=true;}}
                if(Math.abs(x-sp.x)<th){ctx.strokeStyle='#f59e0b';ctx.lineWidth=1;ctx.setLineDash([4,4]);ctx.beginPath();ctx.moveTo(sp.x,y);ctx.lineTo(sp.x,sp.y);ctx.stroke();x=sp.x;if(Math.abs(y-sp.y)<th){y=sp.y;snap=true;}}
                if(snap){ctx.fillStyle='#f59e0b';ctx.beginPath();ctx.arc(sp.x,sp.y,8,0,Math.PI*2);ctx.fill();ctx.strokeStyle='white';ctx.lineWidth=2;ctx.stroke();}
            }
            if(!snap){
                if(Math.abs(y-lp.y)<30){ctx.strokeStyle='#10b981';ctx.lineWidth=1;ctx.setLineDash([2,2]);ctx.beginPath();ctx.moveTo(0,lp.y);ctx.lineTo(canvas.width,lp.y);ctx.stroke();}
                if(Math.abs(x-lp.x)<30){ctx.strokeStyle='#10b981';ctx.lineWidth=1;ctx.setLineDash([2,2]);ctx.beginPath();ctx.moveTo(lp.x,0);ctx.lineTo(lp.x,canvas.height);ctx.stroke();}
            }
            ctx.strokeStyle=snap?'#f59e0b':'#667eea';ctx.lineWidth=3;ctx.setLineDash([5,5]);ctx.lineCap='round';
            ctx.beginPath();ctx.moveTo(lp.x,lp.y);ctx.lineTo(x,y);ctx.stroke();ctx.setLineDash([]);
        }
        
        function snapToAxis(x1,y1,x2,y2){const dx=Math.abs(x2-x1),dy=Math.abs(y2-y1),th=30;if(dx>dy&&dy<th)return{x:x2,y:y1};if(dy>dx&&dx<th)return{x:x1,y:y2};return{x:x2,y:y2};}
        
        function handleTouchDrawing(e) {
            e.preventDefault();const touch=e.touches[0];const rect=canvas.getBoundingClientRect();
            const scaleX=canvas.width/rect.width,scaleY=canvas.height/rect.height;
            let x=(touch.clientX-rect.left)*scaleX,y=(touch.clientY-rect.top)*scaleY;
            if(drawingPoints.length>0){const lp=drawingPoints[drawingPoints.length-1];const s=snapToAxis(lp.x,lp.y,x,y);x=s.x;y=s.y;}
            if(drawingPoints.length>=3){const sp=drawingPoints[0];if(Math.sqrt(Math.pow(x-sp.x,2)+Math.pow(y-sp.y,2))<40){if(confirm('å›³å½¢ã‚’é–‰ã˜ã¾ã™ã‹ï¼Ÿ\nï¼ˆå§‹ç‚¹ã¨çµ‚ç‚¹ã‚’çµåˆã—ã¾ã™ï¼‰')){x=sp.x;y=sp.y;drawingPoints.push({x,y});const pp=drawingPoints[drawingPoints.length-2],cp=drawingPoints[drawingPoints.length-1];const id=String.fromCharCode(65+lines.length);lines.push({id,x1:pp.x,y1:pp.y,x2:cp.x,y2:cp.y,name:`è¾º${id}`,start:'wall',end:'wall'});autoSetCorners();finishDrawing();return;}else return;}}
            const clickRadius=25;for(let i=0;i<lines.length;i++){const line=lines[i];let isStart=false;if(drawingPoints.length>=3&&i===0){const sp=drawingPoints[0];isStart=Math.sqrt(Math.pow(line.x1-sp.x,2)+Math.pow(line.y1-sp.y,2))<5;}if(!isStart&&Math.sqrt(Math.pow(x-line.x1,2)+Math.pow(y-line.y1,2))<clickRadius)return;if(Math.sqrt(Math.pow(x-line.x2,2)+Math.pow(y-line.y2,2))<clickRadius)return;}
            const ct=new Date().getTime();if(ct-lastTapTime<500&&drawingPoints.length>0){finishDrawing();return;}lastTapTime=ct;
            drawingPoints.push({x,y});
            if(drawingPoints.length>=2){const pp=drawingPoints[drawingPoints.length-2],cp=drawingPoints[drawingPoints.length-1];const id=String.fromCharCode(65+lines.length);lines.push({id,x1:pp.x,y1:pp.y,x2:cp.x,y2:cp.y,name:`è¾º${id}`,start:'wall',end:'wall'});autoSetCorners();}
            drawLines();updateDrawingControls();
        }
        
        function handleTouchDrawingMove(e) {
            if(drawingPoints.length===0)return;e.preventDefault();
            const touch=e.touches[0];const rect=canvas.getBoundingClientRect();
            const scaleX=canvas.width/rect.width,scaleY=canvas.height/rect.height;
            let x=(touch.clientX-rect.left)*scaleX,y=(touch.clientY-rect.top)*scaleY;
            const lp=drawingPoints[drawingPoints.length-1];const s=snapToAxis(lp.x,lp.y,x,y);x=s.x;y=s.y;
            drawLines();
            let snap=false;
            if(drawingPoints.length>=3){const sp=drawingPoints[0];const th=15;
                if(Math.abs(y-sp.y)<th){ctx.strokeStyle='#f59e0b';ctx.lineWidth=2;ctx.setLineDash([4,4]);ctx.beginPath();ctx.moveTo(x,sp.y);ctx.lineTo(sp.x,sp.y);ctx.stroke();y=sp.y;if(Math.abs(x-sp.x)<th){x=sp.x;snap=true;}}
                if(Math.abs(x-sp.x)<th){ctx.strokeStyle='#f59e0b';ctx.lineWidth=2;ctx.setLineDash([4,4]);ctx.beginPath();ctx.moveTo(sp.x,y);ctx.lineTo(sp.x,sp.y);ctx.stroke();x=sp.x;if(Math.abs(y-sp.y)<th){y=sp.y;snap=true;}}
                if(snap){ctx.fillStyle='#f59e0b';ctx.beginPath();ctx.arc(sp.x,sp.y,10,0,Math.PI*2);ctx.fill();ctx.strokeStyle='white';ctx.lineWidth=2;ctx.stroke();}
            }
            if(!snap){if(Math.abs(y-lp.y)<30){ctx.strokeStyle='#10b981';ctx.lineWidth=1;ctx.setLineDash([2,2]);ctx.beginPath();ctx.moveTo(0,lp.y);ctx.lineTo(canvas.width,lp.y);ctx.stroke();}if(Math.abs(x-lp.x)<30){ctx.strokeStyle='#10b981';ctx.lineWidth=1;ctx.setLineDash([2,2]);ctx.beginPath();ctx.moveTo(lp.x,0);ctx.lineTo(lp.x,canvas.height);ctx.stroke();}}
            ctx.strokeStyle=snap?'#f59e0b':'#667eea';ctx.lineWidth=3;ctx.setLineDash([5,5]);ctx.lineCap='round';
            ctx.beginPath();ctx.moveTo(lp.x,lp.y);ctx.lineTo(x,y);ctx.stroke();ctx.setLineDash([]);
        }
        
        function finishDrawing() {
            drawingPoints=[];drawLines();
            canvas.removeEventListener('click',handleCanvasClick);canvas.removeEventListener('mousemove',handleCanvasMouseMove);
            canvas.removeEventListener('touchstart',handleTouchDrawing);canvas.removeEventListener('touchmove',handleTouchDrawingMove);
            canvas.addEventListener('click',handlePointClick);canvas.addEventListener('touchend',handlePointClickTouch);
            if(lines.length>0)createInputs();
            updateDrawingControls();
        }
        
        function showAlert(message,type='info'){
            const alertDiv=document.getElementById('alert');if(!alertDiv){alert(message);return;}
            const colors={'info':{bg:'#dbeafe',border:'#3b82f6',text:'#1e40af'},'success':{bg:'#d1fae5',border:'#10b981',text:'#065f46'},'warning':{bg:'#fef3c7',border:'#f59e0b',text:'#92400e'},'error':{bg:'#fee2e2',border:'#ef4444',text:'#991b1b'}};
            const c=colors[type]||colors.info;
            alertDiv.style.cssText=`display:block;padding:12px 16px;margin:10px 0;background:${c.bg};border:2px solid ${c.border};border-radius:8px;color:${c.text};font-weight:600;animation:slideDown 0.3s ease;`;
            alertDiv.textContent=message;setTimeout(()=>{alertDiv.style.display='none';},3000);
        }
        
        function cutEdge(){
            if(drawingPoints.length===0){showAlert('ç·šã‚’å¼•ã„ã¦ã‹ã‚‰ç¸åˆ‡ã‚Šã—ã¦ãã ã•ã„','info');return;}
            drawingPoints=[];drawLines();
            showAlert('âœ‚ï¸ ç¸åˆ‡ã‚Šã—ã¾ã—ãŸã€‚æ¬¡ã®ç·šã¯ç‹¬ç«‹ã—ãŸç·šã¨ã—ã¦å¼•ã‘ã¾ã™','success');
            updateDrawingControls();
        }
        
        function handlePointClick(e){
            if(isDrawing||isDragging)return;if(drawingPoints.length>0)return;
            const rect=canvas.getBoundingClientRect();const scaleX=canvas.width/rect.width,scaleY=canvas.height/rect.height;
            const x=(e.offsetX||e.clientX-rect.left)*scaleX,y=(e.offsetY||e.clientY-rect.top)*scaleY;
            const clickRadius=20;
            for(let i=0;i<lines.length;i++){
                const line=lines[i];
                if(Math.sqrt(Math.pow(x-line.x1,2)+Math.pow(y-line.y1,2))<clickRadius){scrollToInput(line.id);return;}
                if(Math.sqrt(Math.pow(x-line.x2,2)+Math.pow(y-line.y2,2))<clickRadius){scrollToInput(line.id);return;}
                if(distanceToLineSegment(x,y,line.x1,line.y1,line.x2,line.y2)<10){scrollToInput(line.id);return;}
            }
        }
        
        function distanceToLineSegment(px,py,x1,y1,x2,y2){
            const dx=x2-x1,dy=y2-y1,lsq=dx*dx+dy*dy;
            if(lsq===0)return Math.sqrt((px-x1)*(px-x1)+(py-y1)*(py-y1));
            let t=((px-x1)*dx+(py-y1)*dy)/lsq;t=Math.max(0,Math.min(1,t));
            const nx=x1+t*dx,ny=y1+t*dy;
            return Math.sqrt((px-nx)*(px-nx)+(py-ny)*(py-ny));
        }
        
        function scrollToInput(lineId){
            setTimeout(()=>{const ig=document.querySelector(`[data-line-id="${lineId}"]`);if(ig){ig.scrollIntoView({behavior:'smooth',block:'center'});ig.style.transition='background-color 0.3s';ig.style.backgroundColor='#fef3c7';setTimeout(()=>{ig.style.backgroundColor='';},2000);}},100);
        }
        
        function autoSetCorners(){
            const tolerance=5;
            const isClosed=lines.length>0&&Math.abs(lines[0].x1-lines[lines.length-1].x2)<tolerance&&Math.abs(lines[0].y1-lines[lines.length-1].y2)<tolerance;
            for(let i=0;i<lines.length;i++){for(let j=i+1;j<lines.length;j++){
                const l1=lines[i],l2=lines[j];
                if(Math.abs(l1.x1-l2.x1)<tolerance&&Math.abs(l1.y1-l2.y1)<tolerance){if(is90Degrees(l1,l2,'start','start')){if(i!==0||isClosed)l1.start='corner';if(j!==0||isClosed)l2.start='corner';}else{if((i!==0||isClosed)&&l1.start==='corner')l2.start='corner';if((j!==0||isClosed)&&l2.start==='corner')l1.start='corner';}}
                if(Math.abs(l1.x1-l2.x2)<tolerance&&Math.abs(l1.y1-l2.y2)<tolerance){if(is90Degrees(l1,l2,'start','end')){if(i!==0||isClosed)l1.start='corner';if(j!==lines.length-1||isClosed)l2.end='corner';}else{if((i!==0||isClosed)&&l1.start==='corner')l2.end='corner';if((j!==lines.length-1||isClosed)&&l2.end==='corner')l1.start='corner';}}
                if(Math.abs(l1.x2-l2.x1)<tolerance&&Math.abs(l1.y2-l2.y1)<tolerance){if(is90Degrees(l1,l2,'end','start')){if(i!==lines.length-1||isClosed)l1.end='corner';if(j!==0||isClosed)l2.start='corner';}else{if((i!==lines.length-1||isClosed)&&l1.end==='corner')l2.start='corner';if((j!==0||isClosed)&&l2.start==='corner')l1.end='corner';}}
                if(Math.abs(l1.x2-l2.x2)<tolerance&&Math.abs(l1.y2-l2.y2)<tolerance){if(is90Degrees(l1,l2,'end','end')){if(i!==lines.length-1||isClosed)l1.end='corner';if(j!==lines.length-1||isClosed)l2.end='corner';}else{if((i!==lines.length-1||isClosed)&&l1.end==='corner')l2.end='corner';if((j!==lines.length-1||isClosed)&&l2.end==='corner')l1.end='corner';}}
            }}
        }
        
        function togglePointState(lineIndex,point){
            const line=lines[lineIndex];const x=point==='start'?line.x1:line.x2;const y=point==='start'?line.y1:line.y2;
            const cornerKey=findCornerKey(x,y,5);const corner=corners[cornerKey];
            const isClosed=lines.length>0&&Math.abs(lines[0].x1-lines[lines.length-1].x2)<5&&Math.abs(lines[0].y1-lines[lines.length-1].y2)<5;
            const isFirst=(lineIndex===0&&point==='start'&&!isClosed);const isLast=(lineIndex===lines.length-1&&point==='end'&&!isClosed);
            const hasStep=corner&&corner.hasStep;
            let states=(isFirst||isLast||hasStep)?['end','wall']:['corner','end','wall'];
            const cur=lines[lineIndex][point]||'wall';lines[lineIndex][point]=states[(states.indexOf(cur)+1)%states.length];
            if(lines[lineIndex][point]==='corner')autoSetCorners();
            if(corner&&corner.hasStep&&corner.lines.length>=2)syncCornerStatesWithStep(cornerKey,line.id,point,lines[lineIndex][point]);
        }
        
        function handleTouch(e){e.preventDefault();const t=e.touches[0]||e.changedTouches[0];const r=canvas.getBoundingClientRect();const sx=canvas.width/r.width,sy=canvas.height/r.height;const x=(t.clientX-r.left)*sx,y=(t.clientY-r.top)*sy;if(e.type==='touchstart')startDrawing({offsetX:x,offsetY:y});else if(e.type==='touchmove')drawing({offsetX:x,offsetY:y});else if(e.type==='touchend')endDrawing({offsetX:x,offsetY:y});}
        
        function startDrawing(e){isDrawing=true;isDragging=false;const r=canvas.getBoundingClientRect();const sx=canvas.width/r.width,sy=canvas.height/r.height;startPoint={x:(e.offsetX||e.clientX-r.left)*sx,y:(e.offsetY||e.clientY-r.top)*sy};}
        function drawing(e){if(!isDrawing)return;isDragging=true;const r=canvas.getBoundingClientRect();const sx=canvas.width/r.width,sy=canvas.height/r.height;const x=(e.offsetX||e.clientX-r.left)*sx,y=(e.offsetY||e.clientY-r.top)*sy;drawLines();ctx.strokeStyle='#667eea';ctx.lineWidth=3;ctx.setLineDash([5,5]);ctx.lineCap='round';ctx.beginPath();ctx.moveTo(startPoint.x,startPoint.y);ctx.lineTo(x,y);ctx.stroke();ctx.setLineDash([]);}
        function endDrawing(e){if(!isDrawing)return;if(isDragging){const r=canvas.getBoundingClientRect();const sx=canvas.width/r.width,sy=canvas.height/r.height;const x=(e.offsetX||e.clientX-r.left)*sx,y=(e.offsetY||e.clientY-r.top)*sy;const id=String.fromCharCode(65+lines.length);lines.push({id,x1:startPoint.x,y1:startPoint.y,x2:x,y2:y,name:`è¾º${id}`,start:'wall',end:'wall'});drawLines();createInputs();}isDrawing=false;isDragging=false;}
        
        function savePattern(){const name=prompt('ãƒ‘ã‚¿ãƒ¼ãƒ³åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:');if(!name)return;const sp=JSON.parse(localStorage.getItem('savedPatterns')||'{}');sp[name]={lines,dimensions};localStorage.setItem('savedPatterns',JSON.stringify(sp));alert('ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä¿å­˜ã—ã¾ã—ãŸ');}
        
        function loadSavedPatterns(){
            const sp=JSON.parse(localStorage.getItem('savedPatterns')||'{}');const keys=Object.keys(sp);
            if(keys.length===0)return;
            document.getElementById('saved-patterns-section').style.display='block';
            const grid=document.getElementById('saved-patterns-grid');grid.innerHTML='';
            keys.forEach(name=>{const btn=document.createElement('button');btn.className='pattern-btn';btn.innerHTML=`${name}<span class="delete-btn" onclick="event.stopPropagation(); deletePattern('${name}')">Ã—</span>`;btn.onclick=()=>selectPattern(name);grid.appendChild(btn);});
        }
        
        function loadCustomPattern(name){const sp=JSON.parse(localStorage.getItem('savedPatterns')||'{}');const p=sp[name];if(!p)return;document.getElementById('pattern-title').textContent=name;lines=p.lines;dimensions=p.dimensions||{};drawLines();createInputs();}
        function deletePattern(name){if(!confirm(`ã€Œ${name}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`))return;const sp=JSON.parse(localStorage.getItem('savedPatterns')||'{}');delete sp[name];localStorage.setItem('savedPatterns',JSON.stringify(sp));loadSavedPatterns();}
        
        function undoLastLine(){
            if(lines.length===0)return;
            if(drawingPoints.length===0&&lines.length>0){drawingPoints=[];drawingPoints.push({x:lines[0].x1,y:lines[0].y1});for(let i=0;i<lines.length;i++)drawingPoints.push({x:lines[i].x2,y:lines[i].y2});canvas.removeEventListener('click',handlePointClick);canvas.removeEventListener('touchend',handlePointClickTouch);canvas.addEventListener('click',handleCanvasClick);canvas.addEventListener('mousemove',handleCanvasMouseMove);canvas.addEventListener('touchstart',handleTouchDrawing);canvas.addEventListener('touchmove',handleTouchDrawingMove);}
            const lid=lines[lines.length-1].id;lines.pop();delete dimensions[lid];
            if(drawingPoints.length>1)drawingPoints.pop();
            drawLines();createInputs();calculate();updateDrawingControls();
        }
        
        function clearDrawing(){
            if(lines.length>0&&!confirm('ã™ã¹ã¦ã®ä½œå›³ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã‹ï¼Ÿ'))return;
            lines=[];dimensions={};drawingPoints=[];corners={};commonWidth=null;
            ctx.clearRect(0,0,canvas.width,canvas.height);
            document.getElementById('dimension-inputs').innerHTML='';
            document.getElementById('results-content').innerHTML='<p style="color: #999; text-align: center;">å¯¸æ³•ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„</p>';
            updateDrawingControls();
            if(currentPattern==='custom'){canvas.removeEventListener('click',handlePointClick);canvas.removeEventListener('touchend',handlePointClickTouch);canvas.addEventListener('click',handleCanvasClick);canvas.addEventListener('mousemove',handleCanvasMouseMove);canvas.addEventListener('touchstart',handleTouchDrawing);canvas.addEventListener('touchmove',handleTouchDrawingMove);}
            else selectPattern(currentPattern);
        }
        
        function updateDrawingControls(){const c=document.getElementById('drawing-controls');if(c)c.style.display=(drawingPoints.length>0||currentPattern==='custom')?'flex':'none';}
        function backToSelect(){document.getElementById('pattern-select-screen').style.display='block';document.getElementById('measurement-screen').style.display='none';loadSavedPatterns();}
        
        function clearAll(){
            if(!confirm('ã™ã¹ã¦ã®ä½œå›³ã¨å…¥åŠ›å†…å®¹ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã‹ï¼Ÿ'))return;
            lines=[];dimensions={};drawingPoints=[];corners={};commonWidth=null;
            ctx.clearRect(0,0,canvas.width,canvas.height);
            document.getElementById('dimension-inputs').innerHTML='';
            document.getElementById('results-content').innerHTML='<p style="color: #999; text-align: center;">å¯¸æ³•ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„</p>';
            updateDrawingControls();
            if(currentPattern==='Iå­—')createIPattern();else if(currentPattern==='å·¦Lå­—')createLPatternLeft();else if(currentPattern==='å³Lå­—')createLPatternRight();else if(currentPattern==='ã‚³ã®å­—')createUPattern();else if(currentPattern==='custom')setupCustomDrawing();
        }
        
        function getFilename(){return `kutai-keisoku_${new Date().toISOString().slice(0,10)}`;}
        
        function generateResultsHTML(){
            let h='<div style="display: flex; flex-direction: column; gap: 6px;">';
            lines.forEach(line=>{
                const dim=dimensions[line.id];if(!dim||!dim.length)return;
                let result=dim.length;let formula='';const isDiag=isLineDiagonal(line);
                formula=`${isDiag?'èŠ¯å¯¸æ³•':'å¤–æ³•'} ${dim.length}mm`;
                if(line.start==='corner'){const w=getAdjacentLineWidth(line.id,'start');if(w>0){result-=w/2;formula+=` - èº¯ä½“å¹… ${w}mm Ã· 2`;}}
                if(line.end==='corner'){const w=getAdjacentLineWidth(line.id,'end');if(w>0){result-=w/2;formula+=` - èº¯ä½“å¹… ${w}mm Ã· 2`;}}
                const sl=getPointLabel(line.start),el=getPointLabel(line.end);
                h+=`<div style="padding: 6px 8px; background: white; border-radius: 4px;"><div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2px;"><span style="color: #374151; font-weight: 600; font-size: 11px;">${line.name} ${sl}â”${el}</span><strong style="color: #1e40af; font-size: 14px;">${Math.floor(result)} mm</strong></div><div style="color: #6b7280; font-size: 9px; line-height: 1.3;">(${formula} = ${Math.floor(result)}mm)</div></div>`;
            });
            h+='</div>';
            if(commonHeight){
                h+=`<div style="margin-top: 12px; padding: 8px; background: #f0f9ff; border-radius: 4px; border: 1px solid #bfdbfe;"><div style="color: #1e40af; font-weight: 600; font-size: 12px; margin-bottom: 4px;">ğŸ“ èº¯ä½“é«˜ã•: ${commonHeight}mm</div>`;
                if(commonHeight<=1100){const c1=1100-20-commonHeight,c2=1100-30-commonHeight;h+=`<div style="color: #6b7280; font-size: 9px; line-height: 1.5; margin-top: 4px;">1100 - 20 - ${commonHeight} = ${c1}mm<br>1100 - 30 - ${commonHeight} = ${c2}mm</div>`;}
                h+=`</div>`;
            }
            return h;
        }
        
        async function downloadAsPDF(){
            const rc=document.getElementById('results-content');if(!rc||!rc.innerHTML||rc.innerHTML.includes('å…¥åŠ›ãŒå®Œäº†ã—ã¦ã„ã¾ã›ã‚“')){alert('è¨ˆç®—çµæœãŒã‚ã‚Šã¾ã›ã‚“');return;}
            try{
                const sn=document.getElementById('site-name')?.value||'',sc=document.getElementById('sash-color')?.value||'';
                const rd=document.createElement('div');rd.style.cssText='width: 800px; padding: 30px; background: white; font-family: sans-serif;';
                rd.innerHTML=`<div style="text-align: center; margin-bottom: 20px; border-bottom: 3px solid #2563eb; padding-bottom: 15px;"><h1 style="font-size: 28px; color: #1e40af; margin: 0 0 10px 0;">èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ </h1>${sn||sc?`<h2 style="font-size: 18px; color: #374151; margin: 0 0 10px 0;">ğŸ“ ${sn}${sc?` ï¼ ğŸ¨ ${sc}`:''}</h2>`:''}<p style="font-size: 14px; color: #6b7280; margin: 0;">${new Date().toLocaleDateString('ja-JP',{year:'numeric',month:'long',day:'numeric'})}</p></div>`;
                const rcv=document.getElementById('result-canvas');
                if(rcv){const cd=document.createElement('div');cd.style.cssText='margin-bottom: 20px; padding: 20px; background: #f0f9ff; border-radius: 10px;';cd.innerHTML='<h3 style="font-size: 18px; color: #1e40af; margin: 0 0 15px 0;">ğŸ“ æ¸¬å®šå›³</h3>';const ci=document.createElement('img');ci.src=rcv.toDataURL('image/png');ci.style.cssText='width: 100%; height: auto; display: block;';cd.appendChild(ci);rd.appendChild(cd);}
                const rsd=document.createElement('div');rsd.style.cssText='padding: 12px; background: #fef3c7; border-radius: 10px; border: 2px solid #f59e0b;';rsd.innerHTML='<h3 style="font-size: 18px; color: #92400e; margin: 0 0 15px 0;">ğŸ“Š è¨ˆç®—çµæœ</h3>'+generateResultsHTML();rd.appendChild(rsd);
                document.body.appendChild(rd);const cv=await html2canvas(rd,{scale:2,backgroundColor:'#ffffff',logging:false});document.body.removeChild(rd);
                const{jsPDF}=window.jspdf;const pdf=new jsPDF({orientation:'portrait',unit:'mm',format:'a4'});
                const id=cv.toDataURL('image/png');const pw=210,ph=297,m=10,iw=pw-m*2,ih=(cv.height*iw)/cv.width;
                pdf.addImage(id,'PNG',m,m,iw,Math.min(ih,ph-m*2));
                pdf.save((sn?sn+'_':'')+getFilename()+'.pdf');
            }catch(e){console.error('PDFä¿å­˜ã‚¨ãƒ©ãƒ¼:',e);alert('PDFã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: '+e.message);}
        }
        
        async function downloadAsPNG(){
            const rc=document.getElementById('results-content');if(!rc||!rc.innerHTML||rc.innerHTML.includes('å…¥åŠ›ãŒå®Œäº†ã—ã¦ã„ã¾ã›ã‚“')){alert('è¨ˆç®—çµæœãŒã‚ã‚Šã¾ã›ã‚“');return;}
            try{
                const sn=document.getElementById('site-name')?.value||'',sc=document.getElementById('sash-color')?.value||'';
                const rd=document.createElement('div');rd.style.cssText='width: 800px; padding: 30px; background: white; font-family: sans-serif;';
                rd.innerHTML=`<div style="text-align: center; margin-bottom: 20px; border-bottom: 3px solid #2563eb; padding-bottom: 15px;"><h1 style="font-size: 28px; color: #1e40af; margin: 0 0 10px 0;">èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ </h1>${sn||sc?`<h2 style="font-size: 18px; color: #374151; margin: 0 0 10px 0;">ğŸ“ ${sn}${sc?` ï¼ ğŸ¨ ${sc}`:''}</h2>`:''}<p style="font-size: 14px; color: #6b7280; margin: 0;">${new Date().toLocaleDateString('ja-JP',{year:'numeric',month:'long',day:'numeric'})}</p></div>`;
                const rcv=document.getElementById('result-canvas');
                if(rcv){const cd=document.createElement('div');cd.style.cssText='margin-bottom: 20px; padding: 20px; background: #f0f9ff; border-radius: 10px;';cd.innerHTML='<h3 style="font-size: 18px; color: #1e40af; margin: 0 0 15px 0;">ğŸ“ æ¸¬å®šå›³</h3>';const ci=document.createElement('img');ci.src=rcv.toDataURL('image/png');ci.style.cssText='width: 100%; height: auto; display: block;';cd.appendChild(ci);rd.appendChild(cd);}
                const rsd=document.createElement('div');rsd.style.cssText='padding: 12px; background: #fef3c7; border-radius: 10px; border: 2px solid #f59e0b;';rsd.innerHTML='<h3 style="font-size: 18px; color: #92400e; margin: 0 0 15px 0;">ğŸ“Š è¨ˆç®—çµæœ</h3>'+generateResultsHTML();rd.appendChild(rsd);
                document.body.appendChild(rd);const cv=await html2canvas(rd,{scale:2,backgroundColor:'#ffffff',logging:false});document.body.removeChild(rd);
                const id=cv.toDataURL('image/png');const lk=document.createElement('a');lk.download=(sn?sn+'_':'')+getFilename()+'.png';lk.href=id;lk.click();
            }catch(e){console.error('PNGä¿å­˜ã‚¨ãƒ©ãƒ¼:',e);alert('ç”»åƒã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: '+e.message);}
        }
        
        async function shareResult(){
            const rc=document.getElementById('results-content');if(!rc||!rc.innerHTML||rc.innerHTML.includes('å…¥åŠ›ãŒå®Œäº†ã—ã¦ã„ã¾ã›ã‚“')){alert('è¨ˆç®—çµæœãŒã‚ã‚Šã¾ã›ã‚“');return;}
            if(!navigator.share&&!navigator.canShare){alert('ã“ã®ç«¯æœ«ã§ã¯å…±æœ‰æ©Ÿèƒ½ãŒä½¿ãˆã¾ã›ã‚“ã€‚ç”»åƒã¨ã—ã¦ä¿å­˜ã—ã¾ã™ã€‚');await downloadAsPNG();return;}
            try{
                const sn=document.getElementById('site-name')?.value||'',sc=document.getElementById('sash-color')?.value||'';
                const rd=document.createElement('div');rd.style.cssText='width: 800px; padding: 30px; background: white; font-family: sans-serif;';
                rd.innerHTML=`<div style="text-align: center; margin-bottom: 20px; border-bottom: 3px solid #2563eb; padding-bottom: 15px;"><h1 style="font-size: 28px; color: #1e40af; margin: 0 0 10px 0;">èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ </h1>${sn||sc?`<h2 style="font-size: 18px; color: #374151; margin: 0 0 10px 0;">ğŸ“ ${sn}${sc?` ï¼ ğŸ¨ ${sc}`:''}</h2>`:''}<p style="font-size: 14px; color: #6b7280; margin: 0;">${new Date().toLocaleDateString('ja-JP',{year:'numeric',month:'long',day:'numeric'})}</p></div>`;
                const rcv=document.getElementById('result-canvas');
                if(rcv){const cd=document.createElement('div');cd.style.cssText='margin-bottom: 20px; padding: 20px; background: #f0f9ff; border-radius: 10px;';cd.innerHTML='<h3 style="font-size: 18px; color: #1e40af; margin: 0 0 15px 0;">ğŸ“ æ¸¬å®šå›³</h3>';const ci=document.createElement('img');ci.src=rcv.toDataURL('image/png');ci.style.cssText='width: 100%; height: auto; display: block;';cd.appendChild(ci);rd.appendChild(cd);}
                const rsd=document.createElement('div');rsd.style.cssText='padding: 12px; background: #fef3c7; border-radius: 10px; border: 2px solid #f59e0b;';rsd.innerHTML='<h3 style="font-size: 18px; color: #92400e; margin: 0 0 15px 0;">ğŸ“Š è¨ˆç®—çµæœ</h3>'+generateResultsHTML();rd.appendChild(rsd);
                document.body.appendChild(rd);const cv=await html2canvas(rd,{scale:2,backgroundColor:'#ffffff',logging:false,useCORS:true});document.body.removeChild(rd);
                cv.toBlob(async(blob)=>{
                    if(!blob){throw new Error('ç”»åƒã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ');}
                    try{
                        const fn=(sn?sn+'_':'')+getFilename()+'.png';const file=new File([blob],fn,{type:'image/png'});
                        const sd={title:'èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ '+(sn?` - ${sn}`:''),text:'èº¯ä½“æ¡å¯¸ã®è¨ˆç®—çµæœã§ã™',files:[file]};
                        if(navigator.canShare&&!navigator.canShare(sd)){await navigator.share({title:sd.title,text:sd.text,url:window.location.href});}else{await navigator.share(sd);}
                    }catch(se){if(se.name==='AbortError')return;console.error('å…±æœ‰ã‚¨ãƒ©ãƒ¼:',se);alert('å…±æœ‰ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ç”»åƒã¨ã—ã¦ä¿å­˜ã—ã¾ã™ã€‚');await downloadAsPNG();}
                },'image/png');
            }catch(e){console.error('å…±æœ‰ã‚¨ãƒ©ãƒ¼:',e);alert('å…±æœ‰ã®æº–å‚™ã«å¤±æ•—ã—ã¾ã—ãŸ: '+e.message+'\nç”»åƒã¨ã—ã¦ä¿å­˜ã—ã¾ã™ã€‚');await downloadAsPNG();}
        }
        
        function openManual(){document.getElementById('manual-modal').style.display='block';document.body.style.overflow='hidden';}
        function closeManual(){document.getElementById('manual-modal').style.display='none';document.body.style.overflow='auto';}
        window.onclick=function(event){if(event.target===document.getElementById('manual-modal'))closeManual();}
    </script>
</body>
</html>
