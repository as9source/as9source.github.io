<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ </title>
    <!--
    ========================================
    èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ 
    ========================================
    ãƒãƒ¼ã‚¸ãƒ§ãƒ³: 1.6.0
    æœ€çµ‚æ›´æ–°: 2024-12-27
    
    [æ›´æ–°å±¥æ­´]
    v1.6.0 (2024-12-27)
    - PDFä¿å­˜æ©Ÿèƒ½è¿½åŠ ï¼ˆGoodNotesã€Notionã€ã‚¯ãƒ©ã‚¦ãƒ‰ã«ä¿å­˜å¯èƒ½ï¼‰
    - PNGç”»åƒä¿å­˜æ©Ÿèƒ½è¿½åŠ 
    - å…±æœ‰æ©Ÿèƒ½è¿½åŠ ï¼ˆiPhoneã®å…±æœ‰ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‹ã‚‰ç›´æ¥å…±æœ‰ï¼‰
    - è¨ˆç®—çµæœã®å›³ã‚’ç°¡å˜ã«ä¿å­˜ãƒ»å…±æœ‰ã§ãã‚‹ã‚ˆã†ã«æ”¹å–„
    
    v1.5.2 (2024-12-26) - å®Œæˆç‰ˆ
    - è¨ˆç®—çµæœã®å°æ•°ç‚¹ä»¥ä¸‹ã‚’åˆ‡ã‚Šæ¨ã¦ã«å¤‰æ›´
    - ã™ã¹ã¦ã®æ©Ÿèƒ½ãŒå®Œæˆ
    
    v1.5.1 (2024-12-26)
    - ä½œå›³çµ‚äº†å¾Œã®æˆ»ã‚‹ãƒœã‚¿ãƒ³ã§ä½œå›³å†é–‹ã§ãã‚‹æ©Ÿèƒ½ã‚’ä¿®æ­£
    - ä½œå›³ç”¨ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’æ­£ã—ãå†è¨­å®š
    - è¨ˆç®—çµæœã®èº¯ä½“å¹…è¡¨ç¤ºã«èƒŒæ™¯ã‚’è¿½åŠ ï¼ˆé‡ãªã‚Šé˜²æ­¢ï¼‰
    
    v1.5.0 (2024-12-26)
    - ä½œå›³å¾Œã€ç‚¹ãƒ»ç·šã‚¯ãƒªãƒƒã‚¯ã§å…¥åŠ›æ¬„ã«ç§»å‹•ï¼ˆçŠ¶æ…‹å¤‰æ›´ãªã—ï¼‰
    - ç·šã‚¯ãƒªãƒƒã‚¯æ©Ÿèƒ½è¿½åŠ ï¼ˆç‚¹ã‹ã‚‰ç·šåˆ†ã¸ã®è·é›¢è¨ˆç®—ï¼‰
    - è¨ˆç®—çµæœã®å›³ï¼šæœ€å°è¡¨ç¤ºé•·ã•200pxã€ãƒ†ã‚­ã‚¹ãƒˆã‚’ç·šã®å¤–å´ã«é…ç½®
    - ãƒ†ã‚­ã‚¹ãƒˆã®é‡ãªã‚Šã‚’å®Œå…¨ã«é˜²æ­¢ï¼ˆå‚ç›´æ–¹å‘40pxã‚ªãƒ•ã‚»ãƒƒãƒˆï¼‰
    
    v1.4.0 (2024-12-26)
    - è¨ˆç®—çµæœã®å›³ã®æœ€å°è¡¨ç¤ºé•·ã•ã‚’150pxã«å¢—åŠ ï¼ˆæ•°å­—ã®é‡ãªã‚Šã‚’é˜²æ­¢ï¼‰
    - ä½œå›³çµ‚äº†å¾Œã«ç‚¹ã‚¯ãƒªãƒƒã‚¯ã§çŠ¶æ…‹å¤‰æ›´ã§ãã‚‹æ©Ÿèƒ½ã‚’ä¿®æ­£
    - å§‹ç‚¹ã‚¯ãƒªãƒƒã‚¯ã§å›³å½¢ã‚’é–‰ã˜ã‚‹æ©Ÿèƒ½ã‚’ä¿®æ­£ï¼ˆã‚¹ãƒŠãƒƒãƒ—å‡¦ç†å¾Œã«åˆ¤å®šï¼‰
    - PC: 30pxä»¥å†…ã€ã‚¿ãƒƒãƒ: 40pxä»¥å†…ã§å§‹ç‚¹ã¨ã—ã¦èªè­˜
    
    v1.3.1 (2024-12-26)
    - è¨ˆç®—çµæœã®å›³ã§ã‚³ãƒ¼ãƒŠãƒ¼ç‚¹ãŒè¡¨ç¤ºã•ã‚Œãªã„å•é¡Œã‚’ä¿®æ­£
    - ç‚¹ã‚¯ãƒªãƒƒã‚¯æ™‚ã®å…¥åŠ›æ¬„ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æ©Ÿèƒ½ã‚’ä¿®æ­£ï¼ˆDOMã®æ›´æ–°ã‚’å¾…ã¤ï¼‰
    - å§‹ç‚¹ã‚’ç›´æ¥ã‚¯ãƒªãƒƒã‚¯ã—ã¦å›³å½¢ã‚’é–‰ã˜ã‚‹æ©Ÿèƒ½ã‚’ä¿®æ­£
    
    v1.3.0 (2024-12-26)
    - ç‚¹ã‚¯ãƒªãƒƒã‚¯ã§å…¥åŠ›æ¬„ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«&ãƒã‚¤ãƒ©ã‚¤ãƒˆæ©Ÿèƒ½è¿½åŠ 
    - è¨ˆç®—çµæœã®å›³ã‚’å®Ÿå¯¸æ³•æ¯”ç‡ã§è¡¨ç¤ºï¼ˆè¦‹ã‚„ã™ã•å„ªå…ˆï¼‰
    - æœ€å°è¡¨ç¤ºé•·ã•80pxã§å¯¸æ³•ã®è¦–èªæ€§ã‚’ç¢ºä¿
    
    v1.2.0 (2024-12-26)
    - å§‹ç‚¹ã®å¼·èª¿è¡¨ç¤ºã‚µã‚¤ã‚ºã‚’èª¿æ•´
    - å§‹ç‚¹ã‚’ç›´æ¥ã‚¯ãƒªãƒƒã‚¯/ã‚¿ãƒƒãƒ—ã§å›³å½¢ã‚’é–‰ã˜ã‚‹æ©Ÿèƒ½è¿½åŠ 
    - ä½œå›³çµ‚äº†å¾Œã«æˆ»ã‚‹ãƒœã‚¿ãƒ³ã§ä½œå›³ã‚’å†é–‹ã§ãã‚‹æ©Ÿèƒ½è¿½åŠ 
    - ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠã«æˆ»ã‚‹ãƒœã‚¿ãƒ³ã‚’å¸¸ã«æœ‰åŠ¹åŒ–
    
    v1.1.0 (2024-12-26)
    - ã‚¹ãƒãƒ¼ãƒˆã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³è¿½åŠ ï¼ˆã‚¤ãƒ©ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼é¢¨ï¼‰
    - å§‹ç‚¹ã«å‘ã‹ã†ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³è¡¨ç¤º
    - ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³åˆè‡´æ™‚ã«å§‹ç‚¹ã‚’å¼·èª¿è¡¨ç¤º
    - æ®µå·®å¯¸æ³•ã®å…¥åŠ›ãƒã‚§ãƒƒã‚¯è¿½åŠ 
    
    v1.0.0 (2024-12-26)
    - åˆå›ãƒªãƒªãƒ¼ã‚¹
    - Iå­—å‹ã€Lå­—å‹ã€ã‚³ã®å­—å‹ã€è‡ªç”±ä½œå›³å¯¾å¿œ
    - æ®µå·®æ©Ÿèƒ½ã€ã‚³ãƒ¼ãƒŠãƒ¼è¨ˆç®—æ©Ÿèƒ½
    - å››è§’å½¢ã®é–‰ã˜ãŸå›³å½¢å¯¾å¿œ
    ========================================
    -->
    <!-- jsPDF ãƒ©ã‚¤ãƒ–ãƒ©ãƒªï¼ˆPDFä¿å­˜ç”¨ï¼‰ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, 'Hiragino Kaku Gothic ProN', sans-serif;
            background: #f5f7fa;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 700px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            padding: 40px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }
        
        h1 {
            text-align: center;
            color: #1a1a1a;
            margin-bottom: 40px;
            font-size: 28px;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        
        h2 {
            color: #1a1a1a;
            margin: 30px 0 20px;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            opacity: 0.6;
        }
        
        /* ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠç”»é¢ */
        .pattern-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }
        
        .pattern-btn {
            background: white;
            color: #1a1a1a;
            border: 2px solid #e5e7eb;
            padding: 24px 16px;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            min-height: 110px;
        }
        
        .pattern-btn svg {
            width: 50px;
            height: 50px;
        }
        
        .pattern-btn:hover {
            border-color: #3b82f6;
            background: #f0f9ff;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.15);
        }
        
        .pattern-btn:active {
            transform: translateY(0);
        }
        
        .pattern-btn.custom {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
            grid-column: 1 / -1;
        }
        
        .pattern-btn.custom:hover {
            background: #2563eb;
            border-color: #2563eb;
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.25);
        }
        
        .pattern-btn .delete-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .pattern-btn .delete-btn:hover {
            background: #dc2626;
            transform: scale(1.1);
        }
        
        /* æ¡å¯¸ç”»é¢ */
        .measurement-screen {
            display: none;
        }
        
        .back-btn {
            background: #f3f4f6;
            color: #1a1a1a;
            border: 1px solid #e5e7eb;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 20px;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        
        .back-btn:hover {
            background: #e5e7eb;
            border-color: #d1d5db;
        }
        
        .drawing-area {
            position: relative;
            width: 100%;
            height: 400px;
            background: #f9fafb;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            margin: 20px 0;
            overflow: hidden;
            touch-action: none;
        }
        
        canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }
        
        .dimension-inputs {
            margin: 20px 0;
        }
        
        .dimension-item {
            background: #f9fafb;
            padding: 16px;
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            margin-bottom: 12px;
        }
        
        .dimension-item label {
            display: block;
            color: #1a1a1a;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .dimension-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .dimension-row input {
            padding: 10px 12px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            font-size: 15px;
            transition: all 0.2s ease;
        }
        
        .dimension-row input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        .results {
            background: #f9fafb;
            padding: 20px;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            margin-top: 20px;
        }
        
        .result-item {
            padding: 12px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .result-label {
            color: #555;
            font-weight: bold;
        }
        
        .result-value {
            color: #667eea;
            font-weight: bold;
            font-size: 18px;
        }
        
        .save-pattern-btn {
            width: 100%;
            background: #10b981;
            color: white;
            border: none;
            padding: 14px;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.2s ease;
        }
        
        .save-pattern-btn:hover {
            background: #059669;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.25);
        }
        
        .alert {
            background: #fff3cd;
            color: #856404;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #ffc107;
        }
        
        .success {
            background: #d4edda;
            color: #155724;
            border-left-color: #28a745;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠç”»é¢ -->
        <div id="pattern-select-screen">
            <h1>èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ </h1>
            
            <h2>åŸºæœ¬ãƒ‘ã‚¿ãƒ¼ãƒ³</h2>
            <div class="pattern-grid">
                <button class="pattern-btn" onclick="selectPattern('i')">
                    <svg viewBox="0 0 60 60">
                        <line x1="10" y1="30" x2="50" y2="30" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                    </svg>
                    Iå­—
                </button>
                <button class="pattern-btn" onclick="selectPattern('l-left')">
                    <svg viewBox="0 0 60 60">
                        <line x1="15" y1="10" x2="15" y2="50" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                        <line x1="15" y1="10" x2="45" y2="10" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                    </svg>
                    å·¦Lå­—
                </button>
                <button class="pattern-btn" onclick="selectPattern('l-right')">
                    <svg viewBox="0 0 60 60">
                        <line x1="45" y1="10" x2="45" y2="50" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                        <line x1="15" y1="10" x2="45" y2="10" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                    </svg>
                    å³Lå­—
                </button>
                <button class="pattern-btn" onclick="selectPattern('u')">
                    <svg viewBox="0 0 60 60">
                        <line x1="15" y1="50" x2="15" y2="10" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                        <line x1="15" y1="10" x2="45" y2="10" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                        <line x1="45" y1="10" x2="45" y2="50" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
                    </svg>
                    ã‚³ã®å­—
                </button>
            </div>
            
            <div id="saved-patterns-section" style="display: none;">
                <h2>ä¿å­˜æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³</h2>
                <div class="pattern-grid" id="saved-patterns-grid"></div>
            </div>
            
            <h2>ã‚«ã‚¹ã‚¿ãƒ ä½œå›³</h2>
            <div class="pattern-grid">
                <button class="pattern-btn custom" onclick="selectPattern('custom')">è‡ªç”±ã«ç·šã‚’å¼•ã</button>
            </div>
            
            <!-- ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ± -->
            <div style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #e5e7eb; text-align: center; color: #6b7280; font-size: 13px;">
                <div style="margin-bottom: 5px;">èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ  v1.6.0</div>
                <div>æœ€çµ‚æ›´æ–°: 2024-12-27</div>
            </div>
        </div>
        
        <!-- æ¡å¯¸ç”»é¢ -->
        <div id="measurement-screen" class="measurement-screen">
            <button id="back-btn" class="back-btn" onclick="backToSelect()">â† ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠã«æˆ»ã‚‹</button>
            
            <h1 id="pattern-title">æ¡å¯¸å…¥åŠ›</h1>
            
            <div id="alert" class="alert" style="display: none;"></div>
            
            <div class="drawing-area">
                <canvas id="canvas"></canvas>
            </div>
            
            <div id="drawing-controls" style="display: none; margin-top: 10px; display: flex; gap: 10px;">
                <button onclick="undoLastLine()" style="flex: 1; padding: 12px; background: #f59e0b; color: white; border: none; border-radius: 8px; font-size: 15px; font-weight: 600; cursor: pointer; transition: all 0.2s ease;">â†¶ æˆ»ã‚‹</button>
                <button onclick="finishDrawing()" style="flex: 1; padding: 12px; background: #10b981; color: white; border: none; border-radius: 8px; font-size: 15px; font-weight: 600; cursor: pointer; transition: all 0.2s ease;">âœ“ ä½œå›³çµ‚äº†</button>
            </div>
            
            <div class="dimension-inputs" id="dimension-inputs"></div>
            
            <div class="results">
                <h2>è¨ˆç®—çµæœ</h2>
                <div id="results-content">
                    <p style="color: #999; text-align: center;">å¯¸æ³•ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„</p>
                </div>
            </div>
            
            <button class="save-pattern-btn" onclick="savePattern()">ã“ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä¿å­˜</button>
        </div>
    </div>
    
    <script>
        let currentPattern = null;
        let lines = [];
        let dimensions = {};
        let isDrawing = false;
        let isDragging = false;
        let startPoint = null;
        let canvas, ctx;
        let drawingPoints = [];
        let lastClickTime = 0;
        let lastTapTime = 0;
        let commonWidth = null; // èº¯ä½“å¹…
        let useIndividualWidth = false; // å€‹åˆ¥è¨­å®šãƒ•ãƒ©ã‚°
        let commonHeight = null; // èº¯ä½“é«˜ã•
        let corners = {}; // ã‚³ãƒ¼ãƒŠãƒ¼æƒ…å ± { 'x,y': { hasStep: bool, depth: number, lines: [...] } }
        
        // ã‚³ãƒ¼ãƒŠãƒ¼ã‚’æ¤œå‡º
        function detectCorners() {
            if (!corners) {
                corners = {};
            }
            
            if (!lines || lines.length === 0) {
                corners = {};
                return;
            }
            
            const newCorners = {};
            const tolerance = 5; // åŒã˜ç‚¹ã¨ã¿ãªã™è¨±å®¹ç¯„å›²
            
            lines.forEach((line, idx) => {
                if (!line) return;
                
                // å§‹ç‚¹
                const startKey = findCornerKeyForDetection(line.x1, line.y1, tolerance, newCorners);
                if (!newCorners[startKey]) {
                    // æ—¢å­˜ã®ã‚³ãƒ¼ãƒŠãƒ¼æƒ…å ±ã‚’ä¿æŒ
                    const oldCorner = corners[startKey];
                    newCorners[startKey] = { 
                        x: line.x1, 
                        y: line.y1, 
                        hasStep: oldCorner ? oldCorner.hasStep : false, 
                        depth: oldCorner ? oldCorner.depth : null, 
                        lines: [] 
                    };
                }
                newCorners[startKey].lines.push({ lineId: line.id, point: 'start' });
                
                // çµ‚ç‚¹
                const endKey = findCornerKeyForDetection(line.x2, line.y2, tolerance, newCorners);
                if (!newCorners[endKey]) {
                    // æ—¢å­˜ã®ã‚³ãƒ¼ãƒŠãƒ¼æƒ…å ±ã‚’ä¿æŒ
                    const oldCorner = corners[endKey];
                    newCorners[endKey] = { 
                        x: line.x2, 
                        y: line.y2, 
                        hasStep: oldCorner ? oldCorner.hasStep : false, 
                        depth: oldCorner ? oldCorner.depth : null, 
                        lines: [] 
                    };
                }
                newCorners[endKey].lines.push({ lineId: line.id, point: 'end' });
            });
            
            corners = newCorners;
        }
        
        // ã‚³ãƒ¼ãƒŠãƒ¼ã‚­ãƒ¼ã‚’æ¤œç´¢ï¼ˆæ¤œå‡ºç”¨ - æ–°ã—ã„cornersã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‚ç…§ï¼‰
        function findCornerKeyForDetection(x, y, tolerance, cornersObj) {
            for (const key in cornersObj) {
                const corner = cornersObj[key];
                const dist = Math.sqrt(Math.pow(x - corner.x, 2) + Math.pow(y - corner.y, 2));
                if (dist < tolerance) {
                    return key;
                }
            }
            // æ–°ã—ã„ã‚­ãƒ¼ã‚’ç”Ÿæˆ
            return `${Math.round(x)},${Math.round(y)}`;
        }
        
        // ã‚³ãƒ¼ãƒŠãƒ¼ã‚­ãƒ¼ã‚’æ¤œç´¢ï¼ˆæ—¢å­˜ã®cornersã‹ã‚‰æ¤œç´¢ï¼‰
        function findCornerKey(x, y, tolerance) {
            if (!corners) return `${Math.round(x)},${Math.round(y)}`;
            
            for (const key in corners) {
                const corner = corners[key];
                const dist = Math.sqrt(Math.pow(x - corner.x, 2) + Math.pow(y - corner.y, 2));
                if (dist < tolerance) {
                    return key;
                }
            }
            // æ–°ã—ã„ã‚­ãƒ¼ã‚’ç”Ÿæˆ
            return `${Math.round(x)},${Math.round(y)}`;
        }
        
        
        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚
        window.onload = function() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            resizeCanvas();
            
            loadSavedPatterns();
        };
        
        // Canvas ãƒªã‚µã‚¤ã‚º
        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            if (lines.length > 0) {
                drawLines();
            }
        }
        
        // ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠ
        function selectPattern(type) {
            currentPattern = type;
            document.getElementById('pattern-select-screen').style.display = 'none';
            document.getElementById('measurement-screen').style.display = 'block';
            
            // Canvasã‚’ãƒªã‚µã‚¤ã‚º
            setTimeout(resizeCanvas, 100);
            
            lines = [];
            dimensions = {};
            drawingPoints = [];
            commonWidth = null;
            commonHeight = null;
            useIndividualWidth = false;
            
            if (type === 'i') {
                document.getElementById('pattern-title').textContent = 'Iå­—å‹ æ¡å¯¸';
                createIPattern();
            } else if (type === 'l-left') {
                document.getElementById('pattern-title').textContent = 'å·¦Lå­—å‹ æ¡å¯¸';
                createLPatternLeft();
            } else if (type === 'l-right') {
                document.getElementById('pattern-title').textContent = 'å³Lå­—å‹ æ¡å¯¸';
                createLPatternRight();
            } else if (type === 'u') {
                document.getElementById('pattern-title').textContent = 'ã‚³ã®å­—å‹ æ¡å¯¸';
                createUPattern();
            } else if (type === 'custom') {
                document.getElementById('pattern-title').textContent = 'è‡ªç”±ä½œå›³';
                setupCustomDrawing();
            } else {
                // ä¿å­˜æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³ã®èª­ã¿è¾¼ã¿
                loadCustomPattern(type);
            }
        }
        
        // Iå­—ãƒ‘ã‚¿ãƒ¼ãƒ³
        function createIPattern() {
            lines = [
                { 
                    id: 'A', 
                    x1: 100, y1: 200, 
                    x2: 400, y2: 200, 
                    name: 'è¾ºA', 
                    start: 'wall', // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯å£
                    end: 'wall'
                }
            ];
            drawLines();
            createInputs();
            setupPointClickListener();
        }
        
        // å·¦Lå­—ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆâ”Œå‹ï¼‰
        function createLPatternLeft() {
            lines = [
                { 
                    id: 'A', 
                    x1: 150, y1: 100, 
                    x2: 150, y2: 320, 
                    name: 'è¾ºAï¼ˆç¸¦ï¼‰', 
                    start: 'wall',  // æœ€åˆã®ç·šã®å§‹ç‚¹ã¯å£
                    end: 'wall'  // ã‚¨ãƒ³ãƒ‰ã¯å£
                },
                { 
                    id: 'B', 
                    x1: 150, y1: 100, 
                    x2: 400, y2: 100, 
                    name: 'è¾ºBï¼ˆæ¨ªï¼‰', 
                    start: 'corner',
                    end: 'wall'  // ã‚¨ãƒ³ãƒ‰ã¯å£
                }
            ];
            drawLines();
            createInputs();
            setupPointClickListener();
        }
        
        // å³Lå­—ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆâ”å‹ï¼‰
        function createLPatternRight() {
            lines = [
                { 
                    id: 'A', 
                    x1: 100, y1: 100, 
                    x2: 350, y2: 100, 
                    name: 'è¾ºAï¼ˆæ¨ªï¼‰', 
                    start: 'wall',  // ã‚¨ãƒ³ãƒ‰ã¯å£
                    end: 'corner'
                },
                { 
                    id: 'B', 
                    x1: 350, y1: 100, 
                    x2: 350, y2: 320, 
                    name: 'è¾ºBï¼ˆç¸¦ï¼‰', 
                    start: 'corner',
                    end: 'wall'  // ã‚¨ãƒ³ãƒ‰ã¯å£
                }
            ];
            drawLines();
            createInputs();
            setupPointClickListener();
        }
        
        // ã‚³ã®å­—ãƒ‘ã‚¿ãƒ¼ãƒ³
        function createUPattern() {
            lines = [
                { 
                    id: 'A', 
                    x1: 120, y1: 320, 
                    x2: 120, y2: 100, 
                    name: 'è¾ºA', 
                    start: 'wall',  // ã‚¨ãƒ³ãƒ‰ã¯å£
                    end: 'corner'
                },
                { 
                    id: 'B', 
                    x1: 120, y1: 100, 
                    x2: 380, y2: 100, 
                    name: 'è¾ºB', 
                    start: 'corner',
                    end: 'corner'
                },
                { 
                    id: 'C', 
                    x1: 380, y1: 100, 
                    x2: 380, y2: 320, 
                    name: 'è¾ºC', 
                    start: 'corner',
                    end: 'wall'  // ã‚¨ãƒ³ãƒ‰ã¯å£
                }
            ];
            drawLines();
            createInputs();
            setupPointClickListener();
        }
        
        // ç‚¹ã‚¯ãƒªãƒƒã‚¯ãƒªã‚¹ãƒŠãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        function setupPointClickListener() {
            // æ—¢å­˜ã®ãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤ï¼ˆé‡è¤‡é˜²æ­¢ï¼‰
            canvas.removeEventListener('click', handlePointClick);
            canvas.removeEventListener('touchend', handlePointClickTouch);
            
            // æ–°ã—ã„ãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
            canvas.addEventListener('click', handlePointClick);
            canvas.addEventListener('touchend', handlePointClickTouch);
        }
        
        // ã‚¿ãƒƒãƒã§ç‚¹ã®çŠ¶æ…‹ã‚’åˆ‡ã‚Šæ›¿ãˆ
        function handlePointClickTouch(e) {
            if (isDrawing || isDragging) return;
            if (drawingPoints.length > 0) return;
            
            e.preventDefault();
            const touch = e.changedTouches[0];
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (touch.clientX - rect.left) * scaleX;
            const y = (touch.clientY - rect.top) * scaleY;
            
            const clickRadius = 25;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                const distStart = Math.sqrt(Math.pow(x - line.x1, 2) + Math.pow(y - line.y1, 2));
                if (distStart < clickRadius) {
                    // å…¥åŠ›æ¬„ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«&ãƒã‚¤ãƒ©ã‚¤ãƒˆã®ã¿ï¼ˆçŠ¶æ…‹å¤‰æ›´ã—ãªã„ï¼‰
                    scrollToInput(line.id);
                    return;
                }
                
                const distEnd = Math.sqrt(Math.pow(x - line.x2, 2) + Math.pow(y - line.y2, 2));
                if (distEnd < clickRadius) {
                    // å…¥åŠ›æ¬„ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«&ãƒã‚¤ãƒ©ã‚¤ãƒˆã®ã¿ï¼ˆçŠ¶æ…‹å¤‰æ›´ã—ãªã„ï¼‰
                    scrollToInput(line.id);
                    return;
                }
                
                // ç·šã‚’ã‚¿ãƒƒãƒ—ã—ãŸã‹ãƒã‚§ãƒƒã‚¯
                const distToLine = distanceToLineSegment(x, y, line.x1, line.y1, line.x2, line.y2);
                if (distToLine < 15) {
                    // å…¥åŠ›æ¬„ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«&ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                    scrollToInput(line.id);
                    return;
                }
            }
        }
        
        // ç·šã‚’æç”»
        function drawLines() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ã‚³ãƒ¼ãƒŠãƒ¼ã‚’æ¤œå‡º
            detectCorners();
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 5;
            ctx.lineCap = 'round';
            
            // ç·šã‚’æç”»
            lines.forEach((line, index) => {
                ctx.beginPath();
                ctx.moveTo(line.x1, line.y1);
                ctx.lineTo(line.x2, line.y2);
                ctx.stroke();
                
                // ãƒ©ãƒ™ãƒ«ä½ç½®è¨ˆç®—
                const midX = (line.x1 + line.x2) / 2;
                const midY = (line.y1 + line.y2) / 2;
                
                // å…¥åŠ›ã•ã‚ŒãŸå¤–æ³•å¯¸æ³•ã‚’è¡¨ç¤º
                const dim = dimensions[line.id];
                if (dim && dim.length) {
                    ctx.font = 'bold 18px sans-serif';
                    ctx.fillStyle = '#3b82f6';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // èƒŒæ™¯ã‚’ç™½ã
                    const text = `${dim.length}`;
                    const metrics = ctx.measureText(text);
                    const padding = 8;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.fillRect(midX - metrics.width/2 - padding, midY - 12, metrics.width + padding*2, 24);
                    
                    // æ–‡å­—ã‚’æç”»
                    ctx.fillStyle = '#3b82f6';
                    ctx.fillText(text, midX, midY);
                }
                
                // è¾ºåãƒ©ãƒ™ãƒ«
                ctx.font = 'bold 13px sans-serif';
                const textWidth = ctx.measureText(line.name).width;
                const padding = 8;
                const bgWidth = textWidth + padding * 2;
                const bgHeight = 20;
                
                // èƒŒæ™¯
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.fillRect(midX - bgWidth/2, midY - bgHeight/2 - 35, bgWidth, bgHeight);
                
                // æ–‡å­—
                ctx.fillStyle = '#333';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(line.name, midX, midY - 35);
            });
            
            // æ—¢ã«æç”»ã—ãŸã‚³ãƒ¼ãƒŠãƒ¼ã‚’è¨˜éŒ²
            const drawnCorners = new Set();
            
            // ã‚³ãƒ¼ãƒŠãƒ¼ãƒ™ãƒ¼ã‚¹ã§ç‚¹ã‚’æç”»
            if (corners) {
                for (const cornerKey in corners) {
                    const corner = corners[cornerKey];
                    
                    if (!corner || drawnCorners.has(cornerKey)) continue;
                    drawnCorners.add(cornerKey);
                    
                    // ã“ã®ã‚³ãƒ¼ãƒŠãƒ¼ã«æ¥ç¶šã—ã¦ã„ã‚‹è¾ºã‚’å–å¾—
                    if (!corner.lines || corner.lines.length === 0) continue;
                    
                    // ã‚³ãƒ¼ãƒŠãƒ¼ã®åº§æ¨™ã‚’å–å¾—
                    const firstLineRef = corner.lines[0];
                    const firstLine = lines.find(l => l.id === firstLineRef.lineId);
                    if (!firstLine) continue;
                    
                    const cornerX = corner.x !== undefined ? corner.x : (firstLine[firstLineRef.point === 'start' ? 'x1' : 'x2']);
                    const cornerY = corner.y !== undefined ? corner.y : (firstLine[firstLineRef.point === 'start' ? 'y1' : 'y2']);
                    
                    // æ®µå·®ãŒã‚ã‚‹å ´åˆã¯2ã¤ã®ç‚¹ã€ãªã„å ´åˆã¯1ã¤ã®ç‚¹
                    if (corner.hasStep && corner.lines.length >= 2) {
                        // 2ã¤ã®è¾ºã‹ã‚‰çŠ¶æ…‹ã‚’å–å¾—
                        const line1Ref = corner.lines[0];
                        const line2Ref = corner.lines[1];
                        const line1 = lines.find(l => l.id === line1Ref.lineId);
                        const line2 = lines.find(l => l.id === line2Ref.lineId);
                        
                        if (line1 && line2) {
                            const state1 = line1[line1Ref.point] || 'wall';
                            const state2 = line2[line2Ref.point] || 'wall';
                            
                            // 2ã¤ã®è¾ºã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã®å¹³å‡ã‚’å–ã‚‹
                            let avgDx = 0, avgDy = 0;
                            
                            corner.lines.forEach(lineRef => {
                                const line = lines.find(l => l.id === lineRef.lineId);
                                if (!line) return;
                                
                                let dx, dy;
                                if (lineRef.point === 'start') {
                                    dx = line.x2 - line.x1;
                                    dy = line.y2 - line.y1;
                                } else {
                                    dx = line.x1 - line.x2;
                                    dy = line.y1 - line.y2;
                                }
                                avgDx += dx;
                                avgDy += dy;
                            });
                            
                            const length = Math.sqrt(avgDx * avgDx + avgDy * avgDy);
                            if (length > 0) {
                                const perpX = -avgDy / length;
                                const perpY = avgDx / length;
                                const offset = 12;
                                
                                // 2ã¤ã®ç‚¹ã‚’ãã‚Œãã‚Œã®çŠ¶æ…‹ã§æç”»
                                drawPoint(cornerX + perpX * offset, cornerY + perpY * offset, state1);
                                drawPoint(cornerX - perpX * offset, cornerY - perpY * offset, state2);
                            } else {
                                // æ–¹å‘ãŒå®šã¾ã‚‰ãªã„å ´åˆã¯1ã¤ã ã‘
                                drawPoint(cornerX, cornerY, state1);
                            }
                        }
                    } else {
                        // æ®µå·®ãªã—ï¼š1ã¤ã®ç‚¹
                        const state = firstLine[firstLineRef.point] || 'wall';
                        drawPoint(cornerX, cornerY, state);
                    }
                }
            }
            
            // æç”»ä¸­ã®ãƒã‚¤ãƒ³ãƒˆã‚’è¡¨ç¤º
            drawingPoints.forEach((point, index) => {
                ctx.fillStyle = '#f39c12';
                ctx.beginPath();
                ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }
        
        // ç‚¹ã‚’æç”»
        function drawPoint(x, y, state) {
            const colors = {
                'corner': '#e74c3c', // èµ¤ï¼šã‚³ãƒ¼ãƒŠãƒ¼
                'end': '#3498db',    // é’ï¼šã‚¨ãƒ³ãƒ‰
                'wall': '#2ecc71'    // ç·‘ï¼šå£
            };
            
            ctx.fillStyle = colors[state] || colors['end'];
            ctx.beginPath();
            ctx.arc(x, y, 10, 0, Math.PI * 2); // 8ã‹ã‚‰10ã«å¤‰æ›´
            ctx.fill();
            
            // ç™½ã„æ 
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3; // 2ã‹ã‚‰3ã«å¤‰æ›´
            ctx.stroke();
        }
        
        // å…¥åŠ›ãƒ•ã‚©ãƒ¼ãƒ ä½œæˆ
        function createInputs() {
            const container = document.getElementById('dimension-inputs');
            container.innerHTML = '';
            
            // ã‚³ãƒ¼ãƒŠãƒ¼ã‚’æ¤œå‡º
            detectCorners();
            
            // ç‚¹ã®èª¬æ˜
            const infoDiv = document.createElement('div');
            infoDiv.style.cssText = 'background: #e3f2fd; padding: 12px; border-radius: 8px; margin-bottom: 15px;';
            infoDiv.innerHTML = `
                <p style="margin: 0; color: #555; font-size: 14px; line-height: 1.6;">
                    <span style="color: #e74c3c; font-size: 16px;">â—</span> <strong>èµ¤ï¼ã‚³ãƒ¼ãƒŠãƒ¼</strong>ï¼ˆèº¯ä½“å¹…Ã·2ã‚’å¼•ãï¼‰ã€€
                    <span style="color: #3498db; font-size: 16px;">â—</span> <strong>é’ï¼ã‚¨ãƒ³ãƒ‰</strong>ï¼ˆå£ãªã—ï¼‰ã€€
                    <span style="color: #2ecc71; font-size: 16px;">â—</span> <strong>ç·‘ï¼å£</strong>ï¼ˆå£ã‚ã‚Šï¼‰
                </p>
            `;
            container.appendChild(infoDiv);
            
            // èº¯ä½“å¹…ãƒ»é«˜ã•å…¥åŠ›
            const widthDiv = document.createElement('div');
            widthDiv.style.cssText = 'background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px;';
            widthDiv.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                    <div>
                        <label style="display: block; color: #555; font-weight: bold; margin-bottom: 8px;">èº¯ä½“å¹… (mm)</label>
                        <input type="number" id="common-width" placeholder="ä¾‹: 180" value="${commonWidth || ''}" 
                               oninput="updateCommonWidth(this.value)" 
                               style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px;">
                    </div>
                    <div>
                        <label style="display: block; color: #555; font-weight: bold; margin-bottom: 8px;">èº¯ä½“é«˜ã• (mm)</label>
                        <input type="number" id="common-height" placeholder="ä¾‹: 1100" value="${commonHeight || ''}" 
                               oninput="updateCommonHeight(this.value)" 
                               style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px;">
                    </div>
                </div>
                <div>
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="individual-width-check" ${useIndividualWidth ? 'checked' : ''} 
                               onchange="toggleIndividualWidth(this.checked)"
                               style="width: 18px; height: 18px; margin-right: 8px; cursor: pointer;">
                        <span style="color: #555; font-size: 14px;">è¾ºã”ã¨ã«èº¯ä½“å¹…ã‚’è¨­å®š</span>
                    </label>
                </div>
            `;
            container.appendChild(widthDiv);
            
            // å„è¾ºã®å…¥åŠ›
            lines.forEach((line, lineIndex) => {
                const div = document.createElement('div');
                div.className = 'dimension-item';
                div.setAttribute('data-line-id', line.id);  // IDã‚’è¿½åŠ 
                
                // ã‚³ãƒ¼ãƒŠãƒ¼ã®æ®µå·®çŠ¶æ…‹ã‚’ç¢ºèª
                const startKey = findCornerKey(line.x1, line.y1, 5);
                const endKey = findCornerKey(line.x2, line.y2, 5);
                const startCorner = corners[startKey];
                const endCorner = corners[endKey];
                
                // æ®µå·®ãŒã‚ã‚‹å ´åˆã®çŠ¶æ…‹ã‚’å–å¾—
                const startHasStep = startCorner && startCorner.hasStep;
                const endHasStep = endCorner && endCorner.hasStep;
                
                // ç‚¹ã®çŠ¶æ…‹ã‚’å–å¾—
                let startState = line.start || 'wall';
                let endState = line.end || 'wall';
                
                // æ–œã‚ç·šã‹ã©ã†ã‹åˆ¤å®š
                const isDiagonal = isLineDiagonal(line);
                const angle = isDiagonal ? getLineAngle(line).toFixed(1) : null;
                
                // å€‹åˆ¥èº¯ä½“å¹…å…¥åŠ›æ¬„
                const widthInput = useIndividualWidth ? `
                    <input type="number" placeholder="èº¯ä½“å¹… (mm)" 
                           oninput="updateDimension('${line.id}', 'width', this.value)"
                           value="${dimensions[line.id]?.width || ''}"
                           style="padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 16px;">
                ` : '';
                
                // è§’åº¦å…¥åŠ›æ¬„ï¼ˆæ–œã‚ç·šã®å ´åˆã®ã¿ï¼‰
                const angleInput = isDiagonal ? `
                    <div style="margin-top: 10px; padding: 10px; background: #fff3cd; border-radius: 6px; border: 2px solid #ffc107;">
                        <label style="display: block; color: #856404; font-weight: bold; margin-bottom: 5px; font-size: 13px;">
                            âš ï¸ æ–œã‚ç·šï¼šè§’åº¦ï¼ˆåº¦ï¼‰
                        </label>
                        <input type="number" placeholder="è§’åº¦ (åº¦)" 
                               value="${angle || ''}"
                               oninput="updateLineAngle('${line.id}', this.value)"
                               style="width: 100%; padding: 10px; border: 2px solid #ffc107; border-radius: 6px; font-size: 16px;">
                        <p style="margin: 5px 0 0 0; font-size: 12px; color: #856404;">ç¾åœ¨ã®è§’åº¦: ${angle}Â°</p>
                    </div>
                ` : '';
                
                // ç‚¹ã®çŠ¶æ…‹ãƒœã‚¿ãƒ³ï¼ˆé€šå¸¸ï¼‰
                const pointButtons = `
                    <div style="display: flex; gap: 8px;">
                        <button onclick="changePointState('${line.id}', 'start')" style="padding: 6px 12px; background: ${getStateColor(startState)}; color: white; border: none; border-radius: 6px; font-size: 12px; font-weight: bold; cursor: pointer;">
                            å§‹ç‚¹: ${getStateLabel(startState)}
                        </button>
                        <button onclick="changePointState('${line.id}', 'end')" style="padding: 6px 12px; background: ${getStateColor(endState)}; color: white; border: none; border-radius: 6px; font-size: 12px; font-weight: bold; cursor: pointer;">
                            çµ‚ç‚¹: ${getStateLabel(endState)}
                        </button>
                    </div>
                `;
                
                div.innerHTML = `
                    <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <span style="font-weight: bold; color: #667eea;">${line.name}${isDiagonal ? ' <span style="color: #ff9800;">âš ï¸æ–œã‚</span>' : ''}</span>
                        ${pointButtons}
                    </label>
                    <div class="dimension-row" style="display: grid; grid-template-columns: ${useIndividualWidth ? '1fr 1fr' : '1fr'}; gap: 10px;">
                        <input type="number" placeholder="å¤–æ³•å¯¸æ³• (mm)" 
                               oninput="updateDimension('${line.id}', 'length', this.value)"
                               value="${dimensions[line.id]?.length || ''}"
                               style="padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 16px;">
                        ${widthInput}
                    </div>
                    ${angleInput}
                `;
                container.appendChild(div);
                
                if (!dimensions[line.id]) {
                    dimensions[line.id] = { length: null, width: null };
                }
                
                // ã“ã®è¾ºã®çµ‚ç‚¹ãŒã‚³ãƒ¼ãƒŠãƒ¼ã®å ´åˆã€æ®µå·®è¨­å®šã‚’è¿½åŠ 
                if (endCorner && endCorner.lines.length >= 2 && lineIndex < lines.length - 1) {
                    const cornerDiv = document.createElement('div');
                    cornerDiv.style.cssText = 'margin: 10px 0 20px 0; padding: 12px; background: #e8f5e9; border-radius: 6px; border: 2px solid #4caf50;';
                    
                    const nextLine = lines[lineIndex + 1];
                    const cornerLabel = `${line.name}â”${nextLine.name}`;
                    
                    cornerDiv.innerHTML = `
                        <label style="display: flex; align-items: center; cursor: pointer; margin-bottom: 8px;">
                            <input type="checkbox" ${endCorner.hasStep ? 'checked' : ''} 
                                   onchange="toggleCornerStep('${endKey}', this.checked)"
                                   style="width: 18px; height: 18px; margin-right: 8px; cursor: pointer;">
                            <span style="color: #2e7d32; font-weight: bold; font-size: 14px;">ğŸ“ ${cornerLabel} ã«æ®µå·®ã‚ã‚Š</span>
                        </label>
                        ${endCorner.hasStep ? `
                            <input type="number" placeholder="æ·±ã• (mm)" 
                                   value="${endCorner.depth || ''}"
                                   oninput="updateCornerDepth('${endKey}', this.value)"
                                   style="width: 100%; padding: 8px; border: 2px solid #4caf50; border-radius: 6px; font-size: 14px;">
                        ` : ''}
                    `;
                    container.appendChild(cornerDiv);
                }
            });
        }
        
        // è§’åº¦ã‚’æ›´æ–°ã—ã¦ç·šã‚’å†è¨ˆç®—
        function updateLineAngle(lineId, angleDegrees) {
            const lineIndex = lines.findIndex(line => line.id === lineId);
            if (lineIndex === -1) return;
            
            const line = lines[lineIndex];
            const angle = parseFloat(angleDegrees);
            if (isNaN(angle)) return;
            
            // ç·šã®é•·ã•ã‚’è¨ˆç®—
            const dx = line.x2 - line.x1;
            const dy = line.y2 - line.y1;
            const length = Math.sqrt(dx * dx + dy * dy);
            
            // æ–°ã—ã„è§’åº¦ã§çµ‚ç‚¹ã‚’å†è¨ˆç®—
            const radians = angle * (Math.PI / 180);
            line.x2 = line.x1 + length * Math.cos(radians);
            line.y2 = line.y1 + length * Math.sin(radians);
            
            drawLines();
            createInputs();
        }
        
        // èº¯ä½“å¹…ã‚’æ›´æ–°
        function updateCommonWidth(value) {
            commonWidth = value ? parseFloat(value) : null;
            if (!useIndividualWidth) {
                // å…¨ã¦ã®è¾ºã«é©ç”¨
                lines.forEach(line => {
                    if (dimensions[line.id]) {
                        dimensions[line.id].width = commonWidth;
                    }
                });
                drawLines();
                calculate();
            }
        }
        
        // èº¯ä½“é«˜ã•ã‚’æ›´æ–°
        function updateCommonHeight(value) {
            commonHeight = value ? parseFloat(value) : null;
            drawLines();
            calculate();
        }
        
        // ã‚³ãƒ¼ãƒŠãƒ¼ã®æ®µå·®ã‚’åˆ‡ã‚Šæ›¿ãˆ
        function toggleCornerStep(cornerKey, hasStep) {
            if (!corners[cornerKey]) return;
            
            corners[cornerKey].hasStep = hasStep;
            if (!hasStep) {
                corners[cornerKey].depth = null;
            } else {
                // æ®µå·®ã‚’æœ‰åŠ¹ã«ã—ãŸå ´åˆã€ã“ã®ã‚³ãƒ¼ãƒŠãƒ¼ã®å…¨ã¦ã®ç‚¹ã‚’ã‚³ãƒ¼ãƒŠãƒ¼ä»¥å¤–ã«ã™ã‚‹
                const corner = corners[cornerKey];
                corner.lines.forEach(lineRef => {
                    const line = lines.find(l => l.id === lineRef.lineId);
                    if (line && line[lineRef.point] === 'corner') {
                        line[lineRef.point] = 'wall';
                    }
                });
            }
            
            drawLines();
            createInputs();
        }
        
        // ã‚³ãƒ¼ãƒŠãƒ¼ã®æ·±ã•ã‚’æ›´æ–°
        function updateCornerDepth(cornerKey, depth) {
            if (!corners[cornerKey]) return;
            
            corners[cornerKey].depth = depth ? parseFloat(depth) : null;
        }
        
        // å€‹åˆ¥è¨­å®šã®åˆ‡ã‚Šæ›¿ãˆ
        function toggleIndividualWidth(checked) {
            useIndividualWidth = checked;
            if (!checked && commonWidth) {
                // å€‹åˆ¥â†’å…±é€šã«åˆ‡ã‚Šæ›¿ãˆï¼šå…±é€šå€¤ã‚’å…¨è¾ºã«é©ç”¨
                lines.forEach(line => {
                    if (dimensions[line.id]) {
                        dimensions[line.id].width = commonWidth;
                    }
                });
            }
            createInputs();
            drawLines();
            calculate();
        }
        
        // çŠ¶æ…‹ã®è‰²ã‚’å–å¾—
        function getStateColor(state) {
            const colors = {
                'corner': '#e74c3c',
                'end': '#3498db',
                'wall': '#2ecc71'
            };
            return colors[state] || colors['end'];
        }
        
        // çŠ¶æ…‹ã®ãƒ©ãƒ™ãƒ«ã‚’å–å¾—
        function getStateLabel(state) {
            const labels = {
                'corner': 'ã‚³ãƒ¼ãƒŠãƒ¼',
                'end': 'ã‚¨ãƒ³ãƒ‰',
                'wall': 'å£'
            };
            return labels[state] || labels['end'];
        }
        
        // ãƒœã‚¿ãƒ³ã‹ã‚‰ç‚¹ã®çŠ¶æ…‹ã‚’å¤‰æ›´
        function changePointState(lineId, point) {
            const lineIndex = lines.findIndex(line => line.id === lineId);
            if (lineIndex === -1) return;
            
            const line = lines[lineIndex];
            
            // ã“ã®ç‚¹ã®ã‚³ãƒ¼ãƒŠãƒ¼ã‚­ãƒ¼ã‚’å–å¾—
            const x = point === 'start' ? line.x1 : line.x2;
            const y = point === 'start' ? line.y1 : line.y2;
            const cornerKey = findCornerKey(x, y, 5);
            const corner = corners[cornerKey];
            
            // å›³å½¢ãŒé–‰ã˜ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆæœ€åˆã®ç·šã®å§‹ç‚¹ã¨æœ€å¾Œã®ç·šã®çµ‚ç‚¹ãŒåŒã˜ä½ç½®ï¼‰
            const isClosed = lines.length > 0 && 
                Math.abs(lines[0].x1 - lines[lines.length - 1].x2) < 5 && 
                Math.abs(lines[0].y1 - lines[lines.length - 1].y2) < 5;
            
            // æœ€åˆã®ç·šã®å§‹ç‚¹ã¯ã‚³ãƒ¼ãƒŠãƒ¼ã«ãªã‚Œãªã„ï¼ˆé–‰ã˜ã¦ã„ã‚‹å ´åˆã¯é™¤ãï¼‰
            const isFirstLineStart = (lineIndex === 0 && point === 'start' && !isClosed);
            
            // æœ€å¾Œã®ç·šã®çµ‚ç‚¹ã¯ã‚³ãƒ¼ãƒŠãƒ¼ã«ãªã‚Œãªã„ï¼ˆé–‰ã˜ã¦ã„ã‚‹å ´åˆã¯é™¤ãï¼‰
            const isLastLineEnd = (lineIndex === lines.length - 1 && point === 'end' && !isClosed);
            
            // æ®µå·®ãŒã‚ã‚‹ã‚³ãƒ¼ãƒŠãƒ¼ã®å ´åˆã¯ã€ã‚³ãƒ¼ãƒŠãƒ¼é¸æŠã‚’é™¤å¤–
            const hasStepAtCorner = corner && corner.hasStep;
            
            // é¸æŠå¯èƒ½ãªçŠ¶æ…‹ã‚’æ±ºå®š
            let states;
            if (isFirstLineStart || isLastLineEnd || hasStepAtCorner) {
                states = ['end', 'wall'];
            } else {
                states = ['corner', 'end', 'wall'];
            }
            
            const currentState = lines[lineIndex][point] || 'wall';
            const currentIndex = states.indexOf(currentState);
            const nextIndex = (currentIndex + 1) % states.length;
            lines[lineIndex][point] = states[nextIndex];
            
            // ã‚³ãƒ¼ãƒŠãƒ¼ã«å¤‰æ›´ã—ãŸå ´åˆã€åŒã˜ä½ç½®ã®ç‚¹ã‚‚é€£å‹•
            if (lines[lineIndex][point] === 'corner') {
                autoSetCorners();
            }
            
            // æ®µå·®ãŒã‚ã‚‹ã‚³ãƒ¼ãƒŠãƒ¼ã§çŠ¶æ…‹ã‚’å¤‰æ›´ã—ãŸå ´åˆã€æ¥ç¶šã—ã¦ã„ã‚‹è¾ºã®çŠ¶æ…‹ã‚’è‡ªå‹•èª¿æ•´
            if (corner && corner.hasStep && corner.lines.length >= 2) {
                syncCornerStatesWithStep(cornerKey, lineId, point, lines[lineIndex][point]);
            }
            
            // å†æç”»
            drawLines();
            createInputs(); // ãƒœã‚¿ãƒ³ã®è‰²ã‚’æ›´æ–°
            calculate();
        }
        
        // æ®µå·®ãŒã‚ã‚‹ã‚³ãƒ¼ãƒŠãƒ¼ã®çŠ¶æ…‹ã‚’åŒæœŸï¼ˆç‰‡æ–¹ãŒã‚¨ãƒ³ãƒ‰â†’ã‚‚ã†ç‰‡æ–¹ã¯å£ï¼‰
        function syncCornerStatesWithStep(cornerKey, changedLineId, changedPoint, newState) {
            const corner = corners[cornerKey];
            if (!corner) return;
            
            // ã“ã®ã‚³ãƒ¼ãƒŠãƒ¼ã«æ¥ç¶šã—ã¦ã„ã‚‹è¾ºã‚’å–å¾—
            corner.lines.forEach(lineRef => {
                const line = lines.find(l => l.id === lineRef.lineId);
                if (!line) return;
                
                // å¤‰æ›´ã—ãŸè¾ºä»¥å¤–ã®è¾ºã®çŠ¶æ…‹ã‚’èª¿æ•´
                if (line.id !== changedLineId) {
                    if (newState === 'end') {
                        // ç‰‡æ–¹ãŒã‚¨ãƒ³ãƒ‰ â†’ ã‚‚ã†ç‰‡æ–¹ã¯å£
                        line[lineRef.point] = 'wall';
                    } else if (newState === 'wall') {
                        // ç‰‡æ–¹ãŒå£ â†’ ã‚‚ã†ç‰‡æ–¹ã¯ã‚¨ãƒ³ãƒ‰ã¾ãŸã¯å£ï¼ˆå¤‰æ›´ã—ãªã„ï¼‰
                        // ä½•ã‚‚ã—ãªã„
                    }
                }
            });
        }
        
        // å¯¸æ³•æ›´æ–°
        function updateDimension(id, type, value) {
            if (!dimensions[id]) {
                dimensions[id] = { length: null, width: null };
            }
            
            dimensions[id][type] = value ? parseFloat(value) : null;
            
            // å›³é¢ã‚’å†æç”»ï¼ˆã‚¹ã‚±ãƒ¼ãƒ«èª¿æ•´ã¯ã—ãªã„ï¼‰
            drawLines();
            calculate();
        }
        
        // è¨ˆç®—
        function calculate() {
            const resultsContent = document.getElementById('results-content');
            let html = '';
            let hasAll = true;
            let missingItems = []; // æœªå…¥åŠ›é …ç›®ãƒªã‚¹ãƒˆ
            
            // ã‚³ãƒ¼ãƒŠãƒ¼ã‚’æ¤œå‡º
            detectCorners();
            
            // å…¥åŠ›ãƒã‚§ãƒƒã‚¯
            lines.forEach(line => {
                const dim = dimensions[line.id];
                
                // å¤–æ³•å¯¸æ³•ã®ãƒã‚§ãƒƒã‚¯
                if (!dim || !dim.length) {
                    hasAll = false;
                    missingItems.push(`${line.name}ã®å¤–æ³•å¯¸æ³•`);
                }
                
                // èº¯ä½“å¹…ã®ãƒã‚§ãƒƒã‚¯
                const hasWidth = useIndividualWidth ? (dim && dim.width) : commonWidth;
                if (!hasWidth) {
                    hasAll = false;
                    if (useIndividualWidth) {
                        missingItems.push(`${line.name}ã®èº¯ä½“å¹…`);
                    } else if (!commonWidth) {
                        // èº¯ä½“å¹…ã®ãƒã‚§ãƒƒã‚¯ï¼ˆé‡è¤‡ã‚’é¿ã‘ã‚‹ãŸã‚ä¸€åº¦ã ã‘è¿½åŠ ï¼‰
                        if (!missingItems.includes('èº¯ä½“å¹…')) {
                            missingItems.push('èº¯ä½“å¹…');
                        }
                    }
                }
            });
            
            // èº¯ä½“é«˜ã•ã®ãƒã‚§ãƒƒã‚¯
            if (!commonHeight) {
                hasAll = false;
                missingItems.push('èº¯ä½“é«˜ã•');
            }
            
            // æ®µå·®å¯¸æ³•ã®ãƒã‚§ãƒƒã‚¯
            if (corners) {
                for (const cornerKey in corners) {
                    const corner = corners[cornerKey];
                    if (corner && corner.hasStep) {
                        // æ®µå·®ãŒã‚ã‚‹å ´åˆã€æ·±ã•ãŒå…¥åŠ›ã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                        if (!corner.depth) {
                            hasAll = false;
                            // ã‚³ãƒ¼ãƒŠãƒ¼ã«æ¥ç¶šã—ã¦ã„ã‚‹è¾ºã®åå‰ã‚’å–å¾—
                            if (corner.lines && corner.lines.length >= 2) {
                                const line1 = lines.find(l => l.id === corner.lines[0].lineId);
                                const line2 = lines.find(l => l.id === corner.lines[1].lineId);
                                if (line1 && line2) {
                                    missingItems.push(`${line1.name}â”${line2.name}ã®æ®µå·®å¯¸æ³•`);
                                } else {
                                    missingItems.push('æ®µå·®å¯¸æ³•');
                                }
                            } else {
                                missingItems.push('æ®µå·®å¯¸æ³•');
                            }
                        }
                    }
                }
            }
            
            // å…¨ã¦å…¥åŠ›ã•ã‚Œã¦ã„ã‚‹å ´åˆã®ã¿è¨ˆç®—çµæœã‚’è¡¨ç¤º
            if (hasAll) {
                lines.forEach(line => {
                    const dim = dimensions[line.id];
                    let result = dim.length;
                    
                    // å§‹ç‚¹ãŒã‚³ãƒ¼ãƒŠãƒ¼ãªã‚‰éš£æ¥ã™ã‚‹è¾ºã®å¹…ã®åŠåˆ†ã‚’å¼•ã
                    if (line.start === 'corner') {
                        const adjacentWidth = getAdjacentLineWidth(line.id, 'start');
                        if (adjacentWidth > 0) {
                            result -= adjacentWidth / 2;
                        }
                    }
                    
                    // çµ‚ç‚¹ãŒã‚³ãƒ¼ãƒŠãƒ¼ãªã‚‰éš£æ¥ã™ã‚‹è¾ºã®å¹…ã®åŠåˆ†ã‚’å¼•ã
                    if (line.end === 'corner') {
                        const adjacentWidth = getAdjacentLineWidth(line.id, 'end');
                        if (adjacentWidth > 0) {
                            result -= adjacentWidth / 2;
                        }
                    }
                    
                    const startLabel = getPointLabel(line.start);
                    const endLabel = getPointLabel(line.end);
                    
                    html += `
                        <div class="result-item">
                            <span class="result-label">${line.name} ${startLabel}â”${endLabel}</span>
                            <span class="result-value">${Math.floor(result)} mm</span>
                        </div>
                    `;
                });
                
                // ã‚­ãƒ£ãƒ³ãƒã‚¹ã¨ä¿å­˜ãƒœã‚¿ãƒ³ã‚’è¿½åŠ ã—ã¦å›³ã‚’æç”»
                html = `
                    <div style="margin-bottom: 20px;">
                        <canvas id="result-canvas" width="500" height="400" style="width: 100%; border-radius: 10px;"></canvas>
                    </div>
                    <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
                        <button onclick="downloadAsPDF()" style="flex: 1; min-width: 140px; padding: 12px 20px; background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                            ğŸ“„ PDFã§ä¿å­˜
                        </button>
                        <button onclick="downloadAsPNG()" style="flex: 1; min-width: 140px; padding: 12px 20px; background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                            ğŸ–¼ï¸ ç”»åƒã§ä¿å­˜
                        </button>
                        <button onclick="shareResult()" style="flex: 1; min-width: 140px; padding: 12px 20px; background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                            ğŸ“¤ å…±æœ‰
                        </button>
                    </div>
                ` + html;
                
                resultsContent.innerHTML = html;
                
                // å›³ã‚’æç”»
                drawResultDiagram();
            } else {
                // å…¥åŠ›æ¼ã‚ŒãŒã‚ã‚‹å ´åˆã€èµ¤æ–‡å­—ã§è­¦å‘Šè¡¨ç¤º
                const warningHtml = `
                    <div style="background: #fee; border: 2px solid #e74c3c; border-radius: 10px; padding: 20px; text-align: center;">
                        <div style="color: #e74c3c; font-size: 20px; font-weight: bold; margin-bottom: 15px;">
                            âš ï¸ å…¥åŠ›ãŒå®Œäº†ã—ã¦ã„ã¾ã›ã‚“
                        </div>
                        <div style="color: #c0392b; font-size: 16px; line-height: 1.8;">
                            ä»¥ä¸‹ã®é …ç›®ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼š<br>
                            <strong>${missingItems.join('ã€')}</strong>
                        </div>
                    </div>
                `;
                resultsContent.innerHTML = warningHtml;
            }
        }
        
        // éš£æ¥ã™ã‚‹è¾ºã®å¹…ã‚’å–å¾—
        function getAdjacentLineWidth(lineId, point) {
            // è©²å½“ã™ã‚‹è¾ºã‚’æ¢ã™
            const currentLine = lines.find(l => l.id === lineId);
            if (!currentLine) return 0;
            
            // ã‚³ãƒ¼ãƒŠãƒ¼ã‚­ãƒ¼ã‚’å–å¾—
            const x = point === 'start' ? currentLine.x1 : currentLine.x2;
            const y = point === 'start' ? currentLine.y1 : currentLine.y2;
            const cornerKey = findCornerKey(x, y, 5);
            
            if (!corners || !corners[cornerKey]) return 0;
            
            const corner = corners[cornerKey];
            
            // ã“ã®ã‚³ãƒ¼ãƒŠãƒ¼ã«æ¥ç¶šã—ã¦ã„ã‚‹ä»–ã®è¾ºã‚’æ¢ã™
            for (const lineRef of corner.lines) {
                if (lineRef.lineId !== lineId) {
                    // éš£æ¥ã™ã‚‹è¾ºãŒè¦‹ã¤ã‹ã£ãŸ
                    const adjacentLine = lines.find(l => l.id === lineRef.lineId);
                    if (adjacentLine) {
                        const adjacentDim = dimensions[lineRef.lineId];
                        if (adjacentDim && adjacentDim.width) {
                            return adjacentDim.width;
                        }
                    }
                }
            }
            
            return 0;
        }
        
        // è¨ˆç®—çµæœã®å›³ã‚’æç”»
        function drawResultDiagram() {
            const resultCanvas = document.getElementById('result-canvas');
            if (!resultCanvas) return;
            
            const ctx = resultCanvas.getContext('2d');
            
            // èƒŒæ™¯è‰²ã‚’å¡—ã‚‹ï¼ˆè¨ˆç®—çµæœã¨ã‚ã‹ã‚‹ã‚ˆã†ã«ï¼‰
            ctx.fillStyle = '#f0f9ff';
            ctx.fillRect(0, 0, resultCanvas.width, resultCanvas.height);
            
            if (lines.length === 0) return;
            
            // å®Ÿå¯¸æ³•ã‚’ä½¿ã£ã¦å›³å½¢ã‚’å†æ§‹ç¯‰
            const realLines = [];
            let currentX = 0;
            let currentY = 0;
            const minLength = 200; // æœ€å°è¡¨ç¤ºé•·ã•ï¼ˆpxï¼‰- æ•°å­—ãŒé‡ãªã‚‰ãªã„ã‚µã‚¤ã‚º
            
            // æœ€åˆã®ç·šã®å§‹ç‚¹ã‚’è¨­å®š
            realLines.push({
                x1: currentX,
                y1: currentY,
                line: lines[0]
            });
            
            // å„ç·šã‚’å®Ÿå¯¸æ³•ã®æ¯”ç‡ã§é…ç½®
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const dim = dimensions[line.id];
                
                if (!dim || !dim.length) continue;
                
                // å®Ÿéš›ã®é•·ã•ã‚’å–å¾—ï¼ˆmmï¼‰
                let realLength = dim.length;
                
                // ç·šã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—
                const dx = line.x2 - line.x1;
                const dy = line.y2 - line.y1;
                const originalLength = Math.sqrt(dx * dx + dy * dy);
                
                if (originalLength === 0) continue;
                
                // æ­£è¦åŒ–ã•ã‚ŒãŸæ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«
                const dirX = dx / originalLength;
                const dirY = dy / originalLength;
                
                // å®Ÿå¯¸æ³•ã‚’ãƒ”ã‚¯ã‚»ãƒ«ã«å¤‰æ›ï¼ˆ1mm = 0.2pxã€ãŸã ã—æœ€å°é•·ã•ã‚’ä¿è¨¼ï¼‰
                let displayLength = Math.max(realLength * 0.2, minLength);
                
                // æ–°ã—ã„çµ‚ç‚¹ã‚’è¨ˆç®—
                const nextX = currentX + dirX * displayLength;
                const nextY = currentY + dirY * displayLength;
                
                realLines[realLines.length - 1].x2 = nextX;
                realLines[realLines.length - 1].y2 = nextY;
                
                // æ¬¡ã®ç·šã®å§‹ç‚¹ã‚’è¨­å®š
                if (i < lines.length - 1) {
                    currentX = nextX;
                    currentY = nextY;
                    realLines.push({
                        x1: currentX,
                        y1: currentY,
                        line: lines[i + 1]
                    });
                }
            }
            
            if (realLines.length === 0) return;
            
            // å…¨ã¦ã®ç‚¹ã®ç¯„å›²ã‚’å–å¾—
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            
            realLines.forEach(rLine => {
                minX = Math.min(minX, rLine.x1, rLine.x2);
                minY = Math.min(minY, rLine.y1, rLine.y2);
                maxX = Math.max(maxX, rLine.x1, rLine.x2);
                maxY = Math.max(maxY, rLine.y1, rLine.y2);
            });
            
            // å›³å½¢ã®å¹…ã¨é«˜ã•
            const shapeWidth = maxX - minX;
            const shapeHeight = maxY - minY;
            
            if (shapeWidth === 0 || shapeHeight === 0) return;
            
            // ãƒãƒ¼ã‚¸ãƒ³
            const margin = 60;
            const canvasWidth = resultCanvas.width - margin * 2;
            const canvasHeight = resultCanvas.height - margin * 2;
            
            // ã‚¹ã‚±ãƒ¼ãƒ«ä¿‚æ•°ã‚’è¨ˆç®—ï¼ˆã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’ç¶­æŒï¼‰
            const scaleX = canvasWidth / shapeWidth;
            const scaleY = canvasHeight / shapeHeight;
            const scale = Math.min(scaleX, scaleY);
            
            // ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨ˆç®—ï¼ˆä¸­å¤®é…ç½®ï¼‰
            const scaledWidth = shapeWidth * scale;
            const scaledHeight = shapeHeight * scale;
            const offsetX = margin + (canvasWidth - scaledWidth) / 2 - minX * scale;
            const offsetY = margin + (canvasHeight - scaledHeight) / 2 - minY * scale;
            
            // åº§æ¨™å¤‰æ›é–¢æ•°
            function transformX(x) {
                return x * scale + offsetX;
            }
            
            function transformY(y) {
                return y * scale + offsetY;
            }
            
            // ç‚¹ã‚’æç”»ã™ã‚‹é–¢æ•°
            function drawResultPoint(x, y, state) {
                const colors = {
                    'corner': '#ef4444',
                    'end': '#3b82f6',
                    'wall': '#10b981'
                };
                
                ctx.fillStyle = colors[state] || colors['end'];
                ctx.beginPath();
                ctx.arc(transformX(x), transformY(y), 6, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(transformX(x), transformY(y), 6, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // ã‚³ãƒ¼ãƒŠãƒ¼ã‚’æ¤œå‡º
            detectCorners();
            
            // ç·šã‚’æç”»ï¼ˆé»’ä¸€è‰²ã«çµ±ä¸€ï¼‰
            realLines.forEach(rLine => {
                const line = rLine.line;
                
                ctx.strokeStyle = '#1a1a1a';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                ctx.moveTo(transformX(rLine.x1), transformY(rLine.y1));
                ctx.lineTo(transformX(rLine.x2), transformY(rLine.y2));
                ctx.stroke();
                
                // è¨ˆç®—çµæœã¨èº¯ä½“å¹…ã‚’ç·šã®å¤–å´ã«è¡¨ç¤º
                const dim = dimensions[line.id];
                if (dim && dim.length) {
                    let result = dim.length;
                    
                    // å§‹ç‚¹ãŒã‚³ãƒ¼ãƒŠãƒ¼ãªã‚‰éš£æ¥ã™ã‚‹è¾ºã®å¹…ã®åŠåˆ†ã‚’å¼•ã
                    if (line.start === 'corner') {
                        const adjacentWidth = getAdjacentLineWidth(line.id, 'start');
                        if (adjacentWidth > 0) {
                            result -= adjacentWidth / 2;
                        }
                    }
                    
                    // çµ‚ç‚¹ãŒã‚³ãƒ¼ãƒŠãƒ¼ãªã‚‰éš£æ¥ã™ã‚‹è¾ºã®å¹…ã®åŠåˆ†ã‚’å¼•ã
                    if (line.end === 'corner') {
                        const adjacentWidth = getAdjacentLineWidth(line.id, 'end');
                        if (adjacentWidth > 0) {
                            result -= adjacentWidth / 2;
                        }
                    }
                    
                    // ç·šã®ä¸­ç‚¹ã¨æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—
                    const midX = (rLine.x1 + rLine.x2) / 2;
                    const midY = (rLine.y1 + rLine.y2) / 2;
                    const dx = rLine.x2 - rLine.x1;
                    const dy = rLine.y2 - rLine.y1;
                    const lineLength = Math.sqrt(dx * dx + dy * dy);
                    
                    // ç·šã®å‚ç›´æ–¹å‘ã®ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆå·¦å´ã«é…ç½®ï¼‰
                    const perpX = -dy / lineLength;
                    const perpY = dx / lineLength;
                    
                    // ãƒ†ã‚­ã‚¹ãƒˆã®ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆç·šã®å¤–å´ã€40pxé›¢ã™ï¼‰
                    const offset = 40;
                    const textX = transformX(midX + perpX * offset);
                    const textY = transformY(midY + perpY * offset);
                    
                    // èŠ¯å¯¸æ³•ï¼ˆè¨ˆç®—çµæœï¼‰ã‚’å¤§ããç›®ç«‹ã¤ã‚ˆã†ã«è¡¨ç¤º
                    ctx.font = 'bold 22px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    const resultText = `${Math.floor(result)}`;
                    const resultMetrics = ctx.measureText(resultText);
                    const padding = 8;
                    
                    // é»„è‰²ã®èƒŒæ™¯ã§ç›®ç«‹ãŸã›ã‚‹
                    ctx.fillStyle = '#fef3c7';
                    ctx.fillRect(textX - resultMetrics.width/2 - padding, textY - 13, resultMetrics.width + padding*2, 26);
                    
                    // æ ç·šã‚’è¿½åŠ 
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(textX - resultMetrics.width/2 - padding, textY - 13, resultMetrics.width + padding*2, 26);
                    
                    // æ–‡å­—ã‚’æç”»ï¼ˆæ¿ƒã„é’ã§å¼·èª¿ï¼‰
                    ctx.fillStyle = '#1e40af';
                    ctx.fillText(resultText, textX, textY);
                    
                    // èº¯ä½“å¹…ã‚’å°ã•ãè¡¨ç¤ºï¼ˆèŠ¯å¯¸æ³•ã®ä¸‹ã€èƒŒæ™¯ä»˜ãï¼‰
                    if (dim.width) {
                        ctx.font = '11px sans-serif';
                        const widthText = `å¹…:${dim.width}`;
                        const widthMetrics = ctx.measureText(widthText);
                        const widthY = textY + 20;
                        const widthPadding = 4;
                        
                        // èƒŒæ™¯ï¼ˆè–„ã„ç°è‰²ï¼‰
                        ctx.fillStyle = '#f3f4f6';
                        ctx.fillRect(textX - widthMetrics.width/2 - widthPadding, widthY - 8, widthMetrics.width + widthPadding*2, 16);
                        
                        // æ–‡å­—ï¼ˆç°è‰²ï¼‰
                        ctx.fillStyle = '#6b7280';
                        ctx.fillText(widthText, textX, widthY);
                    }
                }
            });
            
            // æ—¢ã«æç”»ã—ãŸã‚³ãƒ¼ãƒŠãƒ¼ã‚’è¨˜éŒ²
            const drawnCorners = new Set();
            
            // å…ƒã®åº§æ¨™ã‹ã‚‰realLinesåº§æ¨™ã¸ã®å¯¾å¿œãƒãƒƒãƒ—ã‚’ä½œæˆ
            const coordMap = new Map();
            realLines.forEach((rLine, idx) => {
                const line = rLine.line;
                // å§‹ç‚¹ã®å¯¾å¿œ
                const startKey = `${line.x1},${line.y1}`;
                if (!coordMap.has(startKey)) {
                    coordMap.set(startKey, { x: rLine.x1, y: rLine.y1 });
                }
                // çµ‚ç‚¹ã®å¯¾å¿œ
                const endKey = `${line.x2},${line.y2}`;
                if (!coordMap.has(endKey)) {
                    coordMap.set(endKey, { x: rLine.x2, y: rLine.y2 });
                }
            });
            
            // ã‚³ãƒ¼ãƒŠãƒ¼ãƒ™ãƒ¼ã‚¹ã§ç‚¹ã‚’æç”»
            if (corners) {
                for (const cornerKey in corners) {
                    const corner = corners[cornerKey];
                    
                    if (!corner || drawnCorners.has(cornerKey)) continue;
                    drawnCorners.add(cornerKey);
                    
                    if (!corner.lines || corner.lines.length === 0) continue;
                    
                    const firstLineRef = corner.lines[0];
                    const firstLine = lines.find(l => l.id === firstLineRef.lineId);
                    if (!firstLine) continue;
                    
                    // ã‚³ãƒ¼ãƒŠãƒ¼ã®å…ƒåº§æ¨™
                    const cornerX = corner.x !== undefined ? corner.x : (firstLine[firstLineRef.point === 'start' ? 'x1' : 'x2']);
                    const cornerY = corner.y !== undefined ? corner.y : (firstLine[firstLineRef.point === 'start' ? 'y1' : 'y2']);
                    
                    // å…ƒåº§æ¨™ã‹ã‚‰realLinesåº§æ¨™ã«å¤‰æ›
                    const coordKey = `${cornerX},${cornerY}`;
                    const realCoord = coordMap.get(coordKey);
                    
                    if (!realCoord) continue;
                    
                    // æ®µå·®ãŒã‚ã‚‹å ´åˆã¯2ã¤ã®ç‚¹ã€ãªã„å ´åˆã¯1ã¤ã®ç‚¹
                    if (corner.hasStep && corner.lines.length >= 2) {
                        // 2ã¤ã®è¾ºã‹ã‚‰çŠ¶æ…‹ã‚’å–å¾—
                        const line1Ref = corner.lines[0];
                        const line2Ref = corner.lines[1];
                        const line1 = lines.find(l => l.id === line1Ref.lineId);
                        const line2 = lines.find(l => l.id === line2Ref.lineId);
                        
                        if (line1 && line2) {
                            const state1 = line1[line1Ref.point] || 'wall';
                            const state2 = line2[line2Ref.point] || 'wall';
                            
                            let avgDx = 0, avgDy = 0;
                            
                            corner.lines.forEach(lineRef => {
                                const line = lines.find(l => l.id === lineRef.lineId);
                                if (!line) return;
                                
                                let dx, dy;
                                if (lineRef.point === 'start') {
                                    dx = line.x2 - line.x1;
                                    dy = line.y2 - line.y1;
                                } else {
                                    dx = line.x1 - line.x2;
                                    dy = line.y1 - line.y2;
                                }
                                avgDx += dx;
                                avgDy += dy;
                            });
                            
                            const length = Math.sqrt(avgDx * avgDx + avgDy * avgDy);
                            if (length > 0) {
                                const perpX = -avgDy / length;
                                const perpY = avgDx / length;
                                const offset = 12;
                                
                                // 2ã¤ã®ç‚¹ã‚’ãã‚Œãã‚Œã®çŠ¶æ…‹ã§æç”»
                                drawResultPoint(realCoord.x + perpX * offset, realCoord.y + perpY * offset, state1);
                                drawResultPoint(realCoord.x - perpX * offset, realCoord.y - perpY * offset, state2);
                            } else {
                                drawResultPoint(realCoord.x, realCoord.y, state1);
                            }
                        }
                    } else {
                        const state = firstLine[firstLineRef.point] || 'wall';
                        drawResultPoint(realCoord.x, realCoord.y, state);
                    }
                }
            }
        }
        
        // ç‚¹ã®ãƒ©ãƒ™ãƒ«ã‚’å–å¾—
        function getPointLabel(state) {
            const labels = {
                'corner': '<span style="color: #e74c3c;">â—</span>',
                'end': '<span style="color: #3498db;">â—</span>',
                'wall': '<span style="color: #2ecc71;">â—</span>'
            };
            return labels[state] || labels['end'];
        }
        
        // ã‚«ã‚¹ã‚¿ãƒ ä½œå›³
        function setupCustomDrawing() {
            // å…¥åŠ›ãƒ•ã‚©ãƒ¼ãƒ ã‚’ã‚¯ãƒªã‚¢
            document.getElementById('dimension-inputs').innerHTML = `
                <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0; color: #1976d2; font-size: 16px;">ğŸ“ ä½œå›³æ–¹æ³•</h3>
                    <p style="margin: 0; color: #555; font-size: 14px;">
                        <strong>ã‚¯ãƒªãƒƒã‚¯</strong>ã§ç‚¹ã‚’æ‰“ã¡ã€ç·šã‚’é€£ç¶šã—ã¦å¼•ã<br>
                        <strong>ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯</strong>ã¾ãŸã¯ä¸‹ã®ãƒœã‚¿ãƒ³ã§ä½œå›³çµ‚äº†
                    </p>
                    <button onclick="finishDrawing()" style="width: 100%; padding: 12px; background: #27ae60; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: bold; cursor: pointer; margin-top: 10px;">
                        âœ“ ä½œå›³çµ‚äº†
                    </button>
                    <h3 style="margin: 15px 0 10px 0; color: #1976d2; font-size: 16px;">ğŸ¨ ç‚¹ã®æ„å‘³</h3>
                    <p style="margin: 0; color: #555; font-size: 14px;">
                        <span style="color: #e74c3c;">â—</span> èµ¤ï¼šã‚³ãƒ¼ãƒŠãƒ¼ï¼ˆèº¯ä½“å¹…Ã·2ã‚’å¼•ãï¼‰<br>
                        <span style="color: #3498db;">â—</span> é’ï¼šã‚¨ãƒ³ãƒ‰ï¼ˆç«¯éƒ¨ã€å£ãªã—ï¼‰<br>
                        <span style="color: #2ecc71;">â—</span> ç·‘ï¼šå£ï¼ˆå£ã‚ã‚Šï¼‰<br>
                        <strong>ä½œå›³çµ‚äº†å¾Œã€ç‚¹ã‚’ã‚¿ãƒƒãƒ—ã§åˆ‡ã‚Šæ›¿ãˆ</strong>
                    </p>
                </div>
            `;
            
            drawingPoints = [];
            
            // æ—¢å­˜ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’ã™ã¹ã¦å‰Šé™¤
            canvas.removeEventListener('mousedown', startDrawing);
            canvas.removeEventListener('mousemove', drawing);
            canvas.removeEventListener('mouseup', endDrawing);
            canvas.removeEventListener('click', handlePointClick);
            canvas.removeEventListener('touchend', handlePointClickTouch);
            
            // ä½œå›³ç”¨ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¨­å®š
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('mousemove', handleCanvasMouseMove);
            
            canvas.addEventListener('touchstart', handleTouchDrawing);
            canvas.addEventListener('touchmove', handleTouchDrawingMove);
            
            updateDrawingControls();
        }
        
        // Canvasã‚¯ãƒªãƒƒã‚¯å‡¦ç†ï¼ˆä½œå›³ç”¨ï¼‰
        function handleCanvasClick(e) {
            // ç‚¹ã®çŠ¶æ…‹åˆ‡ã‚Šæ›¿ãˆã¨ã®ç«¶åˆã‚’é¿ã‘ã‚‹
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let x = (e.offsetX || e.clientX - rect.left) * scaleX;
            let y = (e.offsetY || e.clientY - rect.top) * scaleY;
            
            // ã‚¹ãƒŠãƒƒãƒ—å‡¦ç†ï¼ˆ2ç‚¹ç›®ä»¥é™ï¼‰
            if (drawingPoints.length > 0) {
                const lastPoint = drawingPoints[drawingPoints.length - 1];
                const snapped = snapToAxis(lastPoint.x, lastPoint.y, x, y);
                x = snapped.x;
                y = snapped.y;
            }
            
            // å§‹ç‚¹ã¸ã®å¸ç€ã¨é–‰ã˜ã‚‹ç¢ºèªï¼ˆ3ç‚¹ä»¥ä¸Šã‚ã‚‹å ´åˆï¼‰
            if (drawingPoints.length >= 3) {
                const startPoint = drawingPoints[0];
                const distToStart = Math.sqrt(Math.pow(x - startPoint.x, 2) + Math.pow(y - startPoint.y, 2));
                
                // å§‹ç‚¹ã‹ã‚‰30pxä»¥å†…ï¼ˆç›´æ¥ã‚¯ãƒªãƒƒã‚¯ã¾ãŸã¯ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³çµŒç”±ï¼‰
                if (distToStart < 30) {
                    if (confirm('å›³å½¢ã‚’é–‰ã˜ã¾ã™ã‹ï¼Ÿ\nï¼ˆå§‹ç‚¹ã¨çµ‚ç‚¹ã‚’çµåˆã—ã¾ã™ï¼‰')) {
                        // å§‹ç‚¹ã«å¸ç€
                        x = startPoint.x;
                        y = startPoint.y;
                        
                        // ç‚¹ã‚’è¿½åŠ 
                        drawingPoints.push({ x, y });
                        
                        // æœ€å¾Œã®ç·šã‚’ä½œæˆ
                        const prevPoint = drawingPoints[drawingPoints.length - 2];
                        const currPoint = drawingPoints[drawingPoints.length - 1];
                        
                        const id = String.fromCharCode(65 + lines.length);
                        lines.push({
                            id: id,
                            x1: prevPoint.x,
                            y1: prevPoint.y,
                            x2: currPoint.x,
                            y2: currPoint.y,
                            name: `è¾º${id}`,
                            start: 'wall',
                            end: 'wall'
                        });
                        
                        // ã‚³ãƒ¼ãƒŠãƒ¼ã®è‡ªå‹•è¨­å®š
                        autoSetCorners();
                        
                        // ä½œå›³çµ‚äº†
                        finishDrawing();
                        return;
                    } else {
                        // ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ãŸå ´åˆã¯ä½•ã‚‚ã—ãªã„
                        return;
                    }
                }
            }
            
            // æ—¢å­˜ã®ç‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‹åˆ¤å®šï¼ˆãŸã ã—å§‹ç‚¹ã¯é™¤ãï¼‰
            const clickRadius = 20;
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                // å§‹ç‚¹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆ3ç‚¹ä»¥ä¸Šã‚ã‚‹å ´åˆï¼‰
                let isStartPoint = false;
                if (drawingPoints.length >= 3 && i === 0) {
                    const startPoint = drawingPoints[0];
                    const distToStart = Math.sqrt(Math.pow(line.x1 - startPoint.x, 2) + Math.pow(line.y1 - startPoint.y, 2));
                    isStartPoint = distToStart < 5; // å§‹ç‚¹ã¨åŒã˜ä½ç½®ãªã‚‰
                }
                
                const distStart = Math.sqrt(Math.pow(x - line.x1, 2) + Math.pow(y - line.y1, 2));
                const distEnd = Math.sqrt(Math.pow(x - line.x2, 2) + Math.pow(y - line.y2, 2));
                
                // å§‹ç‚¹ä»¥å¤–ã®æ—¢å­˜ã®ç‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´åˆã¯ç„¡è¦–
                if (!isStartPoint && distStart < clickRadius) {
                    return;
                }
                if (distEnd < clickRadius) {
                    return;
                }
            }
            
            // ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯åˆ¤å®š
            const currentTime = new Date().getTime();
            const timeDiff = currentTime - lastClickTime;
            lastClickTime = currentTime;
            
            if (timeDiff < 500 && drawingPoints.length > 0) {
                finishDrawing();
                return;
            }
            
            // ç‚¹ã‚’è¿½åŠ 
            drawingPoints.push({ x, y });
            
            // 2ç‚¹ä»¥ä¸Šã‚ã‚Œã°ç·šã‚’ä½œæˆ
            if (drawingPoints.length >= 2) {
                const prevPoint = drawingPoints[drawingPoints.length - 2];
                const currPoint = drawingPoints[drawingPoints.length - 1];
                
                const id = String.fromCharCode(65 + lines.length);
                lines.push({
                    id: id,
                    x1: prevPoint.x,
                    y1: prevPoint.y,
                    x2: currPoint.x,
                    y2: currPoint.y,
                    name: `è¾º${id}`,
                    start: 'wall',
                    end: 'wall'
                });
                
                // ã‚³ãƒ¼ãƒŠãƒ¼ã®è‡ªå‹•è¨­å®š
                autoSetCorners();
            }
            
            drawLines();
            updateDrawingControls();
        }
        
        // ãƒã‚¦ã‚¹ç§»å‹•æ™‚ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
        function handleCanvasMouseMove(e) {
            if (drawingPoints.length === 0) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let x = (e.offsetX || e.clientX - rect.left) * scaleX;
            let y = (e.offsetY || e.clientY - rect.top) * scaleY;
            
            // ã‚¹ãƒŠãƒƒãƒ—å‡¦ç†
            const lastPoint = drawingPoints[drawingPoints.length - 1];
            const snapped = snapToAxis(lastPoint.x, lastPoint.y, x, y);
            x = snapped.x;
            y = snapped.y;
            
            drawLines();
            
            // å§‹ç‚¹ã¸ã®ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã¨å¸ç€ï¼ˆ3ç‚¹ä»¥ä¸Šã‚ã‚‹å ´åˆï¼‰
            let snapToStart = false;
            if (drawingPoints.length >= 3) {
                const startPoint = drawingPoints[0];
                const threshold = 10; // ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³è¡¨ç¤ºã®é–¾å€¤
                
                // æ°´å¹³ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ï¼ˆYåº§æ¨™ãŒå§‹ç‚¹ã¨è¿‘ã„å ´åˆï¼‰
                if (Math.abs(y - startPoint.y) < threshold) {
                    // å§‹ç‚¹ã«å‘ã‹ã£ã¦æ°´å¹³ç·šã‚’å¼•ã
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(x, startPoint.y);
                    ctx.lineTo(startPoint.x, startPoint.y);
                    ctx.stroke();
                    
                    // Yåº§æ¨™ã‚’å§‹ç‚¹ã«åˆã‚ã›ã‚‹
                    y = startPoint.y;
                    
                    // Xåº§æ¨™ã‚‚å§‹ç‚¹ã¨è¿‘ã„å ´åˆã¯å¸ç€
                    if (Math.abs(x - startPoint.x) < threshold) {
                        x = startPoint.x;
                        snapToStart = true;
                    }
                }
                
                // å‚ç›´ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ï¼ˆXåº§æ¨™ãŒå§‹ç‚¹ã¨è¿‘ã„å ´åˆï¼‰
                if (Math.abs(x - startPoint.x) < threshold) {
                    // å§‹ç‚¹ã«å‘ã‹ã£ã¦å‚ç›´ç·šã‚’å¼•ã
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(startPoint.x, y);
                    ctx.lineTo(startPoint.x, startPoint.y);
                    ctx.stroke();
                    
                    // Xåº§æ¨™ã‚’å§‹ç‚¹ã«åˆã‚ã›ã‚‹
                    x = startPoint.x;
                    
                    // Yåº§æ¨™ã‚‚å§‹ç‚¹ã¨è¿‘ã„å ´åˆã¯å¸ç€
                    if (Math.abs(y - startPoint.y) < threshold) {
                        y = startPoint.y;
                        snapToStart = true;
                    }
                }
                
                // å§‹ç‚¹ã¨åˆè‡´ã—ãŸå ´åˆã€å§‹ç‚¹ã‚’å¤§ããè¡¨ç¤º
                if (snapToStart) {
                    ctx.fillStyle = '#f59e0b';
                    ctx.beginPath();
                    ctx.arc(startPoint.x, startPoint.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ç™½ã„ç¸å–ã‚Š
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
            
            // é€šå¸¸ã®ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ï¼ˆ90åº¦ï¼‰
            if (!snapToStart) {
                // æ°´å¹³ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³
                if (Math.abs(y - lastPoint.y) < 30) {
                    ctx.strokeStyle = '#10b981';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.moveTo(0, lastPoint.y);
                    ctx.lineTo(canvas.width, lastPoint.y);
                    ctx.stroke();
                }
                
                // å‚ç›´ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³
                if (Math.abs(x - lastPoint.x) < 30) {
                    ctx.strokeStyle = '#10b981';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.moveTo(lastPoint.x, 0);
                    ctx.lineTo(lastPoint.x, canvas.height);
                    ctx.stroke();
                }
            }
            
            // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç·š
            ctx.strokeStyle = snapToStart ? '#f59e0b' : '#667eea';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(lastPoint.x, lastPoint.y);
            ctx.lineTo(x, y);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        // æ°´å¹³ãƒ»å‚ç›´ã«ã‚¹ãƒŠãƒƒãƒ—
        function snapToAxis(x1, y1, x2, y2) {
            const dx = Math.abs(x2 - x1);
            const dy = Math.abs(y2 - y1);
            const threshold = 30; // ã‚¹ãƒŠãƒƒãƒ—åˆ¤å®šã®é–¾å€¤
            
            // æ°´å¹³ã«è¿‘ã„
            if (dx > dy && dy < threshold) {
                return { x: x2, y: y1 };
            }
            // å‚ç›´ã«è¿‘ã„
            else if (dy > dx && dx < threshold) {
                return { x: x1, y: y2 };
            }
            // æ–œã‚ï¼ˆãã®ã¾ã¾ï¼‰
            return { x: x2, y: y2 };
        }
        
        // ç·šãŒæ–œã‚ã‹ã©ã†ã‹åˆ¤å®š
        function isLineDiagonal(line) {
            const dx = Math.abs(line.x2 - line.x1);
            const dy = Math.abs(line.y2 - line.y1);
            const threshold = 5;
            
            // æ°´å¹³ã§ã‚‚å‚ç›´ã§ã‚‚ãªã„å ´åˆã¯æ–œã‚
            return dx > threshold && dy > threshold;
        }
        
        // ç·šã®è§’åº¦ã‚’è¨ˆç®—ï¼ˆåº¦ï¼‰
        function getLineAngle(line) {
            const dx = line.x2 - line.x1;
            const dy = line.y2 - line.y1;
            const radians = Math.atan2(dy, dx);
            return radians * (180 / Math.PI);
        }
        
        // ã‚¿ãƒƒãƒæç”»å‡¦ç†
        function handleTouchDrawing(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let x = (touch.clientX - rect.left) * scaleX;
            let y = (touch.clientY - rect.top) * scaleY;
            
            // ã‚¹ãƒŠãƒƒãƒ—å‡¦ç†ï¼ˆ2ç‚¹ç›®ä»¥é™ï¼‰
            if (drawingPoints.length > 0) {
                const lastPoint = drawingPoints[drawingPoints.length - 1];
                const snapped = snapToAxis(lastPoint.x, lastPoint.y, x, y);
                x = snapped.x;
                y = snapped.y;
            }
            
            // å§‹ç‚¹ã¸ã®å¸ç€ã¨é–‰ã˜ã‚‹ç¢ºèªï¼ˆ3ç‚¹ä»¥ä¸Šã‚ã‚‹å ´åˆï¼‰
            if (drawingPoints.length >= 3) {
                const startPoint = drawingPoints[0];
                const distToStart = Math.sqrt(Math.pow(x - startPoint.x, 2) + Math.pow(y - startPoint.y, 2));
                
                // å§‹ç‚¹ã‹ã‚‰40pxä»¥å†…ï¼ˆã‚¿ãƒƒãƒæ“ä½œã¯åºƒã‚ã«ï¼‰
                if (distToStart < 40) {
                    if (confirm('å›³å½¢ã‚’é–‰ã˜ã¾ã™ã‹ï¼Ÿ\nï¼ˆå§‹ç‚¹ã¨çµ‚ç‚¹ã‚’çµåˆã—ã¾ã™ï¼‰')) {
                        // å§‹ç‚¹ã«å¸ç€
                        x = startPoint.x;
                        y = startPoint.y;
                        
                        // ç‚¹ã‚’è¿½åŠ 
                        drawingPoints.push({ x, y });
                        
                        // æœ€å¾Œã®ç·šã‚’ä½œæˆ
                        const prevPoint = drawingPoints[drawingPoints.length - 2];
                        const currPoint = drawingPoints[drawingPoints.length - 1];
                        
                        const id = String.fromCharCode(65 + lines.length);
                        lines.push({
                            id: id,
                            x1: prevPoint.x,
                            y1: prevPoint.y,
                            x2: currPoint.x,
                            y2: currPoint.y,
                            name: `è¾º${id}`,
                            start: 'wall',
                            end: 'wall'
                        });
                        
                        // ã‚³ãƒ¼ãƒŠãƒ¼ã®è‡ªå‹•è¨­å®š
                        autoSetCorners();
                        
                        // ä½œå›³çµ‚äº†
                        finishDrawing();
                        return;
                    } else {
                        // ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ãŸå ´åˆã¯ä½•ã‚‚ã—ãªã„
                        return;
                    }
                }
            }
            
            // æ—¢å­˜ã®ç‚¹ã‚’ã‚¿ãƒƒãƒ—ã—ãŸã‹åˆ¤å®šï¼ˆãŸã ã—å§‹ç‚¹ã¯é™¤ãï¼‰
            const clickRadius = 25;
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                // å§‹ç‚¹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆ3ç‚¹ä»¥ä¸Šã‚ã‚‹å ´åˆï¼‰
                let isStartPoint = false;
                if (drawingPoints.length >= 3 && i === 0) {
                    const startPoint = drawingPoints[0];
                    const distToStart = Math.sqrt(Math.pow(line.x1 - startPoint.x, 2) + Math.pow(line.y1 - startPoint.y, 2));
                    isStartPoint = distToStart < 5; // å§‹ç‚¹ã¨åŒã˜ä½ç½®ãªã‚‰
                }
                
                const distStart = Math.sqrt(Math.pow(x - line.x1, 2) + Math.pow(y - line.y1, 2));
                const distEnd = Math.sqrt(Math.pow(x - line.x2, 2) + Math.pow(y - line.y2, 2));
                
                // å§‹ç‚¹ä»¥å¤–ã®æ—¢å­˜ã®ç‚¹ã‚’ã‚¿ãƒƒãƒ—ã—ãŸå ´åˆã¯ç„¡è¦–
                if (!isStartPoint && distStart < clickRadius) {
                    return;
                }
                if (distEnd < clickRadius) {
                    return;
                }
            }
            
            // ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—åˆ¤å®š
            const currentTime = new Date().getTime();
            const timeDiff = currentTime - lastTapTime;
            lastTapTime = currentTime;
            
            if (timeDiff < 500 && drawingPoints.length > 0) {
                finishDrawing();
                return;
            }
            
            // ç‚¹ã‚’è¿½åŠ 
            drawingPoints.push({ x, y });
            
            // 2ç‚¹ä»¥ä¸Šã‚ã‚Œã°ç·šã‚’ä½œæˆ
            if (drawingPoints.length >= 2) {
                const prevPoint = drawingPoints[drawingPoints.length - 2];
                const currPoint = drawingPoints[drawingPoints.length - 1];
                
                const id = String.fromCharCode(65 + lines.length);
                lines.push({
                    id: id,
                    x1: prevPoint.x,
                    y1: prevPoint.y,
                    x2: currPoint.x,
                    y2: currPoint.y,
                    name: `è¾º${id}`,
                    start: 'wall',
                    end: 'wall'
                });
                
                // ã‚³ãƒ¼ãƒŠãƒ¼ã®è‡ªå‹•è¨­å®š
                autoSetCorners();
            }
            
            drawLines();
            updateDrawingControls();
        }
        
        // ã‚¿ãƒƒãƒç§»å‹•æ™‚ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
        function handleTouchDrawingMove(e) {
            if (drawingPoints.length === 0) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let x = (touch.clientX - rect.left) * scaleX;
            let y = (touch.clientY - rect.top) * scaleY;
            
            // ã‚¹ãƒŠãƒƒãƒ—å‡¦ç†
            const lastPoint = drawingPoints[drawingPoints.length - 1];
            const snapped = snapToAxis(lastPoint.x, lastPoint.y, x, y);
            x = snapped.x;
            y = snapped.y;
            
            drawLines();
            
            // å§‹ç‚¹ã¸ã®ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã¨å¸ç€ï¼ˆ3ç‚¹ä»¥ä¸Šã‚ã‚‹å ´åˆï¼‰
            let snapToStart = false;
            if (drawingPoints.length >= 3) {
                const startPoint = drawingPoints[0];
                const threshold = 15; // ã‚¿ãƒƒãƒæ“ä½œã¯å°‘ã—åºƒã‚ã«
                
                // æ°´å¹³ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ï¼ˆYåº§æ¨™ãŒå§‹ç‚¹ã¨è¿‘ã„å ´åˆï¼‰
                if (Math.abs(y - startPoint.y) < threshold) {
                    // å§‹ç‚¹ã«å‘ã‹ã£ã¦æ°´å¹³ç·šã‚’å¼•ã
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(x, startPoint.y);
                    ctx.lineTo(startPoint.x, startPoint.y);
                    ctx.stroke();
                    
                    // Yåº§æ¨™ã‚’å§‹ç‚¹ã«åˆã‚ã›ã‚‹
                    y = startPoint.y;
                    
                    // Xåº§æ¨™ã‚‚å§‹ç‚¹ã¨è¿‘ã„å ´åˆã¯å¸ç€
                    if (Math.abs(x - startPoint.x) < threshold) {
                        x = startPoint.x;
                        snapToStart = true;
                    }
                }
                
                // å‚ç›´ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ï¼ˆXåº§æ¨™ãŒå§‹ç‚¹ã¨è¿‘ã„å ´åˆï¼‰
                if (Math.abs(x - startPoint.x) < threshold) {
                    // å§‹ç‚¹ã«å‘ã‹ã£ã¦å‚ç›´ç·šã‚’å¼•ã
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(startPoint.x, y);
                    ctx.lineTo(startPoint.x, startPoint.y);
                    ctx.stroke();
                    
                    // Xåº§æ¨™ã‚’å§‹ç‚¹ã«åˆã‚ã›ã‚‹
                    x = startPoint.x;
                    
                    // Yåº§æ¨™ã‚‚å§‹ç‚¹ã¨è¿‘ã„å ´åˆã¯å¸ç€
                    if (Math.abs(y - startPoint.y) < threshold) {
                        y = startPoint.y;
                        snapToStart = true;
                    }
                }
                
                // å§‹ç‚¹ã¨åˆè‡´ã—ãŸå ´åˆã€å§‹ç‚¹ã‚’å¤§ããè¡¨ç¤º
                if (snapToStart) {
                    ctx.fillStyle = '#f59e0b';
                    ctx.beginPath();
                    ctx.arc(startPoint.x, startPoint.y, 10, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ç™½ã„ç¸å–ã‚Š
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
            
            // é€šå¸¸ã®ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ï¼ˆ90åº¦ï¼‰
            if (!snapToStart) {
                // æ°´å¹³ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³
                if (Math.abs(y - lastPoint.y) < 30) {
                    ctx.strokeStyle = '#10b981';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.moveTo(0, lastPoint.y);
                    ctx.lineTo(canvas.width, lastPoint.y);
                    ctx.stroke();
                }
                
                // å‚ç›´ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³
                if (Math.abs(x - lastPoint.x) < 30) {
                    ctx.strokeStyle = '#10b981';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.moveTo(lastPoint.x, 0);
                    ctx.lineTo(lastPoint.x, canvas.height);
                    ctx.stroke();
                }
            }
            
            // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç·š
            ctx.strokeStyle = snapToStart ? '#f59e0b' : '#667eea';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(lastPoint.x, lastPoint.y);
            ctx.lineTo(x, y);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        // ä½œå›³çµ‚äº†
        function finishDrawing() {
            drawingPoints = [];
            drawLines();
            
            // ä½œå›³ç”¨ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤
            canvas.removeEventListener('click', handleCanvasClick);
            canvas.removeEventListener('mousemove', handleCanvasMouseMove);
            canvas.removeEventListener('touchstart', handleTouchDrawing);
            canvas.removeEventListener('touchmove', handleTouchDrawingMove);
            
            // ç‚¹ã‚¯ãƒªãƒƒã‚¯ç”¨ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¨­å®š
            canvas.addEventListener('click', handlePointClick);
            canvas.addEventListener('touchend', handlePointClickTouch);
            
            if (lines.length > 0) {
                createInputs();
            }
            
            updateDrawingControls();
        }
        
        // ç‚¹ã®ã‚¯ãƒªãƒƒã‚¯å‡¦ç†
        function handlePointClick(e) {
            if (isDrawing || isDragging) return;
            if (drawingPoints.length > 0) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.offsetX || e.clientX - rect.left) * scaleX;
            const y = (e.offsetY || e.clientY - rect.top) * scaleY;
            
            const clickRadius = 20;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                const distStart = Math.sqrt(Math.pow(x - line.x1, 2) + Math.pow(y - line.y1, 2));
                if (distStart < clickRadius) {
                    // å…¥åŠ›æ¬„ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«&ãƒã‚¤ãƒ©ã‚¤ãƒˆã®ã¿ï¼ˆçŠ¶æ…‹å¤‰æ›´ã—ãªã„ï¼‰
                    scrollToInput(line.id);
                    return;
                }
                
                const distEnd = Math.sqrt(Math.pow(x - line.x2, 2) + Math.pow(y - line.y2, 2));
                if (distEnd < clickRadius) {
                    // å…¥åŠ›æ¬„ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«&ãƒã‚¤ãƒ©ã‚¤ãƒˆã®ã¿ï¼ˆçŠ¶æ…‹å¤‰æ›´ã—ãªã„ï¼‰
                    scrollToInput(line.id);
                    return;
                }
                
                // ç·šã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‹ãƒã‚§ãƒƒã‚¯
                const distToLine = distanceToLineSegment(x, y, line.x1, line.y1, line.x2, line.y2);
                if (distToLine < 10) {
                    // å…¥åŠ›æ¬„ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«&ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                    scrollToInput(line.id);
                    return;
                }
            }
        }
        
        // ç‚¹ã‹ã‚‰ç·šåˆ†ã¸ã®æœ€çŸ­è·é›¢ã‚’è¨ˆç®—
        function distanceToLineSegment(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const lengthSquared = dx * dx + dy * dy;
            
            if (lengthSquared === 0) {
                return Math.sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1));
            }
            
            let t = ((px - x1) * dx + (py - y1) * dy) / lengthSquared;
            t = Math.max(0, Math.min(1, t));
            
            const nearestX = x1 + t * dx;
            const nearestY = y1 + t * dy;
            
            return Math.sqrt((px - nearestX) * (px - nearestX) + (py - nearestY) * (py - nearestY));
        }
        
        // å…¥åŠ›æ¬„ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«&ãƒã‚¤ãƒ©ã‚¤ãƒˆ
        function scrollToInput(lineId) {
            // DOMã®æ›´æ–°ã‚’å¾…ã¤
            setTimeout(() => {
                const inputGroup = document.querySelector(`[data-line-id="${lineId}"]`);
                if (inputGroup) {
                    // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
                    inputGroup.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    
                    // ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼ˆ2ç§’é–“ï¼‰
                    inputGroup.style.transition = 'background-color 0.3s';
                    inputGroup.style.backgroundColor = '#fef3c7';
                    
                    setTimeout(() => {
                        inputGroup.style.backgroundColor = '';
                    }, 2000);
                }
            }, 100);
        }
        
        // ã‚³ãƒ¼ãƒŠãƒ¼ã‚’è‡ªå‹•è¨­å®š
        function autoSetCorners() {
            const tolerance = 5; // åŒã˜ä½ç½®ã¨åˆ¤å®šã™ã‚‹è·é›¢
            
            // å›³å½¢ãŒé–‰ã˜ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆæœ€åˆã®ç·šã®å§‹ç‚¹ã¨æœ€å¾Œã®ç·šã®çµ‚ç‚¹ãŒåŒã˜ä½ç½®ï¼‰
            const isClosed = lines.length > 0 && 
                Math.abs(lines[0].x1 - lines[lines.length - 1].x2) < tolerance && 
                Math.abs(lines[0].y1 - lines[lines.length - 1].y2) < tolerance;
            
            // å…¨ã¦ã®ç‚¹ã‚’ãƒã‚§ãƒƒã‚¯
            for (let i = 0; i < lines.length; i++) {
                for (let j = i + 1; j < lines.length; j++) {
                    const line1 = lines[i];
                    const line2 = lines[j];
                    
                    // line1ã®å§‹ç‚¹ã¨line2ã®å§‹ç‚¹ãŒåŒã˜ä½ç½®
                    if (Math.abs(line1.x1 - line2.x1) < tolerance && Math.abs(line1.y1 - line2.y1) < tolerance) {
                        // 90åº¦ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯
                        if (is90Degrees(line1, line2, 'start', 'start')) {
                            // æœ€åˆã®ç·šã®å§‹ç‚¹ã¯ã‚³ãƒ¼ãƒŠãƒ¼ã«ã—ãªã„ï¼ˆé–‰ã˜ã¦ã„ã‚‹å ´åˆã¯é™¤ãï¼‰
                            if (i !== 0 || isClosed) line1.start = 'corner';
                            if (j !== 0 || isClosed) line2.start = 'corner';
                        } else {
                            // 90åº¦ã§ãªã„å ´åˆã¯é€šå¸¸ã®é€£å‹•
                            if ((i !== 0 || isClosed) && line1.start === 'corner') line2.start = 'corner';
                            if ((j !== 0 || isClosed) && line2.start === 'corner') line1.start = 'corner';
                        }
                    }
                    
                    // line1ã®å§‹ç‚¹ã¨line2ã®çµ‚ç‚¹ãŒåŒã˜ä½ç½®
                    if (Math.abs(line1.x1 - line2.x2) < tolerance && Math.abs(line1.y1 - line2.y2) < tolerance) {
                        // 90åº¦ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯
                        if (is90Degrees(line1, line2, 'start', 'end')) {
                            if (i !== 0 || isClosed) line1.start = 'corner';
                            // æœ€å¾Œã®ç·šã®çµ‚ç‚¹ã¯ã‚³ãƒ¼ãƒŠãƒ¼ã«ã—ãªã„ï¼ˆé–‰ã˜ã¦ã„ã‚‹å ´åˆã¯é™¤ãï¼‰
                            if (j !== lines.length - 1 || isClosed) line2.end = 'corner';
                        } else {
                            if ((i !== 0 || isClosed) && line1.start === 'corner') line2.end = 'corner';
                            if ((j !== lines.length - 1 || isClosed) && line2.end === 'corner') line1.start = 'corner';
                        }
                    }
                    
                    // line1ã®çµ‚ç‚¹ã¨line2ã®å§‹ç‚¹ãŒåŒã˜ä½ç½®
                    if (Math.abs(line1.x2 - line2.x1) < tolerance && Math.abs(line1.y2 - line2.y1) < tolerance) {
                        // 90åº¦ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯
                        if (is90Degrees(line1, line2, 'end', 'start')) {
                            // æœ€å¾Œã®ç·šã®çµ‚ç‚¹ã¯ã‚³ãƒ¼ãƒŠãƒ¼ã«ã—ãªã„ï¼ˆé–‰ã˜ã¦ã„ã‚‹å ´åˆã¯é™¤ãï¼‰
                            if (i !== lines.length - 1 || isClosed) line1.end = 'corner';
                            if (j !== 0 || isClosed) line2.start = 'corner';
                        } else {
                            if ((i !== lines.length - 1 || isClosed) && line1.end === 'corner') line2.start = 'corner';
                            if ((j !== 0 || isClosed) && line2.start === 'corner') line1.end = 'corner';
                        }
                    }
                    
                    // line1ã®çµ‚ç‚¹ã¨line2ã®çµ‚ç‚¹ãŒåŒã˜ä½ç½®
                    if (Math.abs(line1.x2 - line2.x2) < tolerance && Math.abs(line1.y2 - line2.y2) < tolerance) {
                        // 90åº¦ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯
                        if (is90Degrees(line1, line2, 'end', 'end')) {
                            // æœ€å¾Œã®ç·šã®çµ‚ç‚¹ã¯ã‚³ãƒ¼ãƒŠãƒ¼ã«ã—ãªã„ï¼ˆé–‰ã˜ã¦ã„ã‚‹å ´åˆã¯é™¤ãï¼‰
                            if (i !== lines.length - 1 || isClosed) line1.end = 'corner';
                            if (j !== lines.length - 1 || isClosed) line2.end = 'corner';
                        } else {
                            if ((i !== lines.length - 1 || isClosed) && line1.end === 'corner') line2.end = 'corner';
                            if ((j !== lines.length - 1 || isClosed) && line2.end === 'corner') line1.end = 'corner';
                        }
                    }
                }
            }
        }
        
        // 2ã¤ã®ç·šãŒ90åº¦ã‹ã©ã†ã‹åˆ¤å®š
        function is90Degrees(line1, line2, point1, point2) {
            // ç·š1ã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«
            const dx1 = line1.x2 - line1.x1;
            const dy1 = line1.y2 - line1.y1;
            
            // ç·š2ã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«
            const dx2 = line2.x2 - line2.x1;
            const dy2 = line2.y2 - line2.y1;
            
            // å†…ç©ã‚’è¨ˆç®—ï¼ˆ90åº¦ãªã‚‰0ã«è¿‘ã„ï¼‰
            const dotProduct = dx1 * dx2 + dy1 * dy2;
            const magnitude1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
            const magnitude2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
            
            if (magnitude1 === 0 || magnitude2 === 0) return false;
            
            const cosAngle = dotProduct / (magnitude1 * magnitude2);
            
            // 90åº¦ã®å ´åˆã€cosã¯0ã«è¿‘ã„ï¼ˆè¨±å®¹èª¤å·®0.1ï¼‰
            return Math.abs(cosAngle) < 0.1;
        }
        
        // ç‚¹ã®çŠ¶æ…‹ã‚’åˆ‡ã‚Šæ›¿ãˆ
        function togglePointState(lineIndex, point) {
            const line = lines[lineIndex];
            
            // ã“ã®ç‚¹ã®ã‚³ãƒ¼ãƒŠãƒ¼ã‚­ãƒ¼ã‚’å–å¾—
            const x = point === 'start' ? line.x1 : line.x2;
            const y = point === 'start' ? line.y1 : line.y2;
            const cornerKey = findCornerKey(x, y, 5);
            const corner = corners[cornerKey];
            
            // å›³å½¢ãŒé–‰ã˜ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆæœ€åˆã®ç·šã®å§‹ç‚¹ã¨æœ€å¾Œã®ç·šã®çµ‚ç‚¹ãŒåŒã˜ä½ç½®ï¼‰
            const isClosed = lines.length > 0 && 
                Math.abs(lines[0].x1 - lines[lines.length - 1].x2) < 5 && 
                Math.abs(lines[0].y1 - lines[lines.length - 1].y2) < 5;
            
            // æœ€åˆã®ç·šã®å§‹ç‚¹ã¯ã‚³ãƒ¼ãƒŠãƒ¼ã«ãªã‚Œãªã„ï¼ˆé–‰ã˜ã¦ã„ã‚‹å ´åˆã¯é™¤ãï¼‰
            const isFirstLineStart = (lineIndex === 0 && point === 'start' && !isClosed);
            
            // æœ€å¾Œã®ç·šã®çµ‚ç‚¹ã¯ã‚³ãƒ¼ãƒŠãƒ¼ã«ãªã‚Œãªã„ï¼ˆé–‰ã˜ã¦ã„ã‚‹å ´åˆã¯é™¤ãï¼‰
            const isLastLineEnd = (lineIndex === lines.length - 1 && point === 'end' && !isClosed);
            
            // æ®µå·®ãŒã‚ã‚‹ã‚³ãƒ¼ãƒŠãƒ¼ã®å ´åˆã¯ã€ã‚³ãƒ¼ãƒŠãƒ¼é¸æŠã‚’é™¤å¤–
            const hasStepAtCorner = corner && corner.hasStep;
            
            // é¸æŠå¯èƒ½ãªçŠ¶æ…‹ã‚’æ±ºå®š
            let states;
            if (isFirstLineStart || isLastLineEnd || hasStepAtCorner) {
                states = ['end', 'wall'];
            } else {
                states = ['corner', 'end', 'wall'];
            }
            
            const currentState = lines[lineIndex][point] || 'wall';
            const currentIndex = states.indexOf(currentState);
            const nextIndex = (currentIndex + 1) % states.length;
            lines[lineIndex][point] = states[nextIndex];
            
            // ã‚³ãƒ¼ãƒŠãƒ¼ã«å¤‰æ›´ã—ãŸå ´åˆã€åŒã˜ä½ç½®ã®ç‚¹ã‚‚é€£å‹•
            if (lines[lineIndex][point] === 'corner') {
                autoSetCorners();
            }
            
            // æ®µå·®ãŒã‚ã‚‹ã‚³ãƒ¼ãƒŠãƒ¼ã§çŠ¶æ…‹ã‚’å¤‰æ›´ã—ãŸå ´åˆã€æ¥ç¶šã—ã¦ã„ã‚‹è¾ºã®çŠ¶æ…‹ã‚’è‡ªå‹•èª¿æ•´
            if (corner && corner.hasStep && corner.lines.length >= 2) {
                syncCornerStatesWithStep(cornerKey, line.id, point, lines[lineIndex][point]);
            }
        }
        
        
        function handleTouch(e) {
            e.preventDefault();
            const touch = e.touches[0] || e.changedTouches[0];
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (touch.clientX - rect.left) * scaleX;
            const y = (touch.clientY - rect.top) * scaleY;
            
            if (e.type === 'touchstart') {
                startDrawing({ offsetX: x, offsetY: y });
            } else if (e.type === 'touchmove') {
                drawing({ offsetX: x, offsetY: y });
            } else if (e.type === 'touchend') {
                endDrawing({ offsetX: x, offsetY: y });
            }
        }
        
        function startDrawing(e) {
            isDrawing = true;
            isDragging = false; // ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹æ™‚ã¯false
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            startPoint = { 
                x: (e.offsetX || e.clientX - rect.left) * scaleX, 
                y: (e.offsetY || e.clientY - rect.top) * scaleY 
            };
        }
        
        function drawing(e) {
            if (!isDrawing) return;
            
            isDragging = true; // ãƒã‚¦ã‚¹ç§»å‹•ã—ãŸã‚‰ãƒ‰ãƒ©ãƒƒã‚°ä¸­
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.offsetX || e.clientX - rect.left) * scaleX;
            const y = (e.offsetY || e.clientY - rect.top) * scaleY;
            
            // æ—¢å­˜ã®ç·šã‚’æç”»
            drawLines();
            
            // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç·šã‚’æç”»
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(startPoint.x, startPoint.y);
            ctx.lineTo(x, y);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        function endDrawing(e) {
            if (!isDrawing) return;
            
            // ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ã„ãŸå ´åˆã®ã¿ç·šã‚’å¼•ã
            if (isDragging) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.offsetX || e.clientX - rect.left) * scaleX;
                const y = (e.offsetY || e.clientY - rect.top) * scaleY;
                
                const id = String.fromCharCode(65 + lines.length);
                lines.push({
                    id: id,
                    x1: startPoint.x,
                    y1: startPoint.y,
                    x2: x,
                    y2: y,
                    name: `è¾º${id}`,
                    start: 'wall', // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯å£
                    end: 'wall'    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯å£
                });
                
                drawLines();
                createInputs(); // ç·šã‚’å¼•ã„ãŸå¾Œã«å…¥åŠ›ãƒ•ã‚©ãƒ¼ãƒ ã‚’ä½œæˆ
            }
            
            isDrawing = false;
            isDragging = false;
        }
        
        // ãƒ‘ã‚¿ãƒ¼ãƒ³ä¿å­˜
        function savePattern() {
            const name = prompt('ãƒ‘ã‚¿ãƒ¼ãƒ³åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:');
            if (!name) return;
            
            const savedPatterns = JSON.parse(localStorage.getItem('savedPatterns') || '{}');
            savedPatterns[name] = {
                lines: lines,
                dimensions: dimensions
            };
            localStorage.setItem('savedPatterns', JSON.stringify(savedPatterns));
            
            alert('ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä¿å­˜ã—ã¾ã—ãŸ');
        }
        
        // ä¿å­˜æ¸ˆã¿ãƒ‘ã‚¿ãƒ¼ãƒ³èª­ã¿è¾¼ã¿
        function loadSavedPatterns() {
            const savedPatterns = JSON.parse(localStorage.getItem('savedPatterns') || '{}');
            const keys = Object.keys(savedPatterns);
            
            if (keys.length === 0) return;
            
            document.getElementById('saved-patterns-section').style.display = 'block';
            const grid = document.getElementById('saved-patterns-grid');
            grid.innerHTML = '';
            
            keys.forEach(name => {
                const btn = document.createElement('button');
                btn.className = 'pattern-btn';
                btn.innerHTML = `
                    ${name}
                    <span class="delete-btn" onclick="event.stopPropagation(); deletePattern('${name}')">Ã—</span>
                `;
                btn.onclick = () => selectPattern(name);
                grid.appendChild(btn);
            });
        }
        
        // ã‚«ã‚¹ã‚¿ãƒ ãƒ‘ã‚¿ãƒ¼ãƒ³èª­ã¿è¾¼ã¿
        function loadCustomPattern(name) {
            const savedPatterns = JSON.parse(localStorage.getItem('savedPatterns') || '{}');
            const pattern = savedPatterns[name];
            
            if (!pattern) return;
            
            document.getElementById('pattern-title').textContent = name;
            lines = pattern.lines;
            dimensions = pattern.dimensions || {};
            
            drawLines();
            createInputs();
        }
        
        // ãƒ‘ã‚¿ãƒ¼ãƒ³å‰Šé™¤
        function deletePattern(name) {
            if (!confirm(`ã€Œ${name}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`)) return;
            
            const savedPatterns = JSON.parse(localStorage.getItem('savedPatterns') || '{}');
            delete savedPatterns[name];
            localStorage.setItem('savedPatterns', JSON.stringify(savedPatterns));
            
            loadSavedPatterns();
        }
        
        // ã‚¯ãƒªã‚¢ï¼ˆå…¨å‰Šé™¤ï¼‰
        // ã‚¯ãƒªã‚¢ï¼ˆå…¨å‰Šé™¤ï¼‰
        
        // æœ€å¾Œã®ç·šã‚’å‰Šé™¤
        function undoLastLine() {
            if (lines.length === 0) return;
            
            // ä½œå›³çµ‚äº†å¾Œï¼ˆdrawingPointsãŒç©ºï¼‰ã®å ´åˆã¯ã€drawingPointsã‚’å¾©å…ƒã—ã¦ã‹ã‚‰å‰Šé™¤
            if (drawingPoints.length === 0 && lines.length > 0) {
                // å…¨ã¦ã®ç‚¹ã‚’drawingPointsã«å¾©å…ƒ
                drawingPoints = [];
                
                // æœ€åˆã®ç·šã®å§‹ç‚¹ã‚’è¿½åŠ 
                drawingPoints.push({ x: lines[0].x1, y: lines[0].y1 });
                
                // å…¨ã¦ã®ç·šã®çµ‚ç‚¹ã‚’è¿½åŠ 
                for (let i = 0; i < lines.length; i++) {
                    drawingPoints.push({ x: lines[i].x2, y: lines[i].y2 });
                }
                
                // ç‚¹ã‚¯ãƒªãƒƒã‚¯ç”¨ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤
                canvas.removeEventListener('click', handlePointClick);
                canvas.removeEventListener('touchend', handlePointClickTouch);
                
                // ä½œå›³ç”¨ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å†è¨­å®š
                canvas.addEventListener('click', handleCanvasClick);
                canvas.addEventListener('mousemove', handleCanvasMouseMove);
                canvas.addEventListener('touchstart', handleTouchDrawing);
                canvas.addEventListener('touchmove', handleTouchDrawingMove);
            }
            
            // æœ€å¾Œã®ç·šã‚’å‰Šé™¤
            const lastLineId = lines[lines.length - 1].id;
            lines.pop();
            delete dimensions[lastLineId];
            
            // drawingPointsã‹ã‚‰æœ€å¾Œã®ç‚¹ã‚’å‰Šé™¤ï¼ˆ1ã¤å‰ã®ç‚¹ã‹ã‚‰å†é–‹ã§ãã‚‹ã‚ˆã†ã«ï¼‰
            if (drawingPoints.length > 1) {
                drawingPoints.pop();
            }
            
            drawLines();
            createInputs();
            calculate();
            updateDrawingControls();
        }
        
        // æç”»ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã®è¡¨ç¤ºãƒ»éè¡¨ç¤º
        function updateDrawingControls() {
            const controls = document.getElementById('drawing-controls');
            if (controls) {
                controls.style.display = (drawingPoints.length > 0 || currentPattern === 'custom') ? 'flex' : 'none';
            }
        }
        
        // æˆ»ã‚‹
        function backToSelect() {
            document.getElementById('pattern-select-screen').style.display = 'block';
            document.getElementById('measurement-screen').style.display = 'none';
            loadSavedPatterns();
        }
        
        // ==============================================
        // ä¿å­˜ãƒ»å…±æœ‰æ©Ÿèƒ½
        // ==============================================
        
        // PDFã¨ã—ã¦ä¿å­˜
        function downloadAsPDF() {
            const canvas = document.getElementById('result-canvas');
            if (!canvas) {
                alert('è¨ˆç®—çµæœãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }
            
            try {
                // jsPDFã‚’ä½¿ç”¨ã—ã¦PDFã‚’ä½œæˆ
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF({
                    orientation: 'portrait',
                    unit: 'mm',
                    format: 'a4'
                });
                
                // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ç”»åƒã¨ã—ã¦å–å¾—
                const imgData = canvas.toDataURL('image/png');
                
                // A4ã‚µã‚¤ã‚ºã«åˆã‚ã›ã¦ç”»åƒã‚’é…ç½®
                const imgWidth = 190; // A4å¹… - ä½™ç™½
                const imgHeight = (canvas.height * imgWidth) / canvas.width;
                
                // ã‚¿ã‚¤ãƒˆãƒ«ã‚’è¿½åŠ 
                pdf.setFontSize(16);
                pdf.text('èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ  - è¨ˆç®—çµæœ', 105, 15, { align: 'center' });
                
                // æ—¥ä»˜ã‚’è¿½åŠ 
                const date = new Date().toLocaleDateString('ja-JP');
                pdf.setFontSize(10);
                pdf.text(date, 105, 22, { align: 'center' });
                
                // ç”»åƒã‚’è¿½åŠ 
                pdf.addImage(imgData, 'PNG', 10, 30, imgWidth, imgHeight);
                
                // ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç”Ÿæˆ
                const filename = `èº¯ä½“æ¡å¯¸_${new Date().toISOString().slice(0,10)}.pdf`;
                
                // PDFã‚’ä¿å­˜
                pdf.save(filename);
                
            } catch (error) {
                console.error('PDFä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
                alert('PDFã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ');
            }
        }
        
        // PNGã¨ã—ã¦ä¿å­˜
        function downloadAsPNG() {
            const canvas = document.getElementById('result-canvas');
            if (!canvas) {
                alert('è¨ˆç®—çµæœãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }
            
            try {
                // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ç”»åƒã¨ã—ã¦å–å¾—
                const imgData = canvas.toDataURL('image/png');
                
                // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒªãƒ³ã‚¯ã‚’ä½œæˆ
                const link = document.createElement('a');
                link.download = `èº¯ä½“æ¡å¯¸_${new Date().toISOString().slice(0,10)}.png`;
                link.href = imgData;
                link.click();
                
            } catch (error) {
                console.error('PNGä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
                alert('ç”»åƒã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ');
            }
        }
        
        // å…±æœ‰æ©Ÿèƒ½ï¼ˆWeb Share APIä½¿ç”¨ï¼‰
        async function shareResult() {
            const canvas = document.getElementById('result-canvas');
            if (!canvas) {
                alert('è¨ˆç®—çµæœãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }
            
            try {
                // Web Share APIãŒåˆ©ç”¨å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
                if (!navigator.share && !navigator.canShare) {
                    // Web Share APIãŒä½¿ãˆãªã„å ´åˆã€PNGãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œ
                    alert('ã“ã®ç«¯æœ«ã§ã¯å…±æœ‰æ©Ÿèƒ½ãŒä½¿ãˆã¾ã›ã‚“ã€‚ç”»åƒã¨ã—ã¦ä¿å­˜ã—ã¾ã™ã€‚');
                    downloadAsPNG();
                    return;
                }
                
                // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’Blobã«å¤‰æ›
                canvas.toBlob(async (blob) => {
                    try {
                        const file = new File([blob], `èº¯ä½“æ¡å¯¸_${new Date().toISOString().slice(0,10)}.png`, { type: 'image/png' });
                        
                        const shareData = {
                            title: 'èº¯ä½“æ¡å¯¸ã‚·ã‚¹ãƒ†ãƒ  - è¨ˆç®—çµæœ',
                            text: 'èº¯ä½“æ¡å¯¸ã®è¨ˆç®—çµæœã§ã™',
                            files: [file]
                        };
                        
                        // å…±æœ‰å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
                        if (navigator.canShare && !navigator.canShare(shareData)) {
                            // ãƒ•ã‚¡ã‚¤ãƒ«å…±æœ‰ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„å ´åˆã€ãƒ†ã‚­ã‚¹ãƒˆã®ã¿å…±æœ‰
                            await navigator.share({
                                title: shareData.title,
                                text: shareData.text,
                                url: window.location.href
                            });
                        } else {
                            // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å«ã‚ã¦å…±æœ‰
                            await navigator.share(shareData);
                        }
                        
                    } catch (shareError) {
                        if (shareError.name !== 'AbortError') {
                            console.error('å…±æœ‰ã‚¨ãƒ©ãƒ¼:', shareError);
                            alert('å…±æœ‰ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ç”»åƒã¨ã—ã¦ä¿å­˜ã—ã¾ã™ã€‚');
                            downloadAsPNG();
                        }
                    }
                }, 'image/png');
                
            } catch (error) {
                console.error('å…±æœ‰ã‚¨ãƒ©ãƒ¼:', error);
                alert('å…±æœ‰ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ç”»åƒã¨ã—ã¦ä¿å­˜ã—ã¾ã™ã€‚');
                downloadAsPNG();
            }
        }
    </script>
</body>
</html>
